<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[代数中的 群 环 域]]></title>
    <url>%2F2018%2F11%2F07%2Fgroup-ring-field-in-mathematics%2F</url>
    <content type="text"><![CDATA[最近总是碰到群环域这些东西，抽空学习了一下，写篇博客加深印象。本文综合各种博客，百科写成。本人不是学数学出身。本文只是自己的理解。 引例 整数加法群最常见的群之一是整数集 $\mathbb {Z}$ 和整数的加法所构成的群。它由以下数列组成：$…, −4, −3, −2, −1, 0, 1, 2, 3, 4, …$群有四个公理。以上面的加法群为例。如下： 封闭性： 对于任何两个整数$a$和$b$，它们的和$a + b$也是整数。换句话说，在任何时候，把两个整数相加都能得出整数的结果。这个性质叫做在加法下封闭。 结合律： 对于任何整数$a$, $b$和$c$，$(a + b) + c = a +（b + c）$。用话语来表达，先把a加到b，然后把它们的和加到c，所得到的结果与把a加到b与c的和是相等的。这个性质叫做结合律。 单位元： 如果$a$是任何整数，那么$0 + a = a + 0 = a$。零叫做加法的单位元，因为把它加到任何整数都得到相同的整数。 逆元： 对于任何整数$a$，存在另一个整数$b$使得$a + b = b + a = 0$。整数$b$叫做整数$a$的逆元，记为$−a$。 群群的定义群$(G,·)$是由集合$G$和二元运算$·$构成的，符合以下四个性质（称“群公理”）的数学结构。其中，二元运算结合任何两个元素$a$和$b$而形成另一个元素，记为$a·b$，符号$·$是具体的运算，比如整数加法。 群的四个公理 封闭性： 对于所有$G$中$a$, $b$，运算$a·b$的结果也在$G$中。 结合律： 对于所有$G$中的$a$, $b$和$c$，等式$(a·b)·c = a· (b·c)$成立。 单位元： 存在$G$中的一个元素$e$，使得对于所有$G$中的元素$a$，总有等式$e·a = a·e = a$成立。 逆元： 对于每个$G$中的$a$，存在$G$中的一个元素$b$使得总有$a·b = b·a = e$，此处$e$为单位元。 阿贝尔群群运算的次序很重要，把元素$a$与元素$b$结合，所得到的结果不一定与把元素$b$与元素$a$结合相同；$a\cdot b=b\cdot a$(交换律)不一定恒成立。阿贝尔群的群运算符合交换律，因此阿贝尔群也被称为交换群。它由自身的集合$G$和二元运算$*$构成。它除了满足一般的群公理，封闭性、结合律、单位元、逆元之外，还满足交换律公理$a*b=b*a$因为阿贝尔群的群运算满足交换律和结合律，群元素乘积的值与乘法运算时的次序无关。群运算不满足交换律的群被称为“非阿贝尔群”，或“非交换群”。阿贝尔群有两种主要运算符号,加法和乘法。 约定 运算 单位元 幂 逆元 加法运算 $x + y$ $0$ $nx$ $−x$ 乘法运算 $x * y$或$xy$ $e$或$1$ $x^n$ $x^{−1}$ 半群半群的运算经常指示为乘号。集合$S$和其上的二元运算$·$: $S×S \rightarrow S$。若$·$满足结合律，即：$\forall x,y,z \in S$，有$(x·y)·z=x·(y·z)$，则称有序对$(S,·)$为半群，运算$·$称为该半群的乘法。即半群只满足群的四个公理中的封闭性和结合律。 环环的定义集合$R$和定义于其上的二元运算$+$和$·$，$(R, +, ·)$构成一个环，若它们满足： $(R, +)$形成一个交换群，其单位元称为零元，记作$0$。即： 封闭性： $(R, +)$是封闭的 结合律： $(a + b) + c = a + (b + c)$ 单位元： $0 + a = a + 0 = a$ 逆元： $\forall a, \exists -a$, 满足$a + −a = −a + a = 0$ 交换律： $(a + b) = (b + a)$ $(R, ·)$形成一个半群。即： 封闭性： $(R, ·)$是封闭的 结合律： $(a·b)·c = a·(b·c)$ 乘法关于加法满足分配律。即： $a·(b + c) = (a·b) + (a·c)$ $(a + b)·c = (a·c) + (b·c)$ 就是一个交换群和一个半群的结合。环在群的基础上限制更加严格了一些。 除环除环（division ring），又译反对称体（skew field），是一类特殊的环，在环内除法运算有效。除环内必有非$0$元素，且环内所有的非$0$量都有对应的倒数（比如说，对于$x$来说，存在数$a$，使得 $a·x = x·a = 1$）。除环不一定是交换环。换种说法，一个环是除环当且仅当其可逆元群包含了环中所有的非零元素。也就是说，$(R, ·)$有乘法单位元，并且每个非零元素都有对应的乘法逆元。即，在环的基础上要求$(R, ·)$是群。 域非正式的讲，域是种集合，集合中的元素可以做两种运算，”加法”： $a+b$和”乘法”： $a\cdot b$, 且要求集合中任意元素 $a$ 有加法逆元 $-a$，对所有非零元素 $b$ 有乘法逆元 $b^{-1}$ ，这种性质让我们可以用以下方法来定义加法和乘法的”反运算”，减法： $a-b$ 和除法 $a/b$$a-b=a+(-b)$$a/b=a\cdot b^{-1}$在抽象代数中，域（Field）是一种可进行加、减、乘和除（除了除以零之外，“零”即加法单位元）运算的代数结构。域的概念是数域以及四则运算的推广。域是环的一种。域和一般的环的区别在于域要求它的元素（除零元之外）可以进行除法运算，这等于说每个非零的元素都要有乘法逆元。域中的运算关于乘法是可交换的。若乘法运算没有要求可交换则称为除环，division ring或skew field。 域的定义一域是交换性除环。 域的定义二域是一种交换环$(F, +, *)$，当中加法单位元$0$不等于乘法单位元$1$，且所有非零元素有乘法逆元。 域的定义三域是个集合 $F$ 且带有加法和乘法两种运算，这里“运算”可以想成是种映射，对任意两元素 $a,b\in F$ ，这映射将此两元素对应到某元素，且这些运算满足如下性质： 封闭性： 在加法运算上封闭，对所有属于$F$的 $a, b$， $a+b$属于$F$ 在乘法运算上封闭，对所有属于$F$的 $a, b$， $a*b$属于$F$ 结合律： 加法有结合律，对所有属于$F$的 $a, b, c$， $(a+b)+c=a+(b+c)$ 乘法有结合律，对所有属于$F$的 $a, b, c$， $(a*b)*c=a*(b*c)$ 单位元： 加法单位元，在$F$中有元素$0$，使得所有 $a \in F$，$a+0=a$ 乘法单位元，在$F$中有元素$1$，使得所有 $a \in F$，$a*1=a$ 加法单位元$0$不等于乘法单位元$1$ 逆元： 加法逆元，对所有属于$F$的 $a$，存在 $-a$ 使得 $a+(-a)=0$ 乘法逆元，对所有属于$F$的 $a$ 且 $a \ne 0$，存在 $a^{-1}$ 使得 $a*a^{-1}=1$ 交换律： 加法交换律，对所有属于$F$的 $a, b$， $a+b=b+a$ 乘法交换律，对所有属于$F$的 $a, b$， $a*b=b*a$ 分配律： 对所有属于$F$的 $a, b, c$，有$a·(b + c) = (a·b) + (a·c)$ 对所有属于$F$的 $a, b, c$，有$(a + b)·c = (a·c) + (b·c)$ 其中$0 \ne 1$的要求排除了平凡的只由一个元素组成的域。由以上性质可以得出一些最基本的推论：$−(a * b) =(−a)* b = a *(−b)$$a * 0 = 0$如果$a * b = 0$，则要么$a = 0$，要么$b = 0$域在环的基础上限制更加严格了一些。]]></content>
      <categories>
        <category>数学</category>
        <category>代数</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>代数</tag>
        <tag>群论</tag>
        <tag>环论</tag>
        <tag>域论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM CodeForces 1006 B 题解 贪心]]></title>
    <url>%2F2018%2F07%2F24%2Facm-cf-1006b-greedy%2F</url>
    <content type="text"><![CDATA[这是一道简单的贪心，在输入的时候记录下前k个最大数。然后在顺序扫一遍序列，将这k个数找出来。每找到一个，就立即划分一组，找到最后一个时，如果后边还有没遍历完的。那么就将剩下的数并到最后一组。 题目B. Polycarp’s Practice 限制time limit per test: 2 secondsmemory limit per test: 256 megabytesinput: standard inputoutput: standard output 描述Polycarp is practicing his problem solving skill. He has a list of $n$ problems with difficulties $a_1,a_2,…,a_n$, respectively. His plan is to practice for exactly $k$ days. Each day he has to solve at least one problem from his list. Polycarp solves the problems in the order they are given in his list, he cannot skip any problem from his list. He has to solve all $n$ problems in exactly $k$ days.Thus, each day Polycarp solves a contiguous sequence of (consecutive) problems from the start of the list. He can’t skip problems or solve them multiple times. As a result, in $k$ days he will solve all the $n$ problems.The profit of the $j^{th}$ day of Polycarp’s practice is the maximum among all the difficulties of problems Polycarp solves during the $j^{th}$ day (i.e. if he solves problems with indices from $l$ to $r$ during a day, then the profit of the day is $max_{l \le i \le r} a_i$). The total profit of his practice is the sum of the profits over all $k$ days of his practice.You want to help Polycarp to get the maximum possible total profit over all valid ways to solve problems. Your task is to distribute all $n$problems between $k$ days satisfying the conditions above in such a way, that the total profit is maximum.For example, if $n=8,k=3$ and $a=[5,4,2,6,5,1,9,2]$, one of the possible distributions with maximum total profit is: $[5,4,2],[6,5],[1,9,2]$. Here the total profit equals $5+6+9=20$. 输入格式The first line of the input contains two integers $n$ and $k$ $(1 \le k \le n \le 2000)$ — the number of problems and the number of days, respectively.The second line of the input contains $n$ integers $a_1,a_2,…,a_n$ $(1 \le a_i \le 2000)$ — difficulties of problems in Polycarp’s list, in the order they are placed in the list (i.e. in the order Polycarp will solve them). 输出格式In the first line of the output print the maximum possible total profit.In the second line print exactly $k$ positive integers $t_1,t_2,…,t_k$ ($t_1+t_2+⋯+t_k$ must equal $n$), where $t_j$ means the number of problems Polycarp will solve during the $j^{th}$ day in order to achieve the maximum possible total profit of his practice.If there are many possible answers, you may print any of them. 样本128 35 4 2 6 5 1 9 2 12203 2 3 125 11 1 1 1 1 1215 124 21 2000 2000 2 1240002 2 提示The first example is described in the problem statement.In the second example there is only one possible distribution.In the third example the best answer is to distribute problems in the following way: $[1,2000],[2000,2]$. The total profit of this distribution is $2000+2000=4000$. 思路这是一道简单的贪心，在输入的时候记录下前k个最大数。然后在顺序扫一遍序列，将这k个数找出来。每找到一个，就立即划分一组，找到最后一个时，如果后边还有没遍历完的。那么就将剩下的数并到最后一组。简单说下代码，cnt[i]最开始表示i这个数在序列中出现了几次。第21-36行，minval存的是前k个最大数中最小的那个数。然后这个时候，ret就跟着计算出来了。并且这个时候cnt数组的含义就变了。cnti含义是i这个数还剩几个没找到。这个找没找到是用在后边划分组用的。res数组是用来存储各组的数的个数的。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int n, k;int num[2010];int cnt[2010];int res[2010];int main()&#123; scanf("%d%d", &amp;n, &amp;k); memset(cnt, 0, sizeof cnt); memset(res, 0, sizeof res); for (int i = 0; i &lt; n; i++)&#123; scanf("%d", &amp;num[i]); cnt[num[i]]++; &#125; int minval = 0; int tmp = 0; int cur = 2000; int ret = 0; while(tmp &lt; k)&#123; while(!cnt[cur]) cur--; tmp += cnt[cur]; if(tmp &gt;= k)&#123; cnt[cur] -= tmp-k; minval = cur; &#125; ret += cur*cnt[cur]; cur--; &#125; printf("%d\n", ret); int rescur = 0; for(int i = 0; i &lt; n; i++)&#123; if(num[i] &gt;= minval &amp;&amp; cnt[num[i]])&#123; cnt[num[i]]--; res[rescur]++; if(rescur &lt; k-1) rescur++; &#125; else&#123; res[rescur]++; &#125; &#125; for(int i = 0; i &lt;= rescur; i++)&#123; printf("%d", res[i]); i == rescur ? printf("\n") : printf(" "); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>贪心</tag>
        <tag>CodeForces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客 GitHub仓库图床]]></title>
    <url>%2F2018%2F07%2F18%2Fhexo-blog-github-images-repository%2F</url>
    <content type="text"><![CDATA[随着博客的写作，其实我们比较担心的问题就是GitHub对于单个项目来说的大小是有一定限制的。而写博客中有免不了放图片。图片这种东西真是非常的占地方。网上都说用七牛云、微博、或者是什么座图床。我看了看，好像是挺麻烦的。又得注册账号，又得导出外链的。我发现github有一个图片预览的功能。于是我想到了用github这个图片预览的功能做一个图床。创造一个仓库专门存图片，如果这个仓库存满了，再创建一个仓库就好了。每个仓库能存1G的东西，所以觉得还不错。下面说一下我的思路。 原项目结构原来的项目结构是在博客的项目目录下的source文件夹下新建一个叫images的文件夹，文件夹下存图片。即博客目录/source/images可能有好多人最开始都跟我差不多的结构。我就是从这个结构开始改的。 思路这个就是GitHub图片预览的urlhttps://raw.githubusercontent.com/lmnsyunhao/blog-pica/master/acm-cf-963b-dfs/normal.png，考虑到这个url太长，而且考虑到如果github之后更改这个url，那么很有可能所有的博文的图片链接都要修改。我有了这样一个思路，我的图片链接先请求到我自己的服务器上，然后服务器重写url，301重定向到github。这样如果某一天github这个图片预览的url格式变了的话，直接改服务器那边的重写规则就好了。甚至如果以后不支持图片预览的话，也能再做打算。不用修改博文。当然，如果你们懒得用服务器重定向了的话，直接把博文中的图片改成类似上边的那种url也行。OK，开搞。 建立图片仓库GitHub新建仓库blog-pica，如果这个仓库满了，我的下一个仓库名字就是blog-picb，我是这样定义的。然后我在本地的博客项目下新建images文件夹，即博客目录/images。因为如果放到source文件夹下，在hexo g时候会在博客目录/public文件夹下生成对应的images文件夹，这样的话hexo d的时候还是会将图片上传。即，保证了图片不会在博客仓库出现然后我修改博客目录/.gitignore文件，添加一行，内容是/images/，这样的话，就会将此文件夹忽略掉。从而保证图片只在图床仓库出现，不会在备份仓库出现。然后将之前的那些图片拷贝到博客目录/images文件夹下，然后执行下面操作：12345git initgit add .git commit -m &quot;images upload&quot;git remote add origin git@github.com:lmnsyunhao/blog-pica.gitgit push -u origin master 博客目录/images这个位置只是我放图片仓库的位置，或者说你们想放哪儿放哪儿，不一定要放在博客项目内。因为现在这个图片仓库和博客项目已经没关系了。现在图片仓库已经建立好了，而且图片也已经上传到GitHub上了。 添加DNS解析如果你没有域名的话，那么不用添加解析。继续看下一节。我是在腾讯云托管的我的域名解析。所以去腾讯云添加一个解析记录。A类型记录，images.yunhao.space解析到自己的服务器IP地址。如果不会添加解析，域名解析配置教程 修改博文图片地址这个比较简单，用Notepad++或者是sublime什么的，文件夹内搜索，比如搜](/images/这个，然后全部替换一下。具体怎么搜索，我就不管了。反正就是做如下替换。将[图](/images/folder/1.png)替换成[图](http://images.yunhao.space/pica/folder/1.png如果没有域名的话，那么那个images.yunhao.space就要替换成你的服务器ip地址了。 配置nginx重写我的服务器是Ubuntu16.04 Nginx。去自己的服务器上。进行如下操作：12cd /etc/nginx/sites-availablevim 301.yunhao.space.images.conf 然后输入如下内容：123456server &#123; server_name images.yunhao.space; location ~ \.png$ &#123; rewrite ^/(pic[a-z])/(.*)$ http://raw.githubusercontent.com/lmnsyunhao/blog-$1/master/$2 permanent; &#125;&#125; 保存退出vim，然后执行下面命令：123cd ../sites-enabledln -s /etc/nginx/sites-available/301.yunhao.space.images.conf images-redirectionsystemctl restart nginx.service 这个时候应该就ok了。然后每次的时候，需要提前把图片push到仓库中才行。 仓库满了如果某一天仓库满了的话，那么就在github上新建一个仓库blog-picb，然后将那个images文件夹删除，因为这个仓库满了，所以就把本地的删了，反正远程的也不收影响。然后再在同样的位置新建一个images的仓库，连上blog-picb这个新的仓库，然后继续往里面存图片就好了。当然之后写作的时候博文中图片的url就要换成blog-picb了。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>Hexo</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git Submodule 特性详解]]></title>
    <url>%2F2018%2F07%2F18%2Fgit-submodule-learning-note%2F</url>
    <content type="text"><![CDATA[今天在搞博客的时候，遇到了嵌套git项目的问题，之前一直没多想。然后今天遇到了问题，在这里总结一下git如何优雅的处理嵌套项目。即git的submodule特性是什么。 submodule介绍当一个git项目a中嵌套了另一个git项目b，而且b没有被a的.gitignore文件忽略掉。这种情况下就会用到submodule这个特性了。在使用git命令的时候，git会检查当前项目内是否含有另一个需要监控的git项目，如果有就会弹出一个提示，提示应该用submodule来解决这种情况。为什么呢？试想一下，如果不用这种特性的话，那么每个a的commit中都会有一个b的所有的commit树。也就是成了树套树。空间复杂度就瞬间变成O(n*n)了。所以用submodule这个特性可以避免这种情况的发生。submodule在项目a中存储一个指向项目b的某次提交的commit id，在存储一些b的仓库地址等配置信息，以这种方式将b集成进来。避免了树套树的问题。接下来，我们在GitHub上面使用两个仓库来进行学习，主项目main，子模块sub。 创建现在假设，我们需要把当前GitHub上的最新版本的sub作为项目main的一个子模块加入。PS：如果你的子项目已经在主项目里了，而且并没有用submodule特性。(这种情况是可能出现的)。可以先切换到子项目根目录下，然后提交所有更改，push到远程。然后在主项目中删除子项目。然后继续进行下述操作。在主项目目录下执行命令，执行这个命令的时候子项目的远程仓库最好不是空的，不然好像.gitmodules中不会添加对应的内容。1git submodule add git@github.com:lmnsyunhao/sub.git sub 执行这个命令之后主目录下就会多出一些文件，.gitmodules和sub文件夹。sub文件夹下就是成功引入的子模块的内容。我们执行git status能够看到有两个文件已经添加到暂存区，准备提交。sub文件夹被当做一个文件进行提交。这个时候就创建好了，然后commit和push一下父项目12git commit -m &quot;add submodule&quot;git push 然后我们到GitHub上可以看到子项目后边带了一个@，@后边的就是子项目的commit id，当前父项目的commit id所对应的子项目的commit id 修改子项目首先，我们需要能对子项目进行commit。进入子项目的目录，然后向正常的操作一样，add，然后commit，然后push。1234cd subgit add .git commit -m &quot;modified something&quot;git push 修改完子项目之后，我们回到父项目的目录，会发现父项目中提示子项目有心的commit id。我们需要把父项目在提交一下，也就是将父项目中的sub文件指向最新的commit id。1234cd ..git add .git commit -m &quot;update sub&quot;git push 更新项目我们在main项目中执行操作：&lt;commit id&gt;是main的远程仓库最新的一次提交中对应的sub的commit id。12345cd maingit pullgit submodule updatecd subgit merge &lt;commit id&gt; master 现在，main项目和sub项目已经和main的远程仓库一样了。因为sub可能还有commit id领先（可能出现这种情况，请看下边情景）。所以还需要在sub项目中执行下面：12cd subgit pull 这样做是为了及时将sub项目更新到最新。当然如果你永远都不会在main项目中修改sub项目的文件的话。那么不进行git pull也是可以的。上面是对sub子项目更新到最新，如果你还有很多子项目，想要将所有的子项目更新到最新的话。可以执行下面操作：1git submodule foreach git pull 试想下面情景：假设sub是main的子项目，现在有3个人，1在开发main，2也在开发main，3在开发sub。1，2有权修改main和sub，3只有权修改sub。 1先修改main和sub，main的commit id是main_a，sub的commit id是sub_a。然后push并离开了。 2在1的基础上继续修改，在main_a的基础上修改main，commit id是main_b，在sub_a的基础上修改sub，commit_id是sub_b。 3在2的基础上修改sub，在sub_b的基础上修改sub，commit id是sub_c。 然后1回来了。他应该先在主项目下git pull，然后发现sub项目有新的提交。然后在主目录执行git submodule update，这个时候，cd到sub中，我们可以看到分支切换到了sub_b这个commit上。也就是说git submodule update只是切换分支，如果这个时候想继续对sub修改的话，首先，我们需要手动merge，执行git merge sub_b master，将sub_b分支merge到主分支上。然后现在这个状态就和main项目的最新状态是一样的了。但是我们知道sub项目还有个commit id，sub_c，我们需要及时对这个sub_c做个处理，否则的话，如果直接修改sub项目，提交的话，容易出现冲突。即，git pull一下，将sub_c更新过来。 从上面的例子我们看到了git submodule update与直接在子项目里面git pull是有一些区别的。直接在子项目中执行git pull的话，那么就是一下子就更新到了sub_c这个commit id了。而git submodule update则是更新到main项目中最后一次提交时sub项目对应的commit id。 克隆父项目方法一：父项目和子项目一起克隆下来1git clone git@github.com:lmnsyunhao/main.git --recursive 方法二：先克隆父项目，然后再克隆子项目1234git clone git@github.com:lmnsyunhao/main.gitcd maingit submodule initgit submodule update 上边的情景已经展示了git submodule update的性质了。即默认切换到对应的commit id，如果你需要修改子项目的话，还需要将commit id手动merge到master才能更改。1git merge &lt;commit id&gt; master 删除子项目不支持命令删除子项目，需要手动删除。123cd maingit rm --cached subrm -rf sub 移除.gitmodules文件中对应的部分移除.git/config文件中对应的部分移除.git/modules文件夹下对应的文件夹]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[U启动 制作WinPE启动盘 支持UEFI启动]]></title>
    <url>%2F2018%2F07%2F13%2Fburn-windows-preinstallation-environment-disk%2F</url>
    <content type="text"><![CDATA[WinPE又叫Windows Preinstallation Environment，这个PE其实就是一个安装在U盘中的小的windows系统，里面有一些非常基础实用的功能，这个PE可以解决一些磁盘损坏、启动项丢失等与系统有关的问题。所以今天就来看看如何来制作WinPE盘。制作WinPE有好多，比如大白菜，老毛桃，大番薯等。唉，真的烦，怎么都是吃的？而且一个个起名字还这么难听。终于我找着了一个好听的，也非常好用。叫U启动，本文说如何刻录U启动WinPE盘，并且支持UEFI启动。 PEPreinstallation Environment，能够管理启动项；能够再你windows系统坏的时候将你的文件备份出来；能够做最基本的磁盘管理等等。他的功能非常的多。所以，装系统的时候免不了使用PE。 U启动安装过程很简单。打开官网，U启动官网，然后点击下载UEFI版。如下图：下载了之后，打开下载的exe，然后安装U启动。如下图：安装完成之后，打开U启动，然后插入U盘，U盘的质量不要太差，要不然刻录出的盘容易出问题。如下图，选中你要制作的U盘，然后其余都是默认，点击开始制作然后应该会提示会清空U盘的所有数据，点击确定。等待制作完成完成后会询问是否模拟启动，这个模拟启动没什么用处，就是检测这个是否刻录成功，一般都是成功的，就不用模拟启动了，选择否。然后U启动 WinPE，就制作好了。这个U盘支持UEFI启动，当然Legacy也同样支持。]]></content>
      <categories>
        <category>系统安装</category>
      </categories>
      <tags>
        <tag>系统安装</tag>
        <tag>U启动</tag>
        <tag>WinPE</tag>
        <tag>UEFI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows10 磁盘管理工具 分区管理 创建分区]]></title>
    <url>%2F2018%2F07%2F13%2Fwindows-disk-manager-partition%2F</url>
    <content type="text"><![CDATA[本文讲如何用windows10自带的磁盘管理工具进行分区管理。装系统之后一般都需要进行这种操作。安装双系统等可能也需要用到这个东西，所以再这里就单拿出来说一下。 创建分区首先打开磁盘管理，右键单击屏幕左下角windows徽。然后点击磁盘管理。如下：然后点击需要分配的空间，即显示未分配的部分，然后右键单击，弹出框中点击新建简单卷。如下：然后出现对话框，点击下一步：如图：然后填写新建的分区的大小。1G=1024M，如下图：点击下一步然后给磁盘分配驱动器号。这个驱动器号分配了之后，不要乱改了。不然容易出现应用程序找不到，打不开的情况。点击下一步文件系统，一般都是NTFS，然后卷标这是是自己起的名字，如果不喜欢可以改。分配好之后，随时都可以改的。不会游应用程序找不到啊，这种情况。点击下一步然后出现这个界面，确认之后，点击完成。稍等一会儿，等格式化完成之后就创建完成了。]]></content>
      <categories>
        <category>系统安装</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>磁盘管理</tag>
        <tag>分区</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows10 系统安装教程 UEFI模式 Legacy模式]]></title>
    <url>%2F2018%2F07%2F13%2Fwindows-system-installation-tutor%2F</url>
    <content type="text"><![CDATA[更换了SSD需要装windows系统？Windows10出问题了怎么办？总是蓝屏，重启电脑也解决不了，这种时候多半是系统某些地方坏了。如果自己不能够排查出来的话，就用某弛一句话，重装系统多半能解决问题。那么如何重装windows10呢？上维修点让别人给装？还得花不少钱，还不如自己装。本文教你如何装windows10系统。 章节概述如果不懂UEFI和Legacy的话，那么看设置UEFI模式、设置SATA Mode、安装Windows系统几节就OK。如果想要了解Legacy安装windows10的话，那么请看UEFI与Legacy区别，设置Legacy模式，安装windows系统几节。 设置UEFI模式如果你不懂UEFI和Legacy的话，那么就选用UEFI模式安装就好了。现在的电脑都支持UEFI，除非你的电脑很老很老。本文选用电脑Lenovo-Y50-70做为例子，其他的电脑装机都是大同小异，如果你不是这个电脑的话，也不要慌，本文会针对一般的电脑进行说明。首先需要准备windows系统盘一个，如何刻录系统盘？刻录 Windows10 系统盘 UltraISO刻录法 与 官方工具法首先要百度你的电脑的BIOS如何进入，还有选择启动项界面如何进入。BIOS一般都是F2，选择启动项一般都是F12。对于不同的电脑，可能有的是按Fn+F2，Fn+F12，或是ESC，Enter键等等。这些请自行百度。具体电脑可能会有所不同。确保你的电脑正常关闭，并完成了备份。开机，狂按F2(或者是你查到的进入BIOS的按键)，进入BIOS。如果怎么也进入不了BIOS？Windows10 PC 无法进入选择启动项界面 无法进入BIOS界面下面就是进入了BIOS，电脑的BIOS一般都不一样。有的可能是这种底色的，还有的是别的底色的，还有更高级的BIOS等等。不过他们有的功能是类似的。界面上会有提示告诉你怎么移动菜单。找到如下这种Boot Mode类似的可以选择启动模式的地方，选项是UEFI、Lagacy等。然后选择UEFI模式，如果没有这种Boot Mode类似的，那么就找什么UEFI Enable，UEFI Mode，Launch CSM什么之类的，然后把UEFI打开。 设置SATA Mode找到SATA Mode这个东西，选项一般有AHCI、RAID、Compatible等。从图中右侧可以看到，一共有两种，一种是AHCI模式，一种是Compatible模式，Compatible模式中又叫IDE模式。实际上还有一种模式是RAID模式。这三种模式都是什么呢？来分别介绍一下。 IDE Mode就是让硬盘模拟老式的接口方式运行，这样可以对Windows XP兼容。 AHCI Mode是Serial ATA Advanced Host Controller Interface，串行ATA高级主控接口。这个模式能够稍微提高硬盘的性能。 RAID Mode是Redundant Array of Independent Disk，独立磁盘冗余阵列。学过操作系统的同学都知道这是个啥。最少两块硬盘才能组建RAID。 装Windows10的时候，SATA Mode要设置为AHCI就行。有些工作站默认的SATA Mode设置为RAID，这样可能会出现Windows10安装完毕之后，容易导致进系统找不到引导，或是经常蓝屏什么的。我猜测是因为Windows10没有默认集成RAID的驱动程序。所以我在此强调一下。注意！！！如果已经成功安装了Windows10不要贸然更改这些设置。否则，系统容易崩。之后，保存设置并退出，这个也一般会有提示的，比如上图中，右下角，F10是保存并退出，如果没找到这种，找到Exit菜单，然后看看类似Exit and Save，Exit Saving Changes等等就行。保存并退出了BIOS之后，关机。如果能正常关机，就正常关机，如果不能正常关机就强制关机。重装系统过程中有些时候避免不了强制关机几次，不用太担心，硬件没那么脆弱。强制关机就是长按电源键直到关机。 安装Windows系统插入windows系统盘，选U盘做windows系统盘的时候别选太垃圾的U盘，容易出问题。质量得过得去。插入系统盘之后，开机。然后狂按F12，或者是别的能够进入选择启动项界面的按键。下面就是选择启动项界面，这个界面如果不相同也很正常，有的更优雅一些。一般这个界面都和BIOS的界面是配套的界面。第一个Windwos Boot Manager这个是我电脑里面现存的Windows的启动选项，后边括号里面那个是硬盘的编号。第二个，EFI USB Device(SanDisk)这个就是我们的系统盘的启动项。如果不一样的话，那么就找这几个关键词，带EFI，USB，然后括号里面的一般是U盘的品牌。然后还有一些别的启动项，比如图上这些，还有的有什么什么LAN等，那些都不是我们需要的。我们选择U盘的启动项，然后Enter进入。然后等一会儿，就会进入到我们的安装系统界面，界面很人性化，根据提示就能安装，我就简要说一下。下面这个界面一般都直接点下一步，默认的都对。点下一步然后能看到下面这个界面，点击现在安装。等一会儿，如下图：出现下图，点击我没有产品密钥，出现下图，让选择Windows安装版本。开发人员一般的装专业版就行，专业版有组策略，家庭版没有。如果只是用windows办公的话，家庭版就行。家庭单语言版，跟教育版我没用过，不敢尝试。有兴趣大家可以尝试一下。然后点击下一步然后点击接受协议，点击下一步。然后出现下面，我一般选择自定义，点击自定义点击自定义，以后会看到这个分区界面。如果你是给电脑新换了SSD，然后重装系统。这个时候应该能看到SSD的盘，从驱动器数量和驱动器的大小可以看出，如果看不到SSD的盘。那么是安装程序不认SSD，这里给出两种方法，第一，关闭电脑，使用PE，将SSD格式化一下。然后再重新装系统。详见本文PE格式化磁盘一节。这种方法我自己试过；第二，网上说找不到SSD驱动器，是因为安装程序里面没有驱动程序，需要将驱动程序下载好，拷贝到U盘中，然后点击图中对话框左下角那个加载驱动程序，将驱动程序加载进来就好了。这种方法我没有试过下边的主分区就分别是C盘，D盘等等。上面的恢复分区是windows存储恢复程序。系统分区是efi分区，存储启动程序的。MSR分区是微软预留分区。现在要删除分区。如果你某个盘里面的东西不想删的话，那么就留着那个分区不删除就好了。反正我觉得，装一次系统挺不容易的，所以我一般所有分区都删除，然后重新分区。所以讲这个表儿里面的所有的都删除，选中某一个分区，然后点击下边儿删除，然后确定删除。全都删除之后，会变成一个未分配的空间。这个时候就可以重新分区了，先分C盘，我一般都分120个G以上，因为C盘会越用越小，所以习惯分大一点儿，如果不想太大，最小得60个G吧，要不然就太小了。注意如果磁盘多余一个的话，别分错了磁盘。点击未分配的空间，然后点击新建，然后输入大小，1024M=1G，然后点击应用。这个时候应该会弹框提示，然后点击确定。如下：点击确定之后，等一会儿，会出现下面这样，会自动建立恢复分区，系统分区，和保留分区。然后，可以继续按照上面的分区方式，将剩下的未分配空间分配。再继续新建的时候，就不会产生恢复分区，系统分区，保留分区了。这三个只有在没有的时候出现。当然，如果你这个时候不想继续分配的话，也可以安装完系统之后再分配。详见Windows10 磁盘管理工具 分区管理 创建分区等重新分区之后，鼠标点击你想要将系统装入的分区。然后再点下一步，也就是说你需要将C盘选中，然后点击下一步，如下图：然后就开始安装了，等一会儿，如下图：等安装结束之后会读条，这个时候就要准备拔U盘了，等到读条结束之后，屏幕完全暗下来的一瞬间，拔出U盘，不然就重启了。读条界面如下：然后电脑应该就自动重启了，成功的话，就已经进入windows了，然后进入windows之后会有检查设备，准备啊，然后让你设置用户名什么的，那个就不说了。 UEFI与Legacy区别UEFI Bios启动模式可以支持两种启动模式，即是Legacy+UEFI启动模式和UEFI启动模式，当中Legacy+UEFI启动模式说的是UEFI和传统BIOS两者共存模式，此种模式还能兼容传统BIOS引导模式以此来启动电脑系统；而UEFI启动模式则只能在UEFI引导模式来启动电脑系统。BIOS是英文”Basic Input Output System”的缩略词，直译过来后中文名称就是”基本输入输出系统”。UEFI全称“统一的可扩展固件接口”(Unified Extensible Firmware Interface)，是一种详细描述类型接口的标准。上图是两者启动时候工作的区别，UEFI相比传统BIOS少了自检这一步，所以快了许多。简单的讲，UEFI比传统的BIOS要快，更优秀。现在大多数电脑都支持UEFI了，传统BIOS，即Legacy快被淘汰了。你们可能现在还在混乱，Legacy、Legacy BIOS、UEFI、UEFI BIOS、BIOS、传统BIOS这些到底有几种启动模式？我是这么区分的，带UEFI四个字的表明是UEFI启动模式，不带UEFI的就是传统的启动模式。所以现在说了半天，一共只有两种启动模式。只不过这两种启动模式有好多种通俗的叫法。 Legacy模式安装如果需要Legacy模式安装的话，那么我们需要在BIOS里面打开Legacy。首先将计算机关闭，然后开机，狂按F2(或者是其他能够进入BIOS的按键，不同电脑可能不一样，自行百度)，进入BIOS。如果进不了BIOS？Windows10 PC 无法进入选择启动项界面 无法进入BIOS界面进入了BIOS之后，看到下面的画面，正如我们上面说的，不同的电脑BIOS的颜色，选项的位置都不一样，所以我只是拿下面这个做个例子。界面上会有提示告诉你怎么移动菜单。找到如下这种Boot Mode类似的可以选择启动模式的地方，选项是UEFI、Lagacy等。然后选择Legacy Support模式，如果没有这种Boot Mode类似的，那么就找什么Legacy Enable，Legacy Mode，Legacy Support，Launch CSM什么之类的，然后把Legacy支持打开。打开了Legacy以后，电脑现在能够进入UEFI的，也能够进入Legacy的。之后，保存设置并退出，这个也一般会有提示的，比如上图中，右下角，F10是保存并退出，如果没找到这种，找到Exit菜单，然后看看类似Exit and Save，Exit Saving Changes等等就行。现在电脑是关闭状态，然后插入U盘，开机，狂按F12(或者是其他能够进入选择启动项界面的按键，不同电脑不一样，自行百度)。如果进不去？Windows10 PC 无法进入选择启动项界面 无法进入BIOS界面下图就是选择启动项界面。我们可以对比只开启UEFI时候的选择启动项界面(就在上边儿，自己看下)，多了几项。前两个是Legacy模式的启动项，后两个是UEFI模式的启动项。中间那个莫名其妙不用管。我们选择第二个，USB HDD这个就是我们的Windows系统盘的Legacy模式安装的启动项。等一会儿然后进入下面这个界面了。细心的我们可以发现，这个界面相比UEFI模式启动的时候区别是，这个对话框有横向拉伸的迹象。到这个界面之后，就和上边儿的安装一样了，就不多说了。 PE格式化SSD首先你得有一个WinPE的盘。WinPE是什么？如何制作？U启动 制作WinPE启动盘 支持UEFI启动然后确保你的电脑正常关闭，并能够进入BIOS，选择启动项界面，如果不知道按哪个按键，一般BIOS是F2，选择启动项是F12，也有Fn+F2和Fn+F12等等，ESC和Enter都有，具体是哪个按键请自行百度。插入WinPE盘，按下开机按钮后，就狂按F12(能进入选择启动项的界面的按键)，进入选择启动项界面。如果怎么按都进入不了？Windows10 PC 无法进入选择启动项界面 无法进入BIOS界面然后会到选择启动项界面。这个界面上，Windows Boot Manager是我电脑上现存的windows10的启动项，括号里的是磁盘的编号，EFI USB Device这个就是WinPE了，括号里是我U盘的牌子，我们上下键移动选中EFI USB Device，然后Enter键进入PE。然后等待一会儿，会有读条什么的，等到进入下图这个界面，说明成功进入了PE。然后用PE里面自带的磁盘管理工具，新建一个分区，格式化一下SSD磁盘，NTFS格式。我现在没有SSD，所以没办法拍照，所以，就意会一下，等以后有了再修改博文。]]></content>
      <categories>
        <category>系统安装</category>
      </categories>
      <tags>
        <tag>系统安装</tag>
        <tag>Windows</tag>
        <tag>UEFI</tag>
        <tag>Legacy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[刻录 Ubuntu16.04 系统盘 UltraISO刻录法]]></title>
    <url>%2F2018%2F07%2F11%2Fburn-ubuntu-installation-disk%2F</url>
    <content type="text"><![CDATA[大学帮别人装了不少系统，双系统什么的，自己也看过不少博文，对装系统这方面有了些体会。应多位故人建议，总结整理。本文主要讲如何刻录Ubuntu的系统盘，以及Ubuntu系统镜像的来源。以16.04为例。 下载镜像Ubuntu镜像不难得，在Ubuntu的官方网站上就有，细心找找就能够找到镜像下载，一般都是1个G多。下载之后是.iso文件。 UltraISO刻录刻录方式和windows大同小异。刻录 Windows10 系统盘 UltraISO刻录法 与 官方工具法我们需要UltraISO和下载好的Ubuntu的.iso镜像文件首先打开UltraISO，如果没激活，请自行激活。点击文件，打开，然后打开镜像文件。然后点击启动，写入硬盘映像。弹出对话框然后磁盘驱动器选择你要刻录的U盘(U盘质量不要太差)，然后写入方式选USB-HDD+，然后点击写入。等一会儿就刻录成功了。]]></content>
      <categories>
        <category>系统安装</category>
      </categories>
      <tags>
        <tag>UltraISO</tag>
        <tag>Ubuntu</tag>
        <tag>系统安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[刻录 Windows10 系统盘 UltraISO刻录法 与 官方工具法]]></title>
    <url>%2F2018%2F07%2F11%2Fburn-windows-installation-disk%2F</url>
    <content type="text"><![CDATA[大学的时候，学会了装系统。干装系统这活儿也有两年了。说下刻录windows10系统盘的两种方法。UltraISO刻录方法，与官方的工具刻录方法。还有windows镜像的获得方法。 UltraISO + .iso镜像文件 刻录首先你需要有UltraISO 软碟通软件，去百度下载。还需要有widows10的镜像文件。一般是.iso文件激活UltraISO软件，激活码善用搜索引擎。已经激活的话，请继续看软件激活之后，打开软件。然后点击文件，打开，打开.iso镜像文件。然后点击启动，写入硬盘映像，弹出窗口磁盘驱动器选择你要做成系统盘的U盘，写入方式选择USB-HDD+，然后点击写入。刻录U盘的时候会格式化U盘(U盘质量不要太差)，确保备份好U盘文件。等待20分钟左右，就成功了。 写入方式如果不想了解写入方式的话，那么就跳过这一节。写入方式，其实就是U盘的工作模式。有USB-HDD、USB-ZIP、RAW、USB-FDD、USB-CDROM等等。这些不同的模式，电脑在启动这个U盘的时候，将U盘视作不同的东西，按照不同的方式处理。USB-HDD，HDD是Hard Disk Driver，这是硬盘仿真模式，把U盘当做硬盘启动。这种模式兼容性很高，缺点是对于一些只支持USB-ZIP模式的电脑则无法启动。USB-HDD+，USB-HDD的增强版，同样对于只支持USB-ZIP的无法启动。兼容性比USB-HDD更好USB-HDD+ v2，USB-HDD的增强模式。同样对于只支持USB-ZIP的无法启动。兼容性比USB-HDD更好USB-ZIP，大容量软盘仿真模式，此模式在一些比较老的电脑上是唯一可选的模式，但对大部分新电脑来说兼容性不好，特别是2GB以上的大容量U盘。USB-ZIP+，USB-ZIP的增强版USB-ZIP+ v2，USB-ZIP的增强版USB-FDD，FDD是Floppy Disk Driver，软盘仿真模式。一般的软盘都用这个模式来启动。USB-CDROM，光盘仿真模式。RAW，未经处理的。未格式化的磁盘。 官方工具 刻录这个官方的工具叫MediaCreationTool，下载地址MediaCreationTool，这个工具不仅可以直接刻录U盘，还能够下载windows10的iso镜像文件。首先打开这个文件，然后出现下面的界面，等待一会儿。如果提示更新了，如下：点击下载更新的媒体创建工具，如果没提示更新，请继续往下看。然后弹出一个网页，网页中点击立即下载工具，就能够下载最新的媒体创建工具。下载完之后，打开新的媒体创建工具。打开媒体创建工具，等一会儿，然后会出现下面的这个界面，点击接受然后出现下面，点击创建安装介质，然后下一步，这个就是刻录U盘的然后确认一下这个是不是自己想要的windows版本，一般默认就行。然后下一步这个时候注意，如果选择ISO文件的话，那么它会下载windows10的镜像文件，然后保存到本地。如果刻录U盘(U盘质量不要太差)，选择U盘，然后点击下一步选择你要制作系统盘的U盘，然后点击下一步。等一会儿就好了。成功之后会有提示。这个时间比上面直接刻录时间要长一点。因为是先下载下来，然后给你刻录到U盘中。不过这种方式刻录的U盘总是最新版本的windows10。这也是这种方式的好处。]]></content>
      <categories>
        <category>系统安装</category>
      </categories>
      <tags>
        <tag>UltraISO</tag>
        <tag>系统安装</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo NexT 添加 Gitalk评论功能]]></title>
    <url>%2F2018%2F07%2F04%2Fhexo-next-gitalk-comments-tutor%2F</url>
    <content type="text"><![CDATA[多说关闭之后，其实还有好多评论，友言、畅言、来比力、disqus、Valine、HyperComments、Gitment。这些我都看过，都不太喜欢。来比力是韩国出的，HyperComments俄罗斯出的，畅言好像得备案才行，Valine是基于LeanCloud的而且匿名的话太丑了，Gitment移动端适配不好，等等问题。最终我找到了Gitalk这个插件。本文介绍如何给Hexo添加Gitalk评论功能，以NexT主题为例。 GitalkGitalk和Gitment一样，是利用GitHub的Issue功能。移动端适配比Gitment好。目前Gitalk还没有被默认集成进NexT主题里。所以需要自己配置。 新建OAuth应用登陆GitHub，然后点击头像，然后Settings，Developer settings。如下：然后，点击OAuth Apps，New OAuth App，如下：填写下面红框的内容。Application Name随便起，Homepage URL是你需要用这个应用的地址，就是博客的地址，callback URL是你的回调地址，一般填你的博客地址。如果你在调试的话，可以填localhost然后，你会跳到这个界面。client id和secret这两个有用。记得不要给别人 添加代码在主题中添加代码，我是强迫症，秉着对NexT主题代码最小的破坏。而且最好在NexT主题中该加代码的地方加。找到NexT的主题目录，然后进入这个路径/next/layout/_custom/下，应该有head.swig，header.swig，sidebar.swig这三个文件。这三个文件应该就是自定义布局的位置。然后，在sidebar.swig里面添加如下代码：12345678910111213141516171819202122232425&#123;% if page.comments and config.gitalk.enable %&#125; &lt;link rel=&quot;stylesheet&quot; href=&quot;&#123;&#123; config.gitalk.gitalk_css &#125;&#125;&quot;&gt; &lt;script src=&quot;&#123;&#123; config.gitalk.gitalk_js &#125;&#125;&quot;&gt;&lt;/script&gt; &lt;script src=&quot;&#123;&#123; config.gitalk.md5 &#125;&#125;&quot;&gt;&lt;/script&gt; &lt;script&gt; var gitalk = new Gitalk(&#123; clientID: &apos;&#123;&#123; config.gitalk.clientID &#125;&#125;&apos;, clientSecret: &apos;&#123;&#123; config.gitalk.clientSecret &#125;&#125;&apos;, repo: &apos;&#123;&#123; config.gitalk.repo &#125;&#125;&apos;, owner: &apos;&#123;&#123; config.gitalk.owner &#125;&#125;&apos;, admin: &apos;&#123;&#123; config.gitalk.admin &#125;&#125;&apos;, id: md5(location.pathname), distractionFreeMode: &apos;true&apos; &#125;); var div = document.createElement(&apos;div&apos;); div.setAttribute(&quot;id&quot;, &quot;gitalk_comments&quot;); div.setAttribute(&quot;class&quot;, &quot;post-nav&quot;); var bro = document.getElementById(&apos;posts&apos;).getElementsByTagName(&apos;article&apos;); bro = bro[0].getElementsByClassName(&apos;post-block&apos;); bro = bro[0].getElementsByTagName(&apos;footer&apos;); bro = bro[0]; bro.appendChild(div); gitalk.render(&apos;gitalk_comments&apos;); &lt;/script&gt;&#123;% endif %&#125; 注意，15行至第22行，是给评论区找一个div，然后23行将div的id传过去。 修改站点配置文件找到站点配置文件，然后添加以下内容。owner是你的github登录名，repo是博客在github上边的仓库名，admin写自己的github登录名，clientID和clientSecret填写上边得到的那两个，下面的三个cdn不要修改1234567891011# Gitalk评论gitalk: enable: true owner: repo: admin: clientID: clientSecret: gitalk_css: //cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css gitalk_js: //cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js md5: //cdn.bootcss.com/blueimp-md5/1.1.0/js/md5.min.js 初始化每次hexo d之后，都要去博客里面看一下，登陆自己的github，然后这个时候会自动初始化评论区。必须初始化一下。这个比gitment的点击才能初始化功能稍微方便点。只需要进入那个界面就可以了。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
        <tag>Gitalk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[域名解析配置教程]]></title>
    <url>%2F2018%2F07%2F01%2Fdomain-name-parsing-setting-tutor%2F</url>
    <content type="text"><![CDATA[配了好多次域名解析了，每次都有那么几个记录类型不清楚是什么意思，今天总结一下域名解析如何配置。 域名我们购买的域名一般都是一级域名，有可能是二级的，举个例子。yunhao.space这个域名是我从GoDaddy那里买来的。space是顶级域名，yunhao是一级域名，我买的是一级域名。如果你买的是haha.org.cn，那么，你买的就是二级域名haha，org是一级域名，cn是顶级域名。 字段简介域名配置的时候几乎都是大同小异。这里简要介绍一下如何添加解析记录。添加解析记录的时候一般都有下面几个字段。我们假设买的域名是一级域名，也是就yunhao.space，第一个就是主机记录，第二个字段是记录类型，然后是记录值，TTL。其余的字段都几乎不需要设置，默认就行。我们接下来详细说下每个字段。 主机记录这个就是你自己起的二级域名。比如，我想设置blog.yunhao.space的解析，那么这个位置就填blog，这个二级域名是你自己随便起的。如果你想设置二级域名为空，那么就填@，就是yunhao.space的解析。想设置手机网站访问时候自动访问的域名，就填m想设置邮箱服务器的域名，就写mail有的DNS解析服务提供商会有一些类似泛解析的设定，就是匹配其他所有域名，填*。 记录类型与记录值这个记录类型，跟记录值是有对应关系的。A类型，用来将域名解析成IP地址，记录值位置填写对应的IPv4地址。CNAME类型，用来将域名解析成另一个域名，记录值位置填写要解析成的域名。MX类型，设置邮箱的时候，需要选的类型。TXT类型，可以写任何东西，一般用来做SPF记录，反垃圾邮件。NS类型，如果需要把子域名给其他DNS服务商解析，就要填NS。AAAA类型，记录值处指定IPv6地址。SRV类型，记录了那台计算机提供了什么服务。SOA类型，表明此DNS名称服务器是为该DNS域中的数据的信息的最佳来源。SOA记录与NS记录的区别：NS记录表示域名服务器记录，用来指定该域名由哪个DNS服务器来进行解析；SOA记录设置一些数据版本和更新以及过期时间的信息。 TTL单位是秒，是缓存失效时间。越低更新越快。但是相比，解析速度就慢了。越高解析越快，越稳定，更新速度慢如果你不想花钱的话，最低一般能设置600秒。]]></content>
      <categories>
        <category>服务器</category>
        <category>域名</category>
      </categories>
      <tags>
        <tag>域名</tag>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub Hexo 博客 GitHub Pages 个人站点 多域名绑定问题]]></title>
    <url>%2F2018%2F07%2F01%2Fgithub-blog-multiple-domain-bundling-issue%2F</url>
    <content type="text"><![CDATA[我的个人站点托管在GitHub上，想要多个域名都能够正常访问站点，比如，yunhao.space可以访问站点，blog.yunhao.space也可以访问站点。记录一次折腾。因为设置过程中，会有缓存，所以吧有的时候，不一定能够是真的能访问，所以得再三确认。 GitHub PagesGitHub Pages提供了将项目设置成站点的功能。可以通过特定的网址访问。GitHub Pages站点有两类，第一类是用户组织站点，第二类是项目站点。第一类站点的仓库名字必须和用户名一样，第二类站点的仓库名字可以随便。访问第一类站点网址是username.github.io，访问第二类站点网址是username.github.io/repository_name。官方说，用户组织站点，每个账户只能有一个，而项目站点每个项目无限。详见官方文档个人站点就是用户站点。 多域名绑定的官方解释Multiple domains in CNAME file，这是官方解释： A CNAME file can contain only one domain. To point multiple domains to the same Page, set up redirects through your DNS provider. 官方说github上的CNAME文件中只能有一个域名。我们就要另寻他法。 301重定向于是我们想到了301重定向。为什么一定要重定向呢？重定向可以让我们浏览器的地址栏修改url。如果只是在dns做CNAME解析的话，是没办法让地址栏修改url的。于是我们就会看到GitHub的404。有人说了，我们可以自己定义一个404.html，然后放在个人站点的根目录下，然后404.html中用js的window.location.href重定向不就好了？这会失败，因为这个404的错误，是github找不到你的个人站点的根目录，报的404，就是说github不知道你想访问哪个项目。而在个人站点根目录下放404.html只能解决在这个目录下找不到某个文件什么的问题，显示404.html的内容。所以，上边那种做法会失败。 服务器重定向这里以Nginx服务器做例子。如果你想将域名blog.yunhao.space 301重定向到 yunhao.space的话，那么如下配置nginx的服务器：我的服务器是Ubuntu16.04，nginx是apt-get安装的。12cd /etc/nginx/sites-availablevim redirection.conf 新建redirection.conf之后，在文件中按照下面这样写入：1234server &#123; server_name blog.yunhao.space; rewrite ^(.*)$ http://yunhao.space$1 permanent;&#125; 保存退出后，重启一下nginx服务1234cd /etc/nginx/sites-enabledln -s /etc/nginx/sites-available/redirection.conf redirectionsystemctl stop nginx.servicesystemctl start nginx.service 记得dns添加A解析，blog.yunhao.space解析到服务器IP地址，如果不会，参考域名解析配置教程然后等一会儿，测试一下，就成功了。这个方法可以说是最直接的，最正常的，我就是采用的这种方法。记得设置nginx开机自启动，否则重启之后，就不能提供服务了。 GitHub多项目重定向这个方法取自一个GitHub Pages的特性。 项目站点可以有自己的域名，不一定要用个人站点域名/项目名称来访问。 解释一下，比如个人站点域名是yunhao.space，github上有个项目站点，项目名字是test，那么在配置好GitHub Pages的情况下，可以通过yunhao.space/test来访问。这个是官方文档中说明的。其实GitHub Pages的项目站点域名绑定比官方说的更强大，也就是说虽然你的个人站点绑定域名是yunhao.space，项目站点可以绑定test.yunhao.space，甚至是test.yunhao.life，顶级域名都可以不一样。想要使用上边特性其实很简单，需要注意两点，第一就是dns解析和github仓库中CNAME文件相对应。第二就是github仓库开启了GitHub Pages服务。下面我继续说这个通过多个项目站点进行重定向的方法。这个例子就正好能够反映上边这个GitHub Pages的特性。比如现在我的yunhao.space已经绑定了个人站点，我想让test.yunhao.life这个域名也指向我的个人站点。首先，dns添加CNAME解析，test.yunhao.life解析到lmnsyunhao.github.io如果不会，参考域名解析配置教程然后，在github上新建一个仓库，名字比如说叫test。然后clone下来。然后，test仓库里放一个CNAME文件，文件中写test.yunhao.life。然后，test仓库里放404.html的文件。文件中用js重定向。如下：注意domain变量内设置自己的想要重定向到的域名1234567&lt;script&gt;var domain = "yunhao.space";var src = window.location.href;var prtc = src.substring(0, src.indexOf(':'));var target = src.substring(src.indexOf('/', src.indexOf(':') + 3));window.location.href = prtc + "://" + domain + target;&lt;/script&gt; 然后，将新增文件add, commit并push到github上master分支。然后，开启test项目的GitHub Pages服务。如下：点击settings，然后往下滚，到GitHub Pages，然后选master，并保存。等会儿，然后测试一下，应该就能定向了。 域名注册商重定向有点域名注册商提供了重定向服务，比如GoDaddy，腾讯云。腾讯云的重定向，如下图：显性URL类型就是301重定向服务，不过大家也从上边的弹窗看到了，有些限制。所以，我在GoDaddy上边找到了重定向服务。因为我的域名就是在GoDaddy上边买的。所以我就直接设置了。我看了看，GoDaddy上边好像不能接管别的域名注册商处注册的域名。如果你是GoDaddy买的域名，那么恭喜你了。这个方法，你可以看一看，否则的话你就得看看自己的域名注册商是否提供重定向服务了。首先登陆GoDaddy，然后点击我的产品。比如，我们要将yunhao.life重定向到yunhao.space，点击DNS如果域名服务不在GoDaddy托管的话，那么首先点击下面的域名服务器，更改回默认的来，然后等更新好了，再继续。如果没出现这种情况，继续往下看：找到转址这一块儿。上边域名转址是处理形如yunhao.life转到yunhao.space的，而子域名转址是blog.yunhao.life转到yunhao.space的，区别是二级域名是否为空。然后下面是域名转址的修改方式：即从yunhao.life转到yunhao.space如果想设置子域名转址，比如blog.yunhao.life转到yunhao.space，如下：现在就设置完了，估计得等一会儿，才能生效。我等了半个多小时。这个域名注册商提供的转址服务不一定快。比如GoDaddy这个的确能转。但是速度有点儿慢。而且好像对于yunhao.life/hello.html转到yunhao.space/hello.html类似情况不支持。]]></content>
      <categories>
        <category>服务器</category>
        <category>域名</category>
      </categories>
      <tags>
        <tag>域名</tag>
        <tag>DNS</tag>
        <tag>服务器</tag>
        <tag>GitHub</tag>
        <tag>GitHub Pages</tag>
        <tag>GoDaddy</tag>
        <tag>腾讯云</tag>
        <tag>Hexo</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NPM 学习笔记]]></title>
    <url>%2F2018%2F06%2F30%2Fnpm-instruction-learning-note%2F</url>
    <content type="text"><![CDATA[总结一下NPM的命令，防止以后总是去查阅。只是一些常用的命令，以及语义化版本号的含义。 NPMNPM全称是node package manager。在安装nodejs的时候就会连带安装npm，用来维护和管理node_modules。我为什么要写这篇博客呢？因为懒得每次都百度。所以就mark一下。 官方文档官方的中文文档请见中文文档 本地安装和全局安装如果你自己的模块依赖于某个包，并通过 Node.js 的 require 加载，那么你应该选择本地安装，这种方式也是 npm install 命令的默认行为。如果你想将包作为一个命令行工具，（比如 grunt CLI），那么你应该选择全局安装。 语义化版本号package.json中的dependencies里面都有version，那么version字段具体都表示什么含义呢？a.b.c的含义，如下：发布补丁，就增加最后一位数字，比如1.0.1如果增加新功能，且不影响原有的功能，就增加小版本号，比如1.1.0如果引入的变化，破坏了向后兼容性，就增加大版本号，比如2.0.0对于依赖包的版本，版本位置应该怎样填写？ 只接受补丁: 1.0 或 1.0.x 或 ~1.0.4 只接受小版本号和补丁: 1 或 1.x 或 ^1.0.4 接受全部更新: * 或 x 指令 npm更新npm install npm -gnpm install npm@latest -g 安装最新测试版npm install npm@next -g 安装下一个未发行版 创建package.jsonnpm initnpm init -y 会抽取项目的信息来生成package.jsonnpm init --yes 会抽取项目的信息来生成package.jsonnpm set init.author.email &quot;wombat@npmjs.com&quot; 设置初始化信息npm set init.author.name &quot;ag_dubs&quot; 设置初始化信息npm set init.license &quot;MIT&quot; 设置初始化信息 查看npm版本npm -v 安装模块npm install &lt;package_name&gt; 本地安装npm install &lt;package_name&gt; -g 全局安装npm install &lt;package_name&gt; --save 会将package_name添加到package.json中的dependencies下npm install &lt;package_name&gt; --save-dev 会将package_name添加到package.json中的devDependencies下 更新模块npm update [-g] [&lt;pkg&gt;...] -g决定更新全局还是更新本地，如果没指定任何的pkg，那么就都更新。 检查模块更新npm outdated [[&lt;@scope&gt;/]&lt;pkg&gt; ...] 删除模块npm uninstall &lt;package_name&gt;npm uninstall --save &lt;package_name&gt; 卸载并移除package.json中的依赖。 查看全局安装的模块npm list -g 查看某个模块的版本号npm list &lt;Module Name&gt; 查看当前目录所有模块npm ls 搜索某模块npm search &lt;Module Name&gt; 查看某条命令帮助npm help &lt;command&gt;]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>NPM</tag>
        <tag>NodeJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo NexT 添加 DaoVoice 在线聊天]]></title>
    <url>%2F2018%2F06%2F30%2Fhexo-next-add-daovoice-contact%2F</url>
    <content type="text"><![CDATA[今天发现了一个有意思的在线聊天工具，DaoVoice，很有意思，还是免费的，本文讲如何将DaoVoice集成进Hexo博客，以NexT主题为例。其他主题些许不同。 DaoVoice一个实时在线沟通的工具。可以及时解答客户的问题。还能够绑定微信。具体请看一分钟了解DaoVoice 新建应用首先现在DaoVoice上注册一个账号。打开DaoCloud首页。找到DaoVoice服务，然后点击，如下图：然后再下边的界面中选择注册，或登录。如果是新注册的用户，那么注册之后，就会看到下面的这个界面。这个是让你添加一个应用的，填写你的公司名称，你的电话号码，然后点击保存就好了如果你是老用户了，找不到上边这个界面了，在下面的位置可以找到，找到之后向上边设置一下。 安装到网站如下图，点击应用设置，安装到网站，JS，仅匿名用户，然后找到下面两个代码。打开博客的主题目录下的文件/themes/next/layout/_custom/head.swig。然后粘贴成下面这样：123456789101112&#123;#Custom head.#&#125;&#123;% if config.daovoice %&#125; &lt;script&gt; (function(i,s,o,g,r,a,m)&#123;i[&quot;DaoVoiceObject&quot;]=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset=&quot;utf-8&quot;;m.parentNode.insertBefore(a,m)&#125;)(window,document,&quot;script&quot;,(&apos;https:&apos; == document.location.protocol ? &apos;https:&apos; : &apos;http:&apos;) + &quot;//widget.daovoice.io/widget/&#123;&#123;config.daovoice_app_id&#125;&#125;.js&quot;,&quot;daovoice&quot;) daovoice(&apos;init&apos;, &#123; app_id: &quot;&#123;&#123;config.daovoice_app_id&#125;&#125;&quot; &#125;); daovoice(&apos;update&apos;); &lt;/script&gt;&#123;% endif %&#125; 注意app_id后边的那个要换一下，然后那个网址后边哪儿也要换成变量。就是上边图片中，那两段代码中被黑条盖住的部分要替换那个被黑条盖住的部分就是你的app_id。打开博客配置文件然后增加下面内容：123# 实时联系daovoice: truedaovoice_app_id: 你的app_id 将你的app_id替换成黑条盖住的部分就行了。然后执行hexo cl &amp; hexo g &amp; hexo d，之后ping一下，如下图如果成功了，现在就已经接入了，网站右下角就应该有一个悬浮钮了。 微信绑定绑定到微信，可以实时处理消息，回复消息。扫码之后，就能看到下面的绑定成功。 设置悬浮钮如果悬浮钮遮挡其他元素了，或者是想设置悬浮钮的颜色，什么的。点击应用设置，聊天设置，如下图：在这里，我们可以设置欢迎语，按钮的颜色，位置什么的。 新消息指派设置一下新消息指派，点击应用设置，新消息设置，默认指派选择自己。如下图 费用问题这个应用是免费的。不过也有付费版。你的网站用户数小于5000的时候，就是免费的。具体的需不需要付费，请看资费情况 用户手册其他问题，请自行查阅官方用户手册]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
        <tag>DaoVoice</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo NexT 站内搜索 站点统计 RSS订阅 字数统计 阅读时长 进度条 图片放大 Canvas背景 DaoVoice聊天 Gitalk评论 功能配置]]></title>
    <url>%2F2018%2F06%2F29%2Fhexo-next-function-setting%2F</url>
    <content type="text"><![CDATA[Hexo的NexT主题的一些功能如何开启。如下：站内搜索功能、站点访客量、站点阅读量、站点总字数、站点总阅读时长、RSS订阅、博文字数、博文阅读时长、博文阅读量、优雅的进度条、点击博文内图片放大、Canvas背景、DaoVoice聊天、Gitalk评论 站内搜索NexT支持集成Swiftype、微搜索、Local Search和Algolia。Swiftype、微搜索我没具体了解。Algolia界面很优雅，因为这个是第三方的，每次都得hexo algolia来上传一下，多了一步操作。而且，Algolia有试用期，试用期过后就降为免费版了，免费版的搜索时不能对文章内容进行搜索。所以，我没用这个。我用的是Local Search，这个是每次hexo g的时候都会产生一个search.xml的文件，搜索就是从这个文件里搜索，这个比较方便。而且支持文章内容搜索。下面说Local Search怎么配置。先打开博客根目录，安装hexo-generator-searchdb1npm install hexo-generator-searchdb --save 然后去博客配置文件中加入下面的12345search: path: search.xml field: post format: html limit: 10000 解释一下各个字段含义：摘自官方 path - file path. By default is search.xml . If the file extension is .json, the output format will be JSON. Otherwise XML format file will be exported. field - the search scope you want to search, you can chose: post (Default) - will only covers all the posts of your blog. page - will only covers all the pages of your blog. all - will covers all the posts and pages of your blog. format - the form of the page contents, works with xml mode, options are: html (Default) - original html string being minified. raw - markdown text of each posts or pages. excerpt - only collect excerpt. more - act as you think. limit - define the maximum number of posts being indexed, always prefer the newest. limit就是xml中的包含的最大论文篇数。去主题配置文件中，打开local search。enable设置true1234567891011# Local search# Dependencies: https://github.com/theme-next/hexo-generator-searchdblocal_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1 # unescape html strings to the readable one unescape: false 站点访客量 站点阅读量这个用不蒜子，去主题配置文件中打开busuanzi就好。12345678910# Show Views/Visitors of the website/page with busuanzi.# Get more information on http://ibruce.info/2015/04/04/busuanzi/busuanzi_count: enable: true total_visitors: true total_visitors_icon: user total_views: true total_views_icon: eye post_views: false post_views_icon: eye 特别说明一下，不蒜子就是统计每个url访问了多少次。虽然能够统计单片博文的访问量，但是没办法在主页显示某个博文的访问量，只有点进去这个博文，才能显示访问量。所以单篇博文访问量我们用leancloud，详见Hexo NexT 主题 LeanCloud 插件安装教程 站点总字数 站点总阅读时长 博文字数 博文阅读时长首先安装hexo-symbols-count-time，在博客根目录输入，1npm install hexo-symbols-count-time --save 修改博客配置文件，打开博客配置文件，添加如下内容。12345symbols_count_time: symbols: true time: true total_symbols: true total_time: true symbols是博文字数，time是博文阅读时长，total_symbols是站点总字数，total_time是站点总阅读时长。检查一下主题配置文件:12345678# Post wordcount display settings# Dependencies: https://github.com/theme-next/hexo-symbols-count-timesymbols_count_time: separated_meta: true item_text_post: true item_text_total: false awl: 4 wpm: 275 awl是平均字长度average word length，默认是4，wpm是阅读速度，word per minute。 RSS订阅打开主题配置文件，找到如下：1234# Set rss to false to disable feed link.# Leave rss as empty to use site's feed link, and install hexo-generator-feed: `npm install hexo-generator-feed --save`.# Set rss to specific value if you have burned your feed already.rss: 如果你自己生成了rss，那么上边就填地址，否则的话留空。安装hexo-generator-feed，在博客根目录输入，1npm install hexo-generator-feed --save 每次hexo g的时候就会生成了atom.xml。 博文阅读量不蒜子统计每个url访问了多少次。虽然能够统计单篇博文的访问量，但是没办法在主页显示某个博文的访问量，只有点进去这个博文，才能显示访问量。所以单篇博文访问量我们用leancloud，详见Hexo NexT 主题 LeanCloud 插件安装教程 优雅的进度条NexT主题里面能够使用Pace来设置优雅的进度条，可以看下Demo首先需要git clone一下，打开NexT主题目录下的source\lib目录，执行下面操作1git clone https://github.com/theme-next/theme-next-pace pace 然后配置一下主题配置文件将pace设置成true。1234567891011121314151617181920# Progress bar in the top during page loading.# Dependencies: https://github.com/theme-next/theme-next-pacepace: true# Themes list:#pace-theme-big-counter#pace-theme-bounce#pace-theme-barber-shop#pace-theme-center-atom#pace-theme-center-circle#pace-theme-center-radar#pace-theme-center-simple#pace-theme-corner-indicator#pace-theme-fill-left#pace-theme-flash#pace-theme-loading-bar#pace-theme-mac-osx#pace-theme-minimal# For example# pace_theme: pace-theme-center-simplepace_theme: pace-theme-corner-indicator 可以从上面的那些里面选一个喜欢的主题，写在pace_theme那里。最近又搞了搞，有第二种方法，更直接，不需要git clone，如下：首先得先把上面pace的位置设置成true，然后那个pace_theme位置填写你喜欢的主题。然后找到主题配置文件中如下位置，这么填cdn。1234567# Internal version: 1.0.2# See: https://github.com/HubSpot/pace# Or use direct links below:# pace: //cdn.bootcss.com/pace/1.0.2/pace.min.js# pace_css: //cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-flash.min.csspace: //cdn.bootcss.com/pace/1.0.2/pace.min.jspace_css: //cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-注意替换成一样的主题.min.css 注意，你上边填了什么主题，下边也要换成对应的主题。 图片放大使用fancybox来让博文里面的图片能够点击放大查看。首先需要git clone一下，打开NexT主题目录下的source\lib目录注意，如果这个目录下有fancybox文件夹，需要先删了才行。然后执行下面操作：1git clone https://github.com/theme-next/theme-next-fancybox3 fancybox 然后配置一下主题配置文件将fancybox设置成true。12345# Fancybox. There is support for old version 2 and new version 3.# Please, choose only any one variant, do not need to install both.# For install 2.x: https://github.com/theme-next/theme-next-fancybox# For install 3.x: https://github.com/theme-next/theme-next-fancybox3fancybox: true 第二种方法：不需要git clone首先，先把fancy设置成true。然后找到主题配置文件中如下位置： 这么填cdn。1234# Internal version: 2.1.5# See: http://fancyapps.com/fancybox/fancybox: //cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.jsfancybox_css: //cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.css canvas背景设置博客背景之后，就能跟我这个背景一样了。首先需要git clone一下，打开NexT主题目录下的source\lib目录，执行下面操作：12git clone https://github.com/theme-next/theme-next-canvas-nest canvas-nestgit clone https://github.com/theme-next/theme-next-three three 然后配置一下主题配置文件下面四个选一个true，其他设置成false123456789101112# Canvas-nest# Dependencies: https://github.com/theme-next/theme-next-canvas-nestcanvas_nest: false# JavaScript 3D library.# Dependencies: https://github.com/theme-next/theme-next-three# three_wavesthree_waves: false# canvas_linescanvas_lines: true# canvas_spherecanvas_sphere: false 第二种方法：不需要git clone同样四选一填写true。然后找到主题配置文件中如下位置，这么填cdn。1234567891011121314# Internal version: 1.0.0# https://github.com/hustcc/canvas-nest.jscanvas_nest: //cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.js# Internal version: 1.0.0# See: https://github.com/theme-next/theme-next-three# three: //cdn.jsdelivr.net/gh/theme-next/theme-next-three@1.0.0/three.min.js# three_waves: //cdn.jsdelivr.net/gh/theme-next/theme-next-three@1.0.0/three-waves.min.js# canvas_lines: //cdn.jsdelivr.net/gh/theme-next/theme-next-three@1.0.0/canvas_lines.min.js# canvas_sphere: //cdn.jsdelivr.net/gh/theme-next/theme-next-three@1.0.0/canvas_sphere.min.jsthree: //cdn.jsdelivr.net/gh/theme-next/theme-next-three@1.0.0/three.min.jsthree_waves: //cdn.jsdelivr.net/gh/theme-next/theme-next-three@1.0.0/three-waves.min.jscanvas_lines: //cdn.jsdelivr.net/gh/theme-next/theme-next-three@1.0.0/canvas_lines.min.jscanvas_sphere: //cdn.jsdelivr.net/gh/theme-next/theme-next-three@1.0.0/canvas_sphere.min.js DaoVoice聊天Hexo NexT 添加 DaoVoice 在线聊天 Gitalk评论Hexo NexT 添加 Gitalk评论功能]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 警告错误 LF will be replaced by CRLF]]></title>
    <url>%2F2018%2F06%2F29%2Fgit-warning-lf-replaced-by-crlf%2F</url>
    <content type="text"><![CDATA[我忍了这个问题好久了，每次Hexo d的时候，一大溜这个警告错误，今天查了查，然后知道了到底是什么问题了。mark一下。 症状每次使用git的时候，都会出现这个问题：12warning: LF will be replaced by CRLF in tags/组合数学/index.html.The file will have its original line endings in your working directory. 一报一大溜，真的烦。 原因windows中的换行符为 CRLF，而在Linux下的换行符为LF。所以会给换过来。就是说，我们在工作区的文件中，有的是以LF作为换行符结尾的，然后在添加到暂存区的时候，git会暂存区的LF换成CRLF。然后统一提交时候，都是CRLF换行了。 Hexo请看这里如果是Hexo d的时候出的这个问题。我就是这个时候出的那么直接禁用转换就好了。不需要删除.git什么的。因为hexo d的时候，他会在.deploy_git文件夹内自动从新生成.git1git config –global core.autocrlf false 解决方法输入下面命令禁用转换。1git config –global core.autocrlf false 但是禁用转换之后，必须得把.git删了，然后重新git init一下才行。所以记得保存一下本地的修改什么的。或者push一下。然后：12rm -rf .gitgit init 到这就行了。我不太确定是不是只有windows上边才会有这种问题。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo-leancloud-counter-security 插件 Too many requests 错误]]></title>
    <url>%2F2018%2F06%2F29%2Fhexo-leancloud-counter-security-too-many-requests-error%2F</url>
    <content type="text"><![CDATA[【该问题可能已修复，以下为原文】 这个插件吧，有点儿不完美，给他改了改，不完美的地方就是，leancloud那边儿没法短时间内接受太多请求。原因是我用的是免费版的，有限制，而hexo-leancloud-counter-security 插件每次发太多无用请求，总是会报429错误，我就给源代码改了改。 症状如果你懒得看解释的话，直接去看修改代码一节。每次进行hexo d的时候会概率性的出现如下错误：12345678910ERROR Too many requests. [429 POST https://xtppdvlr.api.lncld.net/1.1/classes/Counter]Error: Too many requests. [429 POST https://xtppdvlr.api.lncld.net/1.1/classes/Counter] at E:\code\blog\node_modules\leancloud-storage\dist\node\request.js:163:17 at tryCatch (E:\code\blog\node_modules\es6-promise\dist\es6-promise.js:410:12) at invokeCallback (E:\code\blog\node_modules\es6-promise\dist\es6-promise.js:425:13) at publish (E:\code\blog\node_modules\es6-promise\dist\es6-promise.js:399:7) at publishRejection (E:\code\blog\node_modules\es6-promise\dist\es6-promise.js:340:3) at flush (E:\code\blog\node_modules\es6-promise\dist\es6-promise.js:128:5) at _combinedTickCallback (internal/process/next_tick.js:131:7) at process._tickCallback (internal/process/next_tick.js:180:9) 官方解释如下： 信息 - Too many requests.含义 - 超过应用的流控限制，即超过每个应用同一时刻最多可使用的工作线程数，或者说同一时刻最多可以同时处理的数据请求。通过 控制台 &gt; 存储 &gt; API 统计 &gt; API 性能 &gt; 总览 可以查看应用产生的请求统计数据，如平均工作线程、平均响应时间等。使用 LeanCloud 商用版或企业版 的用户，如有需要，可以联系我们来调整工作线程数。 原因我查看了源代码，node_modules\hexo-leancloud-counter-security\index.js这个就是源代码。发现每次进行hexo d的时候，他对每个博文的title和url，向leancloud发送一次查询请求，如果发现leancloud那边儿没有该条记录的话，那么再发送一条插入请求。原逻辑如下：12345678910111213141516171819_.forEach(urls, function (x) &#123; var query = new AV.Query('Counter'); query.equalTo('url', x.url); query.count().then(function (count) &#123; if (count === 0) &#123; var counter = new Counter(); counter.set('url', x.url); counter.set('title', x.title); counter.set('time', 0); counter.save().then(function (obj) &#123; log.info(x.title + ' is saved as: ' + obj.id); &#125;, function (error) &#123; log.error(error); &#125;); &#125; &#125;, function (error) &#123; log.error(error); &#125;);&#125;); 也就是说，每一次hexo d的时候最少的查询次数等于你的博文个数。如果你的leancloud的应用的处理能力不够强大的时候，对于这种高强度的请求，当然会出现Too Many Requests的错误代码。 改进思路我们要做的就是较少不必要的请求咯。本地记录一个title和url的json数组，每次查询这个数组，看看哪些是真正的需要查询的，然后再去查询leancloud。其实可以这样理解，这个本地的数组存储就是leancloud的远程数据库表。因为筛除了一些记录，所以每次hexo d时的请求数量仅仅是相比上一次hexo d时候的增量。 修改代码如果你遇到了问题，看看问题解决一节。修改的是node_modules\hexo-leancloud-counter-security\index.js这个文件hexo-leancloud-counter-security版本是1.3.2一共修改下面几处，在代码中已经做了标记。代码70-84代码87-102代码113-117代码120-123代码126-132代码135-138代码140-142代码225-268改完了之后别着急，打开博客配置文件找到skip_render:这一项，然后加上leancloud_memo.json。不会加的看修改博客配置文件一节。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272'use strict';var _regenerator = require('babel-runtime/regenerator');var _regenerator2 = _interopRequireDefault(_regenerator);var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);var _stringify = require('babel-runtime/core-js/json/stringify');var _stringify2 = _interopRequireDefault(_stringify);var sync = function () &#123; var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee() &#123; var log, config, APP_ID, APP_KEY, publicDir, UrlsFile, urls, currentUser, userName, passWord, Counter; return _regenerator2.default.wrap(function _callee$(_context) &#123; while (1) &#123; switch (_context.prev = _context.next) &#123; case 0: log = this.log; config = this.config; if (!config.leancloud_counter_security.enable_sync) &#123; _context.next = 19; break; &#125; APP_ID = config.leancloud_counter_security.app_id; APP_KEY = config.leancloud_counter_security.app_key; publicDir = this.public_dir; UrlsFile = pathFn.join(publicDir, 'leancloud_counter_security_urls.json'); urls = JSON.parse(fs.readFileSync(UrlsFile, 'utf8')); AV.init(&#123; appId: APP_ID, appKey: APP_KEY &#125;); currentUser = AV.User.current(); if (currentUser) &#123; _context.next = 16; break; &#125; userName = config.leancloud_counter_security.username; passWord = config.leancloud_counter_security.password; if (!userName) &#123; userName = readlineSync.question('Enter your username: '); passWord = readlineSync.question('Enter your password: ', &#123; hideEchoBack: true &#125;); &#125; else if (!passWord) &#123; passWord = readlineSync.question('Enter your password: ', &#123; hideEchoBack: true &#125;); &#125; _context.next = 16; return AV.User.logIn(userName, passWord).then(function (loginedUser) &#123; log.info('Logined as: ' + loginedUser.getUsername()); &#125;, function (error) &#123; log.error(error); &#125;); case 16: log.info('Now syncing your posts list to leancloud counter...'); Counter = AV.Object.extend('Counter'); //----add---- urls.sort(cmp); var memoFile = pathFn.join(publicDir, "leancloud_memo.json"); if(!fs.existsSync(memoFile))&#123; fs.writeFileSync(memoFile, "[\n]"); &#125; var memoData = fs.readFileSync(memoFile, "utf-8").split("\n"); var memoIdx = 1; var newData = []; var cnt = 0; var limit = 0; var env = this; //----end---- _.forEach(urls, function (x) &#123; //----add---- var y = &#123;&#125;; y.title = ""; y.url = ""; var flag = false; while(true)&#123; if(memoData[memoIdx] == ']') break; y = JSON.parse(memoData[memoIdx].substring(0, memoData[memoIdx].length-1)); if(y.url &gt; x.url) break; if(y.url == x.url &amp;&amp; y.title == x.title)&#123; flag = true; break; &#125; memoIdx++; &#125; if(!flag) &#123; log.info("Dealing with record of " + x.title); limit++; //----end---- var query = new AV.Query('Counter'); query.equalTo('url', x.url); query.count().then(function (count) &#123; if (count === 0) &#123; var counter = new Counter(); counter.set('url', x.url); counter.set('title', x.title); counter.set('time', 0); counter.save().then(function (obj) &#123; log.info(x.title + ' is saved as: ' + obj.id); //----add---- newData.push(x); cnt++; postOperation(env, cnt, limit, newData, memoData); //----end---- &#125;, function (error) &#123; log.error(error); //----add---- cnt++; postOperation(env, cnt, limit, newData, memoData); //----end---- &#125;); &#125; //----add---- else&#123; newData.push(x); cnt++; postOperation(env, cnt, limit, newData, memoData); &#125; //----end---- &#125;, function (error) &#123; log.error(error); //----add---- cnt++; postOperation(env, cnt, limit, newData, memoData); //----end---- &#125;); //----add---- &#125; //----end---- &#125;); case 19: case 'end': return _context.stop(); &#125; &#125; &#125;, _callee, this); &#125;)); return function sync() &#123; return _ref.apply(this, arguments); &#125;;&#125;();function _interopRequireDefault(obj) &#123; return obj &amp;&amp; obj.__esModule ? obj : &#123; default: obj &#125;; &#125;var AV = require('leancloud-storage');var _ = require('lodash');var readlineSync = require('readline-sync');var packageInfo = require('./package.json');var pathFn = require('path');var fs = require('fs');function generate_post_list(locals) &#123; var config = this.config; if (config.leancloud_counter_security.enable_sync) &#123; var urlsPath = 'leancloud_counter_security_urls.json'; var urls = [].concat(locals.posts.toArray()).filter(function (x) &#123; return x.published; &#125;).map(function (x) &#123; return &#123; title: x.title, url: '/' + x.path &#125;; &#125;); return &#123; path: urlsPath, data: (0, _stringify2.default)(urls) &#125;; &#125;&#125;hexo.extend.generator.register('leancloud_counter_security_generator', generate_post_list);hexo.extend.deployer.register('leancloud_counter_security_sync', sync);var commandOptions = &#123; desc: packageInfo.description, usage: ' &lt;argument&gt;', 'arguments': [&#123; 'name': 'register | r &lt;username&gt; &lt;password&gt;', 'desc': 'Register a new user.' &#125;]&#125;;function commandFunc(args) &#123; var log = this.log; var config = this.config; if (args._.length !== 3) &#123; log.error('Too Few or Many Arguments.'); &#125; else if (args._[0] === 'register' || args._[0] === 'r') &#123; var APP_ID = config.leancloud_counter_security.app_id; var APP_KEY = config.leancloud_counter_security.app_key; AV.init(&#123; appId: APP_ID, appKey: APP_KEY &#125;); var user = new AV.User(); user.setUsername(String(args._[1])); user.setPassword(String(args._[2])); user.signUp().then(function (loginedUser) &#123; log.info(loginedUser.getUsername() + ' is successfully signed up'); &#125;, function (error) &#123; log.error(error); &#125;); &#125; else &#123; log.error('Unknown Command.'); &#125;&#125;hexo.extend.console.register('lc-counter', 'hexo-leancloud-counter-security', commandOptions, commandFunc);//----add----function cmp(x, y)&#123; if(x.url &lt; y.url) return -1; else if(x.url == y.url) return 0; else return 1;&#125;var postOperation = function (env, cnt, limit, newData, memoData)&#123; if(cnt == limit)&#123; var log = env.log; newData.sort(cmp); var sourceDir = env.source_dir; var publicDir = env.public_dir; var memoFile = pathFn.join(sourceDir, "leancloud_memo.json"); fs.writeFileSync(memoFile, "[\n"); var memoIdx = 1; for(var i = 0; newData[i]; i++)&#123; while(true)&#123; if(memoData[memoIdx] == ']') break; var y = JSON.parse(memoData[memoIdx].substring(0, memoData[memoIdx].length-1)); if(y.url &gt; newData[i].url) break; fs.writeFileSync(memoFile, memoData[memoIdx] + "\n", &#123;'flag':'a'&#125;); memoIdx++; &#125; fs.writeFileSync(memoFile, "&#123;\"title\":\"" + newData[i].title + "\",\"url\":\"" + newData[i].url + "\"&#125;,\n", &#123;'flag':'a'&#125;); &#125; while(memoData[memoIdx] != ']')&#123; fs.writeFileSync(memoFile, memoData[memoIdx] + "\n", &#123;'flag':'a'&#125;); memoIdx++; &#125; fs.writeFileSync(memoFile, memoData[memoIdx], &#123;'flag':'a'&#125;); var srcFile = pathFn.join(sourceDir, "leancloud_memo.json"); var destFile = pathFn.join(publicDir, "leancloud_memo.json"); var readStream = fs.createReadStream(srcFile); var writeStream = fs.createWriteStream(destFile); readStream.pipe(writeStream); console.log("leancloud_memo.json successfully updated."); &#125;&#125; 修改博客配置文件我们需要将leancloud_memo.json排除，否则的话会被渲染，我那个反正就是被渲染了。在博客配置文件中找到这个，然后加一项，如下：1skip_render: leancloud_memo.json 如果有多个项的话，可以这么加：1234skip_render: - 404.html - README.md - leancloud_memo.json 关键逻辑维护memoData和urls数组有序，能够在O(2n)的复杂度内判断出有哪些博文（包括改了题目的，改了文件名的）不在表中。最后的memoData和newData也是有序的，产生的新的文件也是有序的。详见代码，不做过多解释。 额外代价分析一下，额外引入的代价。时间上的代价： 对urls数组进行排序。O(nlogn) urls数组和memoData数组比较以确定某个记录需要向leancloud查询。O(2n) 排序newData数组。O(nlogn) 将memoData和newData数组整合成一个新的数组。O(2n) 将memoData字符串split成数组一次。 读取memoData一次。 写memoData n次。 拷贝memoData一次。 空间上的代价： 引入newData数组，O(n) 引入memoData数组，O(n) 引入一个文件leancloud_memo.json n是博文的数量，一般的话假设有1万篇，这个额外代价感觉还可以。 最后一行不加注释为什么不在上面代码最后艺一行加上//—-end—-？因为加上注释以后会报错。报错如下：12345678910111213141516171819202122232425ERROR Plugin load failed: hexo-leancloud-counter-securityE:\code\blog\node_modules\hexo-leancloud-counter-security\index.js:213&#125;^SyntaxError: Unexpected end of input at createScript (vm.js:80:10) at Object.runInThisContext (vm.js:139:10) at fs.readFile.then.script (E:\code\blog\node_modules\hexo\lib\hexo\index.js:230:19) at tryCatcher (E:\code\blog\node_modules\bluebird\js\release\util.js:16:23) at Promise._settlePromiseFromHandler (E:\code\blog\node_modules\bluebird\js\release\promise.js:512:31) at Promise._settlePromise (E:\code\blog\node_modules\bluebird\js\release\promise.js:569:18) at Promise._settlePromise0 (E:\code\blog\node_modules\bluebird\js\release\promise.js:614:10) at Promise._settlePromises (E:\code\blog\node_modules\bluebird\js\release\promise.js:693:18) at Promise._fulfill (E:\code\blog\node_modules\bluebird\js\release\promise.js:638:18) at Promise._resolveCallback (E:\code\blog\node_modules\bluebird\js\release\promise.js:432:57) at Promise._settlePromiseFromHandler (E:\code\blog\node_modules\bluebird\js\release\promise.js:524:17) at Promise._settlePromise (E:\code\blog\node_modules\bluebird\js\release\promise.js:569:18) at Promise._settlePromise0 (E:\code\blog\node_modules\bluebird\js\release\promise.js:614:10) at Promise._settlePromises (E:\code\blog\node_modules\bluebird\js\release\promise.js:693:18) at Promise._fulfill (E:\code\blog\node_modules\bluebird\js\release\promise.js:638:18) at E:\code\blog\node_modules\bluebird\js\release\nodeback.js:42:21 at E:\code\blog\node_modules\graceful-fs\graceful-fs.js:78:16 at FSReqWrap.readFileAfterClose [as oncomplete] (fs.js:511:3)ERROR Deployer not found: leancloud_counter_security_sync 问题解决如果你在hexo d的时候，发现leancloud那边儿没有添加上记录。排除了各种错误之后，还是没有的话。你可以把source文件夹下的leancloud_memo.json文件删除，然后重新hexo clean &amp; hexo g &amp; hexo d就好了。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>LeanCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo NexT 主题 LeanCloud 插件安装教程]]></title>
    <url>%2F2018%2F06%2F27%2Fhexo-leancloud-plugin-installation-tutor%2F</url>
    <content type="text"><![CDATA[记录一次大折腾。LeanCLoud这个是记录单篇博文阅读量的一个东西，之前配过一次，没这么难，这次学习了之后，发现这个东西还是挺麻烦的。多配几次就不麻烦了。mark一下。 LeanCloudLeanCloud能够给每篇博客统计访问量的工具。首先注册，并登陆LeanCloud。注意：登陆密码要求还得有大写英文字母，小写英文字母，还有数字。 膜拜大佬这篇博客是学习两位大佬，DoubleMine和leaferx，的博文之后写的 应用配置进入控制台后，我们先创建一个应用。点击创建应用然后弹出如下窗口：起名字，选择开发版，之后点击创建按钮创建完之后，我们看到下面这样。然后点击右上角的设置进入之后，我们点击存储，创建Class，弹出的对话框中名字要写Counter，必须写Counter是因为需要和NexT主题兼容。然后ACL权限选择无限制，不然容易统计次数不正常。最后点击创建Class按钮。创建Class的时候容易出现这个问题，如下图，刷新几次，就好了。现在获取应用ID和应用Key。设置，应用key。 主题配置我们把LeanCloud的应用ID和应用Key写到主题配置文件中了，注意此时是主题的配置文件config.yml，找到文件中对应位置，并修改成如下：1234567891011# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.leancloud_visitors: enable: true app_id: 填写 app_key: 填写 # Dependencies: https://github.com/theme-next/hexo-leancloud-counter-security # If you don't care about security in lc counter and just want to use it directly # (without hexo-leancloud-counter-security plugin), set the `security` to `false`. security: true betterPerformance: true enable写成true。把app_id和app_key填上去。然后注意下面，如果没有安装hexo-leancloud-counter-security插件的话，security就填写false。betterPerformance是能够让阅读次数加载更快一些，但是显示的实际数值可能不够准确。配置完了之后，hexo d一下，然后看看是否生效。之前的话应该就能生效了，但是现在好像不行了。如果不能生效请继续看。 Counter类未初始化问题如果你看到这里了，应该就是发现，计数功能无效。可能会出现下面的问题。Counter类未初始化。然后它提示我们看F12的Console，显示信息如下： hexo-leancloud-counter-security插件的安装与配置打开主题配置文件，确保刚刚的那个security已经设置为true。如下：1234567891011# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.leancloud_visitors: enable: true app_id: 填写 app_key: 填写 # Dependencies: https://github.com/theme-next/hexo-leancloud-counter-security # If you don't care about security in lc counter and just want to use it directly # (without hexo-leancloud-counter-security plugin), set the `security` to `false`. security: true betterPerformance: true 打开CMD，然后切换到博客的根目录。执行下面命令，以安装hexo-leancloud-counter-security插件1npm install hexo-leancloud-counter-security --save 等待安装结束之后，我们注册一个用户。命令如下：1hexo lc-counter r 用户名 密码 用户名，密码两处用你自己起好的名字和密码替换。不用和LeanCloud的登陆名和登陆密码一样。这个用于deploy的时候输入。然后打开博客配置文件。注意是博客的配置文件。123456leancloud_counter_security: enable_sync: true app_id: &lt;&lt;your app id&gt;&gt; app_key: &lt;&lt;your app key&gt; username: &lt;&lt;your username&gt;&gt; #如留空则将在部署时询问 password: &lt;&lt;your password&gt;&gt; #建议留空以保证安全性，如留空则将在部署时询问 然后在博客配置文件中找到deploy:，在deploy下边添加一个。如下：12deploy: - type: leancloud_counter_security_sync 之后去LeanCloud查看_User表中是否已经添加刚才的用户，点击存储，_User，看是否多一条记录，如下：然后对Counter表设置权限，点击存储，Counter，其他，权限设置。如下：然后弹出对话框，点击add_fields，指定用户，输入刚才用户，点击添加，添加成功能够看到两处不同，用户ID已经上去了。接下来，我们同样对create进行指定用户。然后，对delete指定用户，这个注意，不添加任何用户。然后关闭。这就设置好了。每次运行hexo d的时候，会扫描所有的博客，对于新的博客，Counter表里没有记录的时候，会新建一条记录。如果博客的配置文件中username和password那块儿留空的话，hexo d的时候需要手动输入密码。然后我们hexo d一下。看看效果。 同时部署git和leancloud的问题如果没出现这个问题，就跳过这一节如果你的博客配置文件中的deploy已经有一个git的了，那么可能会出现下边的问题。12345678910111213141516171819202122232425262728FATAL bad indentation of a mapping entry at line 86, column 3: - type: leancloud_counter_securi ... ^YAMLException: bad indentation of a mapping entry at line 86, column 3: - type: leancloud_counter_securi ... ^ at generateError (E:\code\blog\node_modules\js-yaml\lib\js-yaml\loader.js:165:10) at throwError (E:\code\blog\node_modules\js-yaml\lib\js-yaml\loader.js:171:9) at readBlockMapping (E:\code\blog\node_modules\js-yaml\lib\js-yaml\loader.js:1080:7) at composeNode (E:\code\blog\node_modules\js-yaml\lib\js-yaml\loader.js:1332:12) at readDocument (E:\code\blog\node_modules\js-yaml\lib\js-yaml\loader.js:1492:3) at loadDocuments (E:\code\blog\node_modules\js-yaml\lib\js-yaml\loader.js:1548:5) at Object.load (E:\code\blog\node_modules\js-yaml\lib\js-yaml\loader.js:1569:19) at Hexo.yamlHelper (E:\code\blog\node_modules\hexo\lib\plugins\renderer\yaml.js:7:15) at Hexo.tryCatcher (E:\code\blog\node_modules\bluebird\js\release\util.js:16:23) at Hexo.&lt;anonymous&gt; (E:\code\blog\node_modules\bluebird\js\release\method.js:15:34) at Promise.then.text (E:\code\blog\node_modules\hexo\lib\hexo\render.js:61:21) at tryCatcher (E:\code\blog\node_modules\bluebird\js\release\util.js:16:23) at Promise._settlePromiseFromHandler (E:\code\blog\node_modules\bluebird\js\release\promise.js:512:31) at Promise._settlePromise (E:\code\blog\node_modules\bluebird\js\release\promise.js:569:18) at Promise._settlePromise0 (E:\code\blog\node_modules\bluebird\js\release\promise.js:614:10) at Promise._settlePromises (E:\code\blog\node_modules\bluebird\js\release\promise.js:693:18) at Async._drainQueue (E:\code\blog\node_modules\bluebird\js\release\async.js:133:16) at Async._drainQueues (E:\code\blog\node_modules\bluebird\js\release\async.js:143:10) at Immediate.Async.drainQueues (E:\code\blog\node_modules\bluebird\js\release\async.js:17:14) at runCallback (timers.js:794:20) at tryOnImmediate (timers.js:752:5) at processImmediate [as _immediateCallback] (timers.js:729:5) 12345678910111213141516171819202122232425262728FATAL duplicated mapping key at line 86, column 3: type: leancloud_counter_security ... ^YAMLException: duplicated mapping key at line 86, column 3: type: leancloud_counter_security ... ^ at generateError (E:\code\blog\node_modules\js-yaml\lib\js-yaml\loader.js:165:10) at throwError (E:\code\blog\node_modules\js-yaml\lib\js-yaml\loader.js:171:9) at storeMappingPair (E:\code\blog\node_modules\js-yaml\lib\js-yaml\loader.js:308:7) at readBlockMapping (E:\code\blog\node_modules\js-yaml\lib\js-yaml\loader.js:1071:9) at composeNode (E:\code\blog\node_modules\js-yaml\lib\js-yaml\loader.js:1332:12) at readBlockMapping (E:\code\blog\node_modules\js-yaml\lib\js-yaml\loader.js:1062:11) at composeNode (E:\code\blog\node_modules\js-yaml\lib\js-yaml\loader.js:1332:12) at readDocument (E:\code\blog\node_modules\js-yaml\lib\js-yaml\loader.js:1492:3) at loadDocuments (E:\code\blog\node_modules\js-yaml\lib\js-yaml\loader.js:1548:5) at Object.load (E:\code\blog\node_modules\js-yaml\lib\js-yaml\loader.js:1569:19) at Hexo.yamlHelper (E:\code\blog\node_modules\hexo\lib\plugins\renderer\yaml.js:7:15) at Hexo.tryCatcher (E:\code\blog\node_modules\bluebird\js\release\util.js:16:23) at Hexo.&lt;anonymous&gt; (E:\code\blog\node_modules\bluebird\js\release\method.js:15:34) at Promise.then.text (E:\code\blog\node_modules\hexo\lib\hexo\render.js:61:21) at tryCatcher (E:\code\blog\node_modules\bluebird\js\release\util.js:16:23) at Promise._settlePromiseFromHandler (E:\code\blog\node_modules\bluebird\js\release\promise.js:512:31) at Promise._settlePromise (E:\code\blog\node_modules\bluebird\js\release\promise.js:569:18) at Promise._settlePromise0 (E:\code\blog\node_modules\bluebird\js\release\promise.js:614:10) at Promise._settlePromises (E:\code\blog\node_modules\bluebird\js\release\promise.js:693:18) at Async._drainQueue (E:\code\blog\node_modules\bluebird\js\release\async.js:133:16) at Async._drainQueues (E:\code\blog\node_modules\bluebird\js\release\async.js:143:10) at Immediate.Async.drainQueues (E:\code\blog\node_modules\bluebird\js\release\async.js:17:14) 这个问题，很简单，就是博客配置文件中deploy的那个位置，没写明白。如何让git和leancloud同时部署呢，如下：1234567deploy: - type: git repository: git@github.com:lmnsyunhao/lmnsyunhao.github.io.git branch: master - type: leancloud_counter_security_sync 这样写就行了。具体为啥这样写，简单学习一下YAML语法就好了。不做赘述 部署过程中leancloud过多请求问题如果没出现这个问题就跳过这一节。deploy d的过程中，还可能出现这个问题。看描述是请求过多。如下：12345678910ERROR Too many requests. [429 POST https://xtppdvlr.api.lncld.net/1.1/classes/Counter]Error: Too many requests. [429 POST https://xtppdvlr.api.lncld.net/1.1/classes/Counter] at E:\code\blog\node_modules\leancloud-storage\dist\node\request.js:163:17 at tryCatch (E:\code\blog\node_modules\es6-promise\dist\es6-promise.js:410:12) at invokeCallback (E:\code\blog\node_modules\es6-promise\dist\es6-promise.js:425:13) at publish (E:\code\blog\node_modules\es6-promise\dist\es6-promise.js:399:7) at publishRejection (E:\code\blog\node_modules\es6-promise\dist\es6-promise.js:340:3) at flush (E:\code\blog\node_modules\es6-promise\dist\es6-promise.js:128:5) at _combinedTickCallback (internal/process/next_tick.js:131:7) at process._tickCallback (internal/process/next_tick.js:180:9) 信息 - Too many requests.含义 - 超过应用的流控限制，即超过每个应用同一时刻最多可使用的工作线程数，或者说同一时刻最多可以同时处理的数据请求。通过 控制台 &gt; 存储 &gt; API 统计 &gt; API 性能 &gt; 总览 可以查看应用产生的请求统计数据，如平均工作线程、平均响应时间等。使用 LeanCloud 商用版或企业版 的用户，如有需要，可以联系我们来调整工作线程数。 以上是LeanCloud官方解释。这个就是你第一次部署的时候，你的博文太多了，leancloud那边儿收不过来。但是慢慢的我发现，在LeanCloud控制台那边儿所有的博文都已经有对应的记录了，但是每次hexo d时候还是报错，那是因为请求太快了。我查看了一下hexo-leancloud-counter-security的源代码，发现源代码中每次请求都会把所有博文的记录逐条查询。所以，我改了改源代码，详见hexo-leancloud-counter-security过多请求错误 查看记录这里能够查看记录。time就是阅读次数。这里可以直接改实现骚操作。title，url和createdAt字段不要乱改，不然容易出现问题。 安全中心保护点击设置，安全中心，Web安全域名。这个保证只有对应域名传过来的才有效，也就是说，别人用你的应用ID和应用Key是无效的。 云引擎保护云引擎保护访客数量不被随意篡改。点击云引擎，部署，在线编辑。然后点击创建函数。弹出的框中，选择Hook，beforeUpdate，Counter，函数内填写如下：12345678var query = new AV.Query("Counter");if (request.object.updatedKeys.indexOf('time') !== -1) &#123; return query.get(request.object.id).then(function (obj) &#123; if (obj.get("time") + 1 !== request.object.get("time")) &#123; throw new AV.Cloud.Error('Invalid update!'); &#125; &#125;)&#125; 然后点击保存。之后，我们能看到已经多了一个函数，然后点击上边的部署。弹出对话框，点击部署等待，直到部署完成，如下：]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
        <tag>LeanCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo d 时遇到 Host Key Verification Failed 问题]]></title>
    <url>%2F2018%2F06%2F24%2Fhexo-d-host-key-verification-failed-issue%2F</url>
    <content type="text"><![CDATA[Verification Failed，我记得之前就出现过这种问题，当时忘记了怎么解决的了。而且，也不确定真的是同一类问题。所以，我就先mark一下。 症状今天，在hexo d的时候遇到一个奇怪的问题，这个问题之前没出现过。自打win10更新一次以后就有问题了，不知道是不是更新的问题。以下是hexo报的log1234567891011121314151617181920212223On branch masternothing to commit, working tree cleanHost key verification failed.fatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists.FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlError: Host key verification failed.fatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists. at ChildProcess.&lt;anonymous&gt; (E:\code\blog\node_modules\hexo-util\lib\spawn.js:37:17) at emitTwo (events.js:126:13) at ChildProcess.emit (events.js:214:7) at ChildProcess.cp.emit (E:\code\blog\node_modules\cross-spawn\lib\enoent.js:40:29) at maybeClose (internal/child_process.js:925:16) at Socket.stream.socket.on (internal/child_process.js:346:11) at emitOne (events.js:116:13) at Socket.emit (events.js:211:7) at Pipe._handle.close [as _onclose] (net.js:567:12) 大概说的是ssh key认证失败，不能读取远程库。然后我把自己电脑上的rsa_pub重新放到了github上一次，结果还是失败。 解决方法要提前用ssh连一下github，把github的公钥记录在本地的know_hosts里面就好了。具体方法是，在cmd中输入如下命令：1ssh git@github.com 然后输入yes。之后再进行hexo d的时候就没这个问题了。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>GitHub</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Do U Need A Ladder ?]]></title>
    <url>%2F2018%2F06%2F20%2Fdo-you-need-a-ladder%2F</url>
    <content type="text"><![CDATA[授人以鱼不如授人以渔，我给你一个Ladder，不如教你配个Ladder。本文包括配IPv4，IPv6连接VPS，IPv6+Proxifier免校园网流量。然后还有过程中遇到的一些奇怪问题。mark一下。 映射请将本文中所有的“暗影袜子们”替换成如下字眼 安装SS在服务器端操作。我购买的是Digital Ocean的服务器，Ubuntu16.04系统。确认当前是root用户，通过pip安装。1234sudo apt-get updatesudo apt-get install python-pippip install --upgrade pippip install 暗影袜子们 如果你不想用这种方式安装SS，那么可以看apt方式安装SS一节。 pip无法安装的问题在上边安装的时候，可能会出现下面的问题，如果出现了，就解决一下，没出现当然就不用管这一节。报错如下：1234Traceback (most recent call last): File "/usr/bin/pip", line 9, in &lt;module&gt; from pip import mainImportError: cannot import name main 解决方法是修改/usr/bin/pip文件，改成下面的。123from pip import __main__if __name__ == &apos;__main__&apos;: sys.exit(__main__._main()) apt方式安装SS直接在命令行输入下面命令，如果有权限问题，注意加上sudo:12sudo apt-get updatesudo apt install 暗影袜子们 这样安装与上边有2点区别。第一，apt安装方式，ssserver的位置在/usr/bin/ssserver，而pip安装方法，ssserver在/usr/local/bin/ssserver第二，apt安装方式，ssserver没法加-d参数。不过这不要紧，用systemd设置开机自动时候不需要-d参数。 配置IPv4连接在服务器端操作。创建配置文件1vim /etc/暗影袜子们.json json文件中填写，如下12345678910&#123; "server":"服务器ip", "server_port":8388, "local_address": "127.0.0.1", "local_port":1080, "password":"自己设置的密码", "timeout":300, "method":"aes-256-cfb", "fast_open": false&#125; 字段名称 各个字段的含义 Name 解释说明 server 监听的服务器地址 server_port 监听的服务器端口 local_address 本地监听的地址 local_port 本地坚挺的端口 password 登陆用的密码 timeout 按秒计算 method 加密方法 默认是”aes-256-cfb” fast_open 快速打开，TCP_FASTOPEN, 填写true或者false workers number of workers, available on Unix/Linux 大家在设置的时候最好不要弄错了，就想例子中的那样。一个空格最好都不要错，否则容易出莫名其妙的问题。 配置IPv6连接在服务器端操作如果你的服务器有ipv6的公网地址，那么你可以通过ipv6来连接你的VPS。那么配置文件中就如下填写：12345678910&#123; "server":"::", "server_port":8388, "local_address": "127.0.0.1", "local_port":1080, "password":"自己设置的密码", "timeout":300, "method":"aes-256-cfb", "fast_open": false&#125; 就是server字段填::，这么填以后，你可以使用ipv6连接，也可以使用ipv4连接，亲测。 启动ssserver服务在服务器端操作。1ssserver -c /etc/暗影袜子们.json 输入命令就能够开启ssserver服务了上面的命令是工作在前台的进程。如果想把ssserver放到后台工作。那么用下面的命令启动和停止。12ssserver -c /etc/暗影袜子们.json -d startssserver -c /etc/暗影袜子们.json -d stop 如果你发现你的ssserver不支持-d命令的话，那么就是你安装暗影袜子们时候有问题。重装吧就。 客户端配置在客户端操作windows的客户端点选“添加服务器”，填写“地址”、“端口”、“加密方法”和“密码”即可。其中“端口”、“加密方法”和“密码”与前面设置的服务器配置相同。然后右键右下键的小飞机，确保服务器那块儿勾选的是自己刚刚配好的服务器如果服务器支持IPv4和IPv6双栈，那么客户端实际可以配置两个服务器参数，其仅有“地址”不相同。对于IPv4，填写服务器的IPv4地址；对于IPv6，填写服务器的IPv6地址（末尾不用加/64，也不用写[]）对于Ubuntu的配置，请看本文Ubuntu16.04 SS客户端 SwitchyOmega配置一节。 测试连通性为了保险起见，客户端选择IPv4连接服务器。解释一下系统代理模式中的全局模式和PAC模式，PAC就是一个规则，定义了有哪些网站在国内，有哪些网站在国外。如果选择了全局模式，不管访问国内还是国外的网站，都会走VPS代理；而PAC模式，只有在国外的走代理，国内的不走。但是PAC规则更新慢的话，有时候还得调成全局模式。全局模式访问国内网站，比PAC访问国内网站要慢一点，因为走了代理。客户端设置好之后，看是不是能够正常的登上梯子（客户端登陆youtube.com）。如果正常，那么就成功了。设置客户端中服务器为IPv6地址的，同样访问上述网站，若都能很快正常打开，则成功。可以测试一下支不支持IPv6，访问网站IPv6测试 ssserver配置systemd开机启动在服务器端操作systemd配置文件一般存在于/lib/systemd/system/和/etc/systemd/system/这两个文件夹下，我们需要在/lib/systemd/system下创建配置文件。如下：如果创建过程中有权限问题，自觉用sudo12cd /lib/systemd/systemvim ssserver.service 文件中写如下内容123456789101112# /lib/systemd/system/ssserver.service[Unit]Description=ssserverAfter=network.target[Service]ExecStart=/usr/local/bin/ssserver -c /etc/暗影袜子们.jsonRestart=on-failure[Install]WantedBy=multi-user.target 创建了文件之后，需要重新加载配置一下。1systemctl daemon-reload 确保ssserver处于关闭状态，然后试试把刚才创建的ssserver.service启动1systemctl start ssserver.service 如果没报任何信息的话，查看一下状态。1systemctl status ssserver.service 如果显示running的话，那么就是配置成功了，然后设置一下开机启动。如果没有显示running，启动失败了的话，看下你们的暗影袜子们.json这个文件内容有没有写错，最好空格什么的不要少，也不要多。然后看下ssserver这个东西是不是在/usr/local/bin/ssserver这。用命令which ssserver看看这个是不是对的，有可能在/usr/bin/ssserver路径。然后把上边的那个文件ssserver.service中对应位置改成/usr/bin/ssserver。这样应该就能成了。1systemctl enable ssserver.service 到这里，已经达到目的了，下面是一些有意思的操作，感兴趣的可以看一下。不感兴趣的不看也ok。 配置全局代理+Proxifier Proxifier这个软件可以修改电脑上应用程序的代理，对于某些程序本身没有提供配置代理的功能时候，用这个方法就能够配置应用程序的代理了。 配置这个的目的是让VPS和本地间走ipv6流量，然后系统代理模式选择全局代理，也就是说让所有的网络访问都走VPS。这样的话，也就是说所有的网络都走ipv6。这种情况下会有一些问题。有的软件不支持用前面这种形式访问网络。这个时候我们就需要一个叫做Proxifier的软件来给这些软件搞一下，让他们也能正常了。因为都是ipv6，所以就免流量了，而且不用登录校园网，这就是我们要的效果。首先，VPS那边得是ipv6能够访问的，就是配好了上边说的ipv6连接，其次，本地也需要有ipv6的地址。二者缺一不可。然后。配置一下Proxifier。配置方法如下：打开Proxifier，然后Profile，Proxy Servers，点击右侧Add。如下这样添加。点击确定。添加之后如下图：打开，Profile，Proxification Rules。如下设置点击Profile，Name Resolution：如下设置：这个时候，注销校园网络登陆。然后看看行不行？如果qq能正常使用，说明大功告成了。下次再使用的时候，ipv6连接+Proxifier都打开，就能够免流量了。我用的是有线连接的校园网（没登录），没测试无线能不能用，不过如果无线连接的时候，本地有ipv6地址的话，应该就能用。 这时候会出问题，比如使用localhost:4000调试hexo时候，会无法访问。感觉是dns问题，因为现在是ipv6，可能会解析到ipv6的地址，然后proxifier会报错说，没法解决ipv4和ipv6混合使用的问题。这个时候不用localhost:4000，访问127.0.0.1:4000就能调试hexo了。 Google BBR 加速说是能给网络加速，实际效果感觉并不明显，还是写一下吧。root登陆服务器，输入下面命令。123wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.shchmod +x bbr.sh./bbr.sh 安装完事儿之后会让重启服务器，然后就重启吧。输入下面命令。验证是否安装最新内核并开启了BBR。1uname -r 查看一下；1sysctl net.ipv4.tcp_available_congestion_control 上面结果中，看看等号后边带不带bbr，带就行。1sysctl net.ipv4.tcp_congestion_control 上面结果应该等于bbr。1sysctl net.core.default_qdisc 上面结果应该等于fq。1lsmod | grep bbr 上面结果中，看看有没有tcp_bbr，说明已经启动。 过了两天我保证我这两天，没动服务器，也没开电脑。然后就出现了一个状况。ipv6可以连上服务器，但是ipv4死活连不上服务器。经过一番排查，我感觉是服务器那边的问题。然后，于此同时我用ssh竟然没法连接DigitalOcean的服务器了。闹心。我这个DigitalOcean最开始新建Droplet的时候，没有选ssh。不过，最开始的时候是能够用ssh连的，然后过了两天就连接超时，只能通过网页端的console连接。我查了不少教程又看了官方文档。并不会解决，然后我将droplet的系统重装了。然后依旧是这个问题。然后，我就把这个droplet删了。新建了一个droplet，新建时候上传了ssh公钥，并选择了对应的公钥。然后，当然ssh的连接超时的问题就解决了。然后照着我上边说的又走了一遍，ipv4连不上的问题也解决了。 Ubuntu16.04 SS客户端 浏览器 SwitchyOmega配置这里说下Ubuntu配置，Ubuntu的配置相对较麻烦。首先需要在客户端安装暗影袜子们。安装方式与上面相似。1234sudo apt-get updatesudo apt-get install python-pippip install --upgrade pippip install 暗影袜子们 当然，如果出现pip无法安装的问题，请看上面的那节，同样解决一下。安完之后，在/etc目录下新建一个暗影袜子们.json的文件。文件中如下填写：12345678910&#123; "server":"上面配好的服务器的ip", "server_port":8388, "local_address":"127.0.0.1", "local_port":1080, "password":"自己设置的密码", "timeout":300, "method":"aes-256-cfb", "fast_open":false&#125; 其实这个文件和上面的那个配置文件好像一样。然后，启动下看看能否成功启动sslocal -c /etc/暗影袜子们.json，如果能够正常启动，那么客户端这边儿就和服务器连上了。但是打开chrome，还是没法出去，比如油管网。这个时候，我们还需要配一下浏览器的代理。我以chrome浏览器为例。讲解一下配置。有个东西叫做，SwitchyOmega，点击链接下载，如下下载了之后应该是一个以crx后缀的文件。在浏览器的地址栏输入：chrome://extensions，将刚才下载的crx文件拖动到这里，会提示安装。如下然后，等待安装成功会有提示，打开SwitchyOmega，配置一下代理。点击左侧新建情景模式，弹出对话框。名称随便起，类型选代理服务器，然后点击创建，如下图然后点击新建的情景模式，代理协议选择SOCKS5，代理服务器填写127.0.0.1，代理端口填写1080。然后点击应用选项然后再点击左侧的auto switch然后，勾选规则列表规则，后边选SS，就是你刚才配的情景模式，默认情景模式选择直接连接，规则列表格式选择AutoProxy规则列表地址填写https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt，然后点击立即更新情景模式。然后点击应用选项。如下图：这个时候再切换到auto switch就好了。访问一下youtube.com，应该就能成功了。之后再配置一下sslocal的开机子启动，请见sslocal配置systemd开机启动一节。PS:Windows上的chrome浏览器同样也可以加载这个插件，来增加规则，对于外边的网站走代理，里面的网站不走代理。配置过程相似。 sslocal配置systemd开机启动在客户端操作systemd配置文件一般存在于/lib/systemd/system/和/etc/systemd/system/这两个文件夹下，我们需要在/etc/systemd/system下创建配置文件。如下：如果创建过程中有权限问题，自觉用sudo12cd /etc/systemd/systemvim sslocal.service 文件中写如下内容12345678910111213# /lib/systemd/system/sslocal.service[Unit]Description=sslocalAfter=network.target[Service]ExecStart=/usr/local/bin/sslocal -c /etc/暗影袜子们.jsonExecStop=/bin/kill -s TERM $MAINPIDRestart=on-failure[Install]WantedBy=multi-user.target 创建了文件之后，需要重新加载配置一下。1systemctl daemon-reload 确保sslocal现在处于关闭状态，然后试试把刚才创建的sslocal.service启动1systemctl start sslocal.service 如果没报任何信息的话，查看一下状态。1systemctl status sslocal.service 如果显示running的话，那么就是配置成功了，然后设置一下开机启动1systemctl enable sslocal.service 写在几个月后Digital Ocean把我的账号封了。于是，我换了一个VPS供应商，Vultr。配置方式都一样。]]></content>
      <categories>
        <category>服务器</category>
        <category>Ladder</category>
      </categories>
      <tags>
        <tag>Ladder</tag>
        <tag>Proxifier</tag>
        <tag>VPS</tag>
        <tag>服务器</tag>
        <tag>代理</tag>
        <tag>DigitalOcean</tag>
        <tag>SwitchyOmega</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows10 开启OpenSSH服务 CMD配置SSH远程连接服务]]></title>
    <url>%2F2018%2F06%2F19%2Fwindows-openssh-and-ssh-remote-connection%2F</url>
    <content type="text"><![CDATA[windows10开启OpenSSH的两种方法，不用去下载PuTTY，XShell啦，CMD直接可以使用SSH服务。 开启OpenSSH服务想要cmd能够使用ssh远程连接服务。我们需要打开OpenSSH服务。首先打开设置，快捷键windows键+I。然后打开应用。然后看到右侧有管理可选功能。点击管理可选功能如果列表中有OpenSSH 客户端，或者是OpenSSH Client字样的东西，说明你的电脑已经开启了OpenSSH服务了。如果没开启OpenSSH服务，那么就点击添加功能，然后把OpenSSH安装了就行了。安装了之后，重启一下电脑，然后才能在CMD中使用ssh远程连接的服务。我们可以看到打开OpenSSH服务之后，也就开启了上图的功能。 SSH远程连接我们打开CMD或者是powershell之后，就能够发现可以使用ssh远程连接服务了。]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>OpenSSH</tag>
        <tag>CMD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows10 生成 SSH密钥 GitHub配置]]></title>
    <url>%2F2018%2F06%2F19%2Fwindows-github-ssh-key%2F</url>
    <content type="text"><![CDATA[很多地方都需要用到SSH服务，本文简述SSH技术，如何生成并使用SSH密钥，GitHub SSH连接。 SSH的简介SSH技术是指通信的双方A，B，分别有自己的公钥和私钥，公钥负责加密信息，私钥负责解密信息。设定是这样的A公钥加密的信息，只能通过A的私钥来解密，不能通过其他的私钥来解密，而且通过A的公钥很难推断出A的私钥。通信开始前，双方得知对方的公钥，A给B发送数据，用B的公钥来加密。B给A发送数据用A的公钥来加密。此项技术能够保证通信之间的安全性。即使信息被第三方获取，也无法解密。避免了信息被窃取，篡改，和冒充的情况。 生成密钥首先看看，C盘用户目录(例如：C:\Users\yunhao)下，有没有.ssh这个文件夹。如果有就不用生成，没有就生成一下。或者.ssh文件夹里面没有东西的话也需要生成Windows环境下生成SSH密钥和Ubuntu下生成密钥的方法几乎相仿。windows下生成可以借助GitBash来生成。在某个文件夹下右键，然后打开GitBash。如果不想用GitBash来生成key的话。那么请看本文OpenSSH服务一节输入ssh-keygen回车。生成过程中，会有提示，然后会输入两次密码，这个密码是在使用ssh时候用的，如果不想设置密码的话，就直接回车就好了。 GitHub上配置登陆Github网站，找到个人设置界面。左侧有 SSH and GPG keys 类似字样的选项，点击。然后新建一个 SSH 的 key， 把C:\Users\username\.ssh\id_rsa.pub中的内容复制过去。然后保存。之后就OK了。 OpenSSH服务还有一种方法能够生成密钥。就是开启Windows的OpenSSH服务。之后使用cmd输入ssh-keygen命令来生成。开启方法如下：开启OpenSSH方法]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>Git</tag>
        <tag>GitHub</tag>
        <tag>OpenSSH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GoDaddy 域名 托管于腾讯云解析]]></title>
    <url>%2F2018%2F06%2F18%2Fgodaddy-domain-dns-on-tencent-cloud%2F</url>
    <content type="text"><![CDATA[GoDaddy上面买了域名，看大家都说托管到DNSPod上边快。于是我就写了这样一篇博客，DNSPod就是腾讯云。几乎一样。嗯。 腾讯云获取域名服务器注册并登陆了腾讯云之后，找到控制台。然后找到域名服务，云解析。然后点击添加解析。将你要解析的域名加进来。添加域名就是你购买的域名，项目就默认就行。然后能看到添加的域名，点击后边的解析。然后应该会弹框出来，提示你去域名注册商处修改域名服务器。如下图，如果没有弹框的话，请继续看如果没弹框，我们可以看到上边的域名服务器的地址。并且它提示我们去到域名注册商处更改地址。 GoDaddy自定义域名服务器首先是去GoDaddy登陆账户（登陆密码还得要求有大写英文字母，小写英文字母，还有数字）。然后找到我的产品。然后是找到需要托管的域名的DNS。点击了DNS之后，我们可以看到，记录和域名服务器俩栏。我们需要把下面的域名服务器改成自定义的，然后将腾讯云上边的那个域名服务器的地址填上。刷新一下界面，我们就能够看到记录的位置显示信息，表示已经脱离了Godaddy的管理了。这个时候我们就只需要在腾讯云上添加解析的记录就ok了。 腾讯云添加记录添加记录的过程中，A类型是将域名指向IP，CNAME类型是将域名指向另一个域名。比如主机记录填写@，记录类型写CNAME，线路类型默认，记录值写lmnsyunhao.github.io，TTL600。这个就是表示在访问yunhao.space的时候就会解析到lmnsyunhao.github.io这个域名。相当于直接访问lmnsyunhao.github.io这个域名。比如主机记录填写www，记录类型写A，线路类型默认，记录值写8.8.8.8，TTL600。这个表示在访问www.yunhao.space的时候会解析到8.8.8.8。相当于直接访问8.8.8.8这个IP。@主机记录表示三级域名处为空。如果记录类型选CNAME那么记录值只能写域名才有效，记录类型选A，记录值只能写IP地址才有效。详细添加记录，请参考域名解析配置教程]]></content>
      <categories>
        <category>服务器</category>
        <category>域名</category>
      </categories>
      <tags>
        <tag>域名</tag>
        <tag>DNS</tag>
        <tag>GoDaddy</tag>
        <tag>腾讯云</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM HDU 2089 题解 数位DP]]></title>
    <url>%2F2018%2F06%2F17%2Facm-hdu-2089-digital-dp%2F</url>
    <content type="text"><![CDATA[不要62，经典数位DP，这是记忆化搜索，从高位向低位dfs。详见本文具体内容 题目不要62 限制Time Limit: 1000/1000 MS (Java/Others)Memory Limit: 32768/32768 K (Java/Others) 描述杭州人称那些傻乎乎粘嗒嗒的人为62（音：laoer）。杭州交通管理局经常会扩充一些的士车牌照，新近出来一个好消息，以后上牌照，不再含有不吉利的数字了，这样一来，就可以消除个别的士司机和乘客的心理障碍，更安全地服务大众。不吉利的数字为所有含有4或62的号码。例如：62315 73418 88914都属于不吉利号码。但是，61152虽然含有6和2，但不是62连号，所以不属于不吉利数字之列。你的任务是，对于每次给出的一个牌照区间号，推断出交管局今次又要实际上给多少辆新的士车上牌照了。 输入格式输入的都是整数对$n,m$$(0 \lt n \le m \lt 1000000)$，如果遇到都是0的整数对，则输入结束。 输出格式对于每个整数对，输出一个不含有不吉利数字的统计个数，该数值占一行位置。 样本121 1000 0 180 思路数位DP。这是记忆化搜索，从高位向低位dfs。首先s数组中存储数字是从低位到高位存储的，比如100，在s数组中就是[0,0,1]这么存的。len是数的位数dp[i][0]表示在第i+1位不是6并且低i位没有限制的情况下，低i位中满足条件的数的个数。dp[i][1]表示在第i+1位是6并且低i位没有限制的情况下，低i为中满足条件的数的个数。dp数组用于记忆化搜索。说一下代码吧。这道题是求n到m中（含边界数）满足条件的个数，也就是求m以内的满足条件个数，再减去n-1以内满足条件个数。说下dfs。pos是当前位数；lim是当前位数的上限值，-1代表没上限，0到9之间的数字代表有上限；prev是高一位的数字是几。首先判断边界，pos&lt;0的情况代表找到了一个数，所以要return 1;这个为啥不return 0?自己想一下，return 0的话结果永远都是0了。然后判断是不是没限制，即lim==-1并且，dp对应的位置不是0，即之前求过并存储下来了，那么就直接返回。否则就继续求。然后就是循环次数了。up是循环次数。for循环的意义是对于pos位是各种数字的情况下，继续dfs pos-1位的情况。循环中，如果是4那么跳过；如果是2并且上一位是4直接跳过；如果i和lim相等，即这一位到了上限，那么在继续进行dfs的时候，下一位也要注意上限的问题，免得超了，所以要把s[pos-1]作为参数，不然的话，就直接传-1了。循环结束后进行记录，如果当前没有上限，即这个值在之后还有利用价值，那么就计入dp，否则，不计入。然后返回这个tmp，tmp是结果。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int n, m;int s[10];int len;int dp[10][2];int dfs(int pos, int lim, int prev)&#123; if(pos &lt; 0) return 1; if(lim == -1 &amp;&amp; dp[pos][prev == 6] != 0) return dp[pos][prev == 6]; int up = lim==-1?9:lim; int tmp = 0; for(int i = 0; i &lt;= up; i++)&#123; if(i == 4) continue; if(i == 2 &amp;&amp; prev == 6) continue; if(i == lim) tmp += dfs(pos-1, s[pos-1], i); else tmp += dfs(pos-1, -1, i); &#125; if(lim == -1)&#123; dp[pos][prev == 6] = tmp; &#125; return tmp;&#125;int solve(int num)&#123; len = 0; memset(s, 0, sizeof s); while(num &gt; 0)&#123; s[len++] = num % 10; num /= 10; &#125; return dfs(len-1, s[len-1], -1);&#125;int main()&#123; while(~scanf("%d %d", &amp;n, &amp;m))&#123; if(n == 0 &amp;&amp; m == 0) break; memset(dp, 0, sizeof dp); printf("%d\n", solve(m)-solve(n-1)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DP</tag>
        <tag>HDU</tag>
        <tag>数位DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM LightOJ 1422 题解 区间DP]]></title>
    <url>%2F2018%2F06%2F14%2Facm-lightoj-1422-dp-on-segment%2F</url>
    <content type="text"><![CDATA[Halloween Costumes，区间划分DP。dp[a][b]表示区间[a,b]内最少需要多少件戏服。详见本文内容 题目1422 - Halloween Costumes 限制Time Limit: 2 second(s)Memory Limit: 32 MB 描述Gappu has a very busy weekend ahead of him. Because, next weekend is Halloween, and he is planning to attend as many parties as he can. Since it’s Halloween, these parties are all costume parties, Gappu always selects his costumes in such a way that it blends with his friends, that is, when he is attending the party, arranged by his comic-book-fan friends, he will go with the costume of Superman, but when the party is arranged contest-buddies, he would go with the costume of ‘Chinese Postman’.Since he is going to attend a number of parties on the Halloween night, and wear costumes accordingly, he will be changing his costumes a number of times. So, to make things a little easier, he may put on costumes one over another (that is he may wear the uniform for the postman, over the superman costume). Before each party he can take off some of the costumes, or wear a new one. That is, if he is wearing the Postman uniform over the Superman costume, and wants to go to a party in Superman costume, he can take off the Postman uniform, or he can wear a new Superman uniform. But, keep in mind that, Gappu doesn’t like to wear dresses without cleaning them first, so, after taking off the Postman uniform, he cannot use that again in the Halloween night, if he needs the Postman costume again, he will have to use a new one. He can take off any number of costumes, and if he takes off $k$ of the costumes, that will be the last $k$ ones (e.g. if he wears costume $A$ before costume $B$, to take off $A$, first he has to remove $B$).Given the parties and the costumes, find the minimum number of costumes Gappu will need in the Halloween night. 输入格式Input starts with an integer $T (\le 200)$, denoting the number of test cases.Each case starts with a line containing an integer $N$ $(1 \le N \le 100)$ denoting the number of parties. Next line contains $N$ integers, where the $i^{th}$ integer $c_i$ $(1 \le c_i \le 100)$ denotes the costume he will be wearing in party $i$. He will attend party 1 first, then party 2, and so on. 输出格式For each case, print the case number and the minimum number of required costumes. 样本12345241 2 1 271 2 1 1 3 2 1 12Case 1: 3Case 2: 4 思路区间划分DP。dp[a][b]表示区间[a,b]内最少需要多少件戏服。对于不同长度的每个区间，dp[a][b]最大是b-a+1，然后对以下情况考虑，选出最小值第一，如果区间的两端的戏服是一样的，那么就说明这件戏服在这个区间里可以一直穿着，即dp[a+1][b-1]+1第二，对区间进行划分，对于每个划分，选择最小值。min(dp[a][b], dp[a][k]+dp[k+1][b])第三，对区间划分的时候，如果中间有个数，等于两端的数。即num[k] == num[b]并且num[k] == num[a]，这种情况下，可以省一件戏服，可以从头穿到尾。所以是dp[a][k]+dp[k+1][b]-1，与dp[a][b]比较，选择最小值大概的思路就是这样。看下代码，第21行是对区间长度迭代，第22行是对区间起始节点进行迭代，29行是对不同的划分位置进行迭代。 代码123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int t;int n;int num[105];int dp[105][105];int main()&#123; while(~scanf("%d", &amp;t))&#123; for(int w = 1; w &lt;= t; w++)&#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++)&#123; scanf("%d", &amp;num[i]); &#125; memset(dp, 0, sizeof dp); for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; n-i; j++)&#123; dp[j][j+i] = i+1; if(num[j] == num[j+i])&#123; dp[j][j+i] = min(dp[j][j+i], dp[j+1][j+i-1]+1); &#125; for(int k = j; k &lt; j+i; k++)&#123; dp[j][j+i] = min(dp[j][j+i], dp[j][k]+dp[k+1][j+i]); if(k != j &amp;&amp; k != j+i &amp;&amp; num[k] == num[j] &amp;&amp; num[k] == num[j+i])&#123; dp[j][j+i] = min(dp[j][j+i], dp[j][k]+dp[k+1][j+i]-1); &#125; &#125; &#125; &#125; printf("Case %d: %d\n", w, dp[0][n-1]); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DP</tag>
        <tag>区间DP</tag>
        <tag>LightOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM POJ 1651 题解 区间DP]]></title>
    <url>%2F2018%2F06%2F11%2Facm-poj-1651-dp-on-segment%2F</url>
    <content type="text"><![CDATA[Multiplication Puzzle，划分区间DP。无条件划分区间。详见本文具体内容 题目Multiplication Puzzle 限制Time Limit: 1000MSMemory Limit: 65536K 描述The multiplication puzzle is played with a row of cards, each containing a single positive integer. During the move player takes one card out of the row and scores the number of points equal to the product of the number on the card taken and the numbers on the cards on the left and on the right of it. It is not allowed to take out the first and the last card in the row. After the final move, only two cards are left in the row.The goal is to take cards in such order as to minimize the total number of scored points.For example, if cards in the row contain numbers 10 1 50 20 5, player might take a card with 1, then 20 and 50, scoring$$10 \times 15 \times 0 + 50 \times 20 \times 5 + 10 \times 50 \times 5 = 500+5000+2500 = 8000$$If he would take the cards in the opposite order, i.e. 50, then 20, then 1, the score would be$$1 \times 50 \times 20 + 1 \times 20 \times 5 + 10 \times 1 \times 5 = 1000+100+50 = 1150$$ 输入格式The first line of the input contains the number of cards $N$ $(3 \le N \le 100)$. The second line contains $N$ integers in the range from $1$ to $100$, separated by spaces. 输出格式Output must contain a single integer - the minimal score. 样本12610 1 50 50 20 5 13650 思路划分区间DP。无条件划分区间。dp[a][b]是区间[a,b]的最小的分值。举个例子。序列$1,2,3,4,5$，这就是取$2,3,4$这三个，一共有$6$种组合方式： $2,3,4: \quad 1 \times 2 \times 3+1 \times 3 \times 4+1 \times 4 \times 5$ $2,4,3: \quad 1 \times 2 \times 3+3 \times 4 \times 5+1 \times 3 \times 5$ $3,2,4: \quad 2 \times 3 \times 4+1 \times 2 \times 4+1 \times 4 \times 5$ $3,4,2: \quad 2 \times 3 \times 4+2 \times 4 \times 5+1 \times 2 \times 5$ $4,2,3: \quad 3 \times 4 \times 5+1 \times 2 \times 3+1 \times 3 \times 5$ $4,3,2: \quad 3 \times 4 \times 5+2 \times 3 \times 5+1 \times 2 \times 5$ 也就是说$1,2,3,4,5$的最小分值是从这$6$个组合方式中计算出的。现在考虑区间划分。第一，划分成$[1,2],[2,3,4,5]$两段，$[1,2]$序列中没法计算最小分值，所以考虑序列$[2,3,4,5]$，这个区间的最小分值是从下面这两个序列中计算出来的。$3,4: \quad 2 \times 3 \times 4+2 \times 4 \times 5$$4,3: \quad 3 \times 4 \times 5+2 \times 3 \times 5$与原序列相比，2这个数字还没有移除，我们在后边加上2移除时候的值，得到：$3,4,2: \quad 2 \times 3 \times 4+2 \times 4 \times 5+1 \times 2 \times 5$$4,3,2: \quad 3 \times 4 \times 5+2 \times 3 \times 5+1 \times 2 \times 5$ 第二，划分成$[1,2,3][3,4,5]$两段，$[1,2,3]$序列的最小分值就是将2移除时的分值，$[3,4,5]$序列的最小分值就是将4移除时的分值。所以，我们可以得到这样两个式子：$2,4: \quad 1 \times 2 \times 3+3 \times 4 \times 5$$4,2: \quad 3 \times 4 \times 5+1 \times 2 \times 3$与原序列相比，3这个数字还没有移除，我们在后边再加上3移除时候的值，得到：$2,4,3: \quad 1 \times 2 \times 3+3 \times 4 \times 5+1 \times 3 \times 5$$4,2,3: \quad 3 \times 4 \times 5+1 \times 2 \times 3+1 \times 3 \times 5$ 第三，划分成$[1,2,3,4][4,5]$两段，同理，我们可以得到下面两个：$2,3: \quad 1 \times 2 \times 3+1 \times 3 \times 4$$3,2: \quad 2 \times 3 \times 4+1 \times 2 \times 4$与原序列相比，4还没移除，将4移除。$2,3,4: \quad 1 \times 2 \times 3+1 \times 3 \times 4+1 \times 4 \times 5$$3,2,4: \quad 2 \times 3 \times 4+1 \times 2 \times 4+1 \times 4 \times 5$ 可以看出，拆成了小区间之后，两个小区间的情况再加上边界的数移除的值，就是大区间的所有情况。大概就是这样，我们能看到了整体和局部的关系。这样的话，就可以用划分区间DP了。大区间的解可以从小区间的解中推到出来。上面的例子说明了，大区间求最小值可以拆成小区间，从小区间的最小值中构造出来。解释一下代码，18行对区间长度进行迭代，19行对区间起始节点进行迭代，20行对一个区间的不同划分点进行迭代。转移规则就是在所有划分中取最小值，对于某一个划分的值等于，两个小区间的dp值再加上边界数移除的值。代码中dp默认赋值为0, 所以22行要直接赋值一下，不然最小值永远都是0了，因为序列中所有的数是整数，最小值一定比0大。 代码1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int n;int num[105];int dp[105][105];int main()&#123; while(~scanf("%d", &amp;n))&#123; for(int i = 0; i &lt; n; i++)&#123; scanf("%d", &amp;num[i]); &#125; memset(dp, 0, sizeof dp); for(int i = 2; i &lt; n; i++)&#123; for(int j = 0; j &lt; n-i; j++)&#123; for(int k = j+1; k &lt; j+i; k++)&#123; if(dp[j][j+i] == 0) dp[j][j+i] = dp[j][k]+dp[k][j+i]+num[j]*num[k]*num[j+i]; else dp[j][j+i] = min(dp[j][j+i], dp[j][k]+dp[k][j+i]+num[j]*num[k]*num[j+i]); &#125; &#125; &#125; printf("%d\n", dp[0][n-1]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DP</tag>
        <tag>区间DP</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM POJ 2955 题解 区间DP]]></title>
    <url>%2F2018%2F06%2F10%2Facm-poj-2955-dp-on-segment%2F</url>
    <content type="text"><![CDATA[Brackets。区间划分DP，没有限制的区间划分。详见本文内容 题解Brackets 限制Time Limit: 1000MSMemory Limit: 65536K 描述We give the following inductive definition of a “regular brackets” sequence: the empty sequence is a regular brackets sequence, if s is a regular brackets sequence, then (s) and [s] are regular brackets sequences, and if a and b are regular brackets sequences, then ab is a regular brackets sequence. no other sequence is a regular brackets sequence For instance, all of the following character sequences are regular brackets sequences:(), [], (()), ()[], ()[()]while the following character sequences are not:(, ], )(, ([)], ([(]Given a brackets sequence of characters $a_1a_2…a_n$, your goal is to find the length of the longest regular brackets sequence that is a subsequence of $s$. That is, you wish to find the largest $m$ such that for indices $i_1, i_2, …, i_m$ where $1 \le i_1 \lt i_2 \lt … \lt i_m \le n$, $a_{i_1}a_{i_2} … a_{i_m}$ is a regular brackets sequence.Given the initial sequence ([([]])], the longest regular brackets subsequence is [([])]. 输入格式The input test file will contain multiple test cases. Each input test case consists of a single line containing only the characters (, ), [, and ]; each input test will have length between $1$ and $100$, inclusive. The end-of-file is marked by a line containing the word “end” and should not be processed. 输出格式For each input case, the program should print the length of the longest possible regular brackets subsequence on a single line. 样本123456((()))()()()([]]))[)(([][][)end 1234566406 思路区间划分DP，没有限制的区间划分。dp[a][b]存的是区间[a,b]内满足要求的符号表达式的最大长度。然后dp[a][b]的最大长度，是对区间[a,b]进行划分得到的所有结果中，的最大值。如果str[a]==’(‘并且str[b]==’)’或者是str[a]==’[‘并且str[b]==’]’，即a位置与b位置正好能够配对的时候，dp[a][b]还要与dp[a+1][b-1]作比较，dp[a][b]取最大值。解释一下代码，16行的i是对区间长度进行迭代。17行的j是对不同的区间起始节点进行迭代。18行是对[j,j+i]区间的不同划分点进行迭代。 代码1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int dp[105][105];char str[105];int main()&#123; while(~scanf("%s", str))&#123; if(str[0] == 'e') break; int n = strlen(str); memset(dp, 0, sizeof dp); for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; n-i; j++)&#123; for(int k = j; k &lt; j+i; k++)&#123; dp[j][j+i] = max(dp[j][j+i], dp[j][k]+dp[k+1][j+i]); &#125; if((str[j] == '(' &amp;&amp; str[j+i] == ')') || (str[j] == '[' &amp;&amp; str[j+i] == ']')) dp[j][j+i] = max(dp[j][j+i], dp[j+1][j+i-1]+2); &#125; &#125; printf("%d\n", dp[0][n-1]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DP</tag>
        <tag>区间DP</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM HDU 4745 题解 区间DP]]></title>
    <url>%2F2018%2F06%2F10%2Facm-hdu-4745-dp-on-segment%2F</url>
    <content type="text"><![CDATA[Two Rabbits，在一个长度是n的环形序列上，找一个不连续的回文序列的最大长度。详见具体内容 题目Two Rabbits 限制Time Limit: 10000/5000 MS (Java/Others)Memory Limit: 65535/65535 K (Java/Others) 描述Long long ago, there lived two rabbits Tom and Jerry in the forest. On a sunny afternoon, they planned to play a game with some stones. There were $n$ stones on the ground and they were arranged as a clockwise ring. That is to say, the first stone was adjacent to the second stone and the n-th stone, and the second stone is adjacent to the first stone and the third stone, and so on. The weight of the i-th stone is ai.The rabbits jumped from one stone to another. Tom always jumped clockwise, and Jerry always jumped anticlockwise.At the beginning, the rabbits both choose a stone and stand on it. Then at each turn, Tom should choose a stone which have not been stepped by itself and then jumped to it, and Jerry should do the same thing as Tom, but the jumping direction is anti-clockwise.For some unknown reason, at any time , the weight of the two stones on which the two rabbits stood should be equal. Besides, any rabbit couldn’t jump over a stone which have been stepped by itself. In other words, if the Tom had stood on the second stone, it cannot jump from the first stone to the third stone or from the n-the stone to the 4-th stone.Please note that during the whole process, it was OK for the two rabbits to stand on a same stone at the same time.Now they want to find out the maximum turns they can play if they follow the optimal strategy. 输入格式The input contains at most $20$ test cases.For each test cases, the first line contains a integer $n$ denoting the number of stones.The next line contains $n$ integers separated by space, and the i-th integer $a_i$ denotes the weight of the i-th stone.$(1 \le n \le 1000, 1 \le a_i \le 1000)$The input ends with $n = 0$. 输出格式For each test case, print a integer denoting the maximum turns. 样本12345671141 1 2 162 1 1 2 1 30 123145 提示For the second case, the path of the Tom is $1, 2, 3, 4$, and the path of Jerry is $1, 4, 3, 2$.For the third case, the path of Tom is $1,2,3,4,5$ and the path of Jerry is $4,3,2,1,5$. 思路一两个人一个顺时针蹦，一个逆时针蹦。不能超过一圈。每次蹦到的数字都得相同。为了保证最大跳数，二人走的路径是重合的。不难证明，如果假设二人走的路不重合，那么就会发现一条新的路径，比原来的路径更长，并且这条路径是重合的。所以二人走的路径是重合的。因为二人走的路径是重合的。并且二人是按照相反方向跳的。所以这条路径是回文的。这道题转化为，在一个长度是n的环形序列上，找一个不连续的回文序列的最大长度。我们先说一种常用的思路，倍增。将序列拷贝一份到后面。变成2n的序列。然后区间DP。dp[a][b]是区间[a,b]内的最长回文子串的长度。dp[a][b]的最长回文子串的长度是从dp[a+1][b],dp[a][b-1]中的最大值。如果num[a]和num[b]相等，那么前面得到的最大值还需要与dp[a+1][b-1]+2比较一下，dp[a][b]取最大值。最后的结果是，以0到n-1开头且长度为n的最长回文子序列中，找最大值。找的过程中需要注意一点，就是如果最开始两个兔子不在同一点出发，那么长度就是dp[i][i+n-1]。如果从同一点出发，长度就是dp[i][i+n-2]+1。所以要考虑到从同一点出发，和不同点出发两种情况，找出最大值。解释一下代码，20行是对不同的区间长度进行迭代，21行是对区间起始节点进行迭代。33行是对所有的起始节点迭代，然后长度锁定在n-1，34行是从不同节点出发的情况，35行是从同一个节点出发的情况。 代码一12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;int n;int num[2005];int dp[2005][2005];int main()&#123; while(~scanf("%d", &amp;n))&#123; if(!n) break; for(int i = 0; i &lt; n; i++)&#123; scanf("%d", &amp;num[i]); num[i+n] = num[i]; &#125; memset(dp, 0, sizeof dp); for(int i = 0; i &lt; 2*n; i++)&#123; for(int j = 0; j &lt; 2*n-i; j++)&#123; if(i == 0) dp[j][j+i] = 1; else&#123; dp[j][j+i] = max(dp[j+1][j+i], dp[j][j+i-1]); if(num[j] == num[j+i])&#123; dp[j][j+i] = max(dp[j][j+i], dp[j+1][j+i-1]+2); &#125; &#125; &#125; &#125; int res = 0; for(int i = 0; i &lt; n; i++)&#123; res = max(res, dp[i][i+n-1]); res = max(res, dp[i][i+n-2]+1); &#125; printf("%d\n", res); &#125; return 0;&#125; 思路二题目就是在长度为n的环上，求一个最长的回文子序列的长度。题目是如何转为为这个问题的，请见思路一。这个思路主要是划分区间。即，把序列划分成2段。分别求两段的最长回文子序列。这两段回文子序列能够组成一个大的回文子序列。1…2…2…1 | 3…4…4…3…假设前段的最长回文子序列是1221，后段的最长回文子序列是3443。组成的大的回文子序列是43122134。这就是两个兔子跳的路径结果就是在n-1个不同划分中，两段最长回文子序列的长度和中，找最大值。dp[a][b]是区间[a,b]内的最长回文子串的长度。注意状态转移。dp[a][b]的最长回文子串的长度是从dp[a+1][b],dp[a][b-1]中的最大值。如果num[a]和num[b]相等，那么前面得到的最大值还需要与dp[a+1][b-1]+2比较一下，dp[a][b]取最大值。这种结果中已经考虑到了两个兔子从不同出发点出发，相同出发点出发。考虑某个回文串长度是奇数。12321 | 4554，路径可以是541232145，两个回文串都是奇数长度，12321 | 454，路径可以使54123214。这个就是从同一点出发的情况。为什么划分成两段，而不是三段，因为三段没法组成大的回文子序列。解释一下代码，19行是对不同的区间长度进行迭代，20行是对区间起始节点进行迭代，32行是对不同的划分点进行迭代。 代码二1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;int n;int num[1005];int dp[1005][1005];int main()&#123; while(~scanf("%d", &amp;n))&#123; if(!n) break; for(int i = 0; i &lt; n; i++)&#123; scanf("%d", &amp;num[i]); &#125; memset(dp, 0, sizeof dp); for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; n-i; j++)&#123; if(i == 0) dp[j][j+i] = 1; else&#123; dp[j][j+i] = max(dp[j+1][j+i], dp[j][j+i-1]); if(num[j] == num[j+i])&#123; dp[j][j+i] = max(dp[j][j+i], dp[j+1][j+i-1]+2); &#125; &#125; &#125; &#125; int res = 1; for(int i = 0; i &lt; n-1; i++)&#123; res = max(res, dp[0][i] + dp[i+1][n-1]); &#125; printf("%d\n", res); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DP</tag>
        <tag>HDU</tag>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM HDU 4632 题解 区间DP]]></title>
    <url>%2F2018%2F06%2F10%2Facm-hdu-4632-dp-on-segment%2F</url>
    <content type="text"><![CDATA[Palindrome subsequence，区间DP。dp[i][j]表示的是i,j区间的回文子序列的个数。注意状态转移。详见本文具体内容 题目Palindrome subsequence 限制Time Limit: 2000/1000 MS (Java/Others)Memory Limit: 131072/65535 K (Java/Others) 描述In mathematics, a subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements. For example, the sequence &lt;A, B, D&gt; is a subsequence of &lt;A, B, C, D, E, F&gt;.(http://en.wikipedia.org/wiki/Subsequence)Given a string $S$, your task is to find out how many different subsequence of $S$ is palindrome. Note that for any two subsequence $X = &lt;S_{x_1}, S_{x_2}, …, S_{x_k}&gt;$ and $Y = &lt;S_{y_1}, S_{y_2}, …, S_{y_k}&gt;$ , if there exist an integer $i$ $(1 \le i \le k)$ such that $x_i \ne y_i$, the subsequence $X$ and $Y$ should be consider different even if $S_{x_i} = S_{y_i}$. Also two subsequences with different length should be considered different. 输入格式The first line contains only one integer $T$ $(T \le 50)$, which is the number of test cases. Each test case contains a string $S$, the length of $S$ is not greater than $1000$ and only contains lowercase letters. 输出格式For each test case, output the case number first, then output the number of different subsequence of the given string, the answer should be module $10007$. 样本123454aaaaaagoodafternooneveryonewelcometoooxxourproblems 1234Case 1: 1Case 2: 31Case 3: 421Case 4: 960 思路区间DP。dp[i][j]表示的是i,j区间的回文子序列的个数。注意状态转移。在计算j-i+1长度的区间时，比j-i+1长度小的区间都已经计算过了。因此dp[i][j] = dp[i][j-1] + dp[i+1][j] - dp[i+1][j-1]。如果str[i]==str[j]，那么，dp[i][j]就还需要加上dp[i+1][j-1]+1。19行是对区间长度进行循环。20行是对每个长度的所有区间进行循环。 代码12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;#define mod 10007int t;char str[1005];int dp[1005][1005];int main()&#123; scanf("%d\n", &amp;t); for(int w = 0; w &lt; t; w++)&#123; scanf("%s", str); memset(dp, 0, sizeof dp); int n = strlen(str); for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; n-i; j++)&#123; if(i == 0) dp[j][j+i] = 1; else&#123; dp[j][j+i] = (dp[j][j+i-1]+dp[j+1][j+i])%mod; if(str[j] != str[j+i])&#123; dp[j][j+i] -= dp[j+1][j+i-1]; &#125; else&#123; dp[j][j+i] += 1; &#125; dp[j][j+i] = (dp[j][j+i]+mod)%mod; &#125; &#125; &#125; printf("Case %d: %d\n", w+1, dp[0][n-1]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DP</tag>
        <tag>HDU</tag>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM POJ 2342 题解 树形DP]]></title>
    <url>%2F2018%2F06%2F10%2Facm-poj-2342-dp-on-tree%2F</url>
    <content type="text"><![CDATA[Anniversary party，树形DP。就是在树上做DP。详见本文具体内容 题目Anniversary party 限制Time Limit: 1000MSMemory Limit: 65536K 描述There is going to be a party to celebrate the 80-th Anniversary of the Ural State University. The University has a hierarchical structure of employees. It means that the supervisor relation forms a tree rooted at the rector V. E. Tretyakov. In order to make the party funny for every one, the rector does not want both an employee and his or her immediate supervisor to be present. The personnel office has evaluated conviviality of each employee, so everyone has some number (rating) attached to him or her. Your task is to make a list of guests with the maximal possible sum of guests’ conviviality ratings. 输入格式Employees are numbered from $1$ to $N$. A first line of input contains a number $N$. $1 \le N \le 6000$. Each of the subsequent $N$ lines contains the conviviality rating of the corresponding employee. Conviviality rating is an integer number in a range from $-128$ to $127$. After that go $N – 1$ lines that describe a supervisor relation tree. Each line of the tree specification has the form:L KIt means that the K-th employee is an immediate supervisor of the L-th employee. Input is ended with the line0 0 输出格式Output should contain the maximal sum of guests’ ratings. 样本123456789101112131415711111111 32 36 47 44 53 50 0 15 思路树形DP。就是在树上做DP。dp[i][0]代表以i节点为根的子树，在不取i节点的情况下，能够得到的最大的欢乐值。dp[i][1]代表以i节点为根的子树，在取i节点的情况下，能够得到的最大的欢乐值。最后输出根节点的dp[root][0]和dp[root][1]的最大值。以哪个节点开始遍历树，哪个节点就是根节点。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;using namespace std;int n, l, k;int val[6005];vector&lt;int&gt; tr[6005];int dp[6005][2];void dfs(int idx, int fa)&#123; dp[idx][0] = 0; dp[idx][1] = val[idx]; if(tr[idx].size() == 1 &amp;&amp; fa != 0) return; for(int i = 0; i &lt; tr[idx].size(); i++)&#123; if(tr[idx][i] == fa) continue; dfs(tr[idx][i], idx); &#125; for(int i = 0; i &lt; tr[idx].size(); i++)&#123; if(tr[idx][i] == fa) continue; dp[idx][0] += max(dp[tr[idx][i]][0], dp[tr[idx][i]][1]); dp[idx][1] += dp[tr[idx][i]][0]; &#125;&#125;int main()&#123; while(~scanf("%d", &amp;n))&#123; for(int i = 1; i &lt;= n; i++) tr[i].clear(); memset(dp, 0, sizeof dp); for(int i = 1; i &lt;= n; i++)&#123; scanf("%d", &amp;val[i]); &#125; while(scanf("%d %d", &amp;l, &amp;k))&#123; if(l == 0 &amp;&amp; k == 0) break; tr[l].push_back(k); tr[k].push_back(l); &#125; dfs(1, 0); printf("%d\n", max(dp[1][0], dp[1][1])); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DP</tag>
        <tag>POJ</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM CodeForces 963 B 题解 DFS]]></title>
    <url>%2F2018%2F06%2F09%2Facm-cf-963b-dfs%2F</url>
    <content type="text"><![CDATA[Destruction of a Tree，dfs的题，具体看本文，有详细的解释。 题目B. Destruction of a Tree 限制time limit per test: 1 secondmemory limit per test: 256 megabytesinput: standard inputoutput: standard output 描述You are given a tree (a graph with $n$ vertices and $n-1$ edges in which it’s possible to reach any vertex from any other vertex using only its edges).A vertex can be destroyed if this vertex has even degree. If you destroy a vertex, all edges connected to it are also deleted.Destroy all vertices in the given tree or determine that it is impossible. 输入格式The first line contains integer $n$ $(1 \le n \le 2 \cdot 10^5)$ — number of vertices in a tree.The second line contains $n$ integers $p_1,p_2,…,p_n$ $(0 \le p_i \le n)$. If $p_i \ne 0$ there is an edge between vertices $i$ and $p_i$. It is guaranteed that the given graph is a tree. 输出格式If it’s possible to destroy all vertices, print “YES” (without quotes), otherwise print “NO” (without quotes).If it’s possible to destroy all vertices, in the next $n$ lines print the indices of the vertices in order you destroy them. If there are multiple correct answers, print any. 样本1250 1 2 1 2 123456YES12354 1240 1 2 3 1NO 提示In the first example at first you have to remove the vertex with index $1$ (after that, the edges $(1, 2)$ and $(1, 4)$ are removed), then the vertex with index $2$ (and edges $(2, 3)$ and $(2, 5)$ are removed). After that there are no edges in the tree, so you can remove remaining vertices in any order. 思路首先我们可以知道，n为偶数的情况下，一定是NO，因为n为偶数，总共有奇数条边，每次消除偶数条边，最后一定剩奇数，所以是NO。所以我们只需考虑n是奇数情况。我们发现叶子结点的度一定是奇数，所以要想消除叶子节点，我们需要消除叶子节点的父亲。先消除靠近叶子节点的偶数度点，再往根节点的方向靠近，按此方法能够找到可行解。我们消除某个节点的所有偶数度的子节点，剩下奇数度子节点要想消除，必须消除该节点。如果此时该节点的度是偶，那么可以消除，如果是奇数，还要消除该节点的父节点之后，才能消除该节点。这是一个递归的思路。用dfs。我们用dfs遍历一棵树，遍历过程中用一个栈stk来保存节点之间的约束情况（某个节点的所有偶数度子节点消除之后，才可以消除当前节点，然后消除所有奇数度子节点。消除当前节点时，如果度为偶数，那么直接消除，否则就要等其父节点消除之后才可消除）。这个栈其实保存了消除过程中的拓扑序。比如上图，有21个节点。dfs过程如下，下面的序列显示的是栈stk的情况，左侧为栈底:栈：1,2,5,12,13,14,55节点的所有偶度子节点都已经消除了，剩下的奇度子节点都在栈里。5节点再次入栈是因为保证拓扑序列正确。也就是说除了叶子结点之外的节点都需要，在其子节点遍历完毕之后，二次进栈。为了消除12,13,14这几个节点，需要消除5节点，看5节点此时有偶数度。5节点是偶数度。可以消除5，所以5的所有奇度子节点也可以消除了。所以栈中两个5之间的都能输出了。输出顺序5,14,13,12。栈：1,2然后继续栈：1,2,6,15,16,17,6同理，输出6,17,16,15栈：1,2,7,18,19,7发现节点7没法消除，那么就留在栈里。栈：1,2,7,18,19,7,8,20,21,8,2发现节点8没法消除，节点2也没法消除。栈：1,2,7,18,19,7,8,20,21,8,2,3,9,3发现3,4可以消除，输出3,9栈：1,2,7,18,19,7,8,20,21,8,2,4,10,11,4,1发现4也没法消除，最后到1遍历结束。然后最后1能消除了。所以按照出栈顺序继续输出。1,4,11,10,2,8,21,20,7,19,18这就是结果了。5,14,13,12,6,17,16,15,3,9,1,4,11,10,2,8,21,20,7,19,18思路大概就是这样需要注意的是最后栈里面的要都输出来。然后注意16行要fa！=0。否则的话对于下图这种根节点只有一个孩子的会误判为叶子结点。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;int n, num;int stk[400005];int cur;int cnt[200005];vector&lt;int&gt; tr[200005];void dfs(int idx, int fa)&#123; stk[cur++] = idx; if(tr[idx].size() == 1 &amp;&amp; fa != 0) return; for(int i = 0; i &lt; tr[idx].size(); i++)&#123; if(tr[idx][i] == fa) continue; dfs(tr[idx][i], idx); &#125; stk[cur++] = idx; if(cnt[idx] % 2 == 0)&#123; printf("%d\n", idx); cnt[idx] = -1; cnt[fa]--; cur--; while(cur &amp;&amp; stk[cur-1] != idx)&#123; if(cnt[stk[cur-1]] != -1)&#123; printf("%d\n", stk[cur-1]); cnt[stk[cur-1]] = -1; &#125; cur--; &#125; cur--; &#125;&#125;int main()&#123; while(~scanf("%d", &amp;n))&#123; for(int i = 1; i &lt;= n; i++) tr[i].clear(); memset(cnt, 0, sizeof cnt); cur = 0; for(int i = 1; i &lt;= n; i++)&#123; scanf("%d", &amp;num); if(num != 0)&#123; cnt[i]++; cnt[num]++; tr[i].push_back(num); tr[num].push_back(i); &#125; &#125; if(n%2==0)&#123; printf("NO\n"); &#125; else&#123; printf("YES\n"); dfs(1, 0); while(cur)&#123; if(cnt[stk[cur-1]] != -1)&#123; printf("%d\n", stk[cur-1]); cnt[stk[cur-1]] = -1; &#125; cur--; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>CodeForces</tag>
        <tag>搜索</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM CodeForces 877 B 题解 DP]]></title>
    <url>%2F2018%2F06%2F08%2Facm-cf-877b-dp%2F</url>
    <content type="text"><![CDATA[Nikita and string，简单DP，详见本文内容。 题目B. Nikita and string 限制time limit per test: 2 secondsmemory limit per test: 256 megabytesinput: standard inputoutput: standard output 描述One day Nikita found the string containing letters “a” and “b” only.Nikita thinks that string is beautiful if it can be cut into 3 strings (possibly empty) without changing the order of the letters, where the 1-st and the 3-rd one contain only letters “a” and the 2-nd contains only letters “b”.Nikita wants to make the string beautiful by removing some (possibly none) of its characters, but without changing their order. What is the maximum length of the string he can get? 输入格式The first line contains a non-empty string of length not greater than $5000$ containing only lowercase English letters “a” and “b”. 输出格式Print a single integer — the maximum possible size of beautiful string Nikita can get. 样本1abba 14 1bab 12 提示It the first sample the string is already beautiful.In the second sample he needs to delete one of “b” to make it beautiful. 思路动态规划。dp[i][0]是指前i个字符中，a…序列(不一定连续)的最大长度。dp[i][1]是指前i个字符中，a…b…序列(不一定连续)的最大长度。dp[i][2]是指前i个字符中，a…b…a…序列(不一定连续)的最大长度。转换过程详见代码。 代码1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;char str[5005];int dp[5005][3];int main()&#123; while(~scanf("%s", str))&#123; int len = strlen(str); memset(dp, 0, sizeof dp); for(int i = 1; i &lt;= len; i++)&#123; if(str[i-1] == 'a')&#123; dp[i][0] = dp[i-1][0]+1; dp[i][1] = dp[i-1][1]; dp[i][2] = max(dp[i-1][1]+1, dp[i-1][2]+1); &#125; else&#123; dp[i][0] = dp[i-1][0]; dp[i][1] = max(dp[i-1][0]+1, dp[i-1][1]+1); dp[i][2] = dp[i-1][2]; &#125; &#125; printf("%d\n", max(dp[len][0], max(dp[len][1], dp[len][2]))); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>CodeForces</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM CodeForces 873 B 题解 前缀和]]></title>
    <url>%2F2018%2F06%2F07%2Facm-cf-873b-simple%2F</url>
    <content type="text"><![CDATA[Balanced Substring，可以用一个前缀和的思路来做，详见本文内容。 题目B. Balanced Substring 限制time limit per test: 1 secondmemory limit per test: 256 megabytesinput: standard inputoutput: standard output 描述You are given a string $s$ consisting only of characters $0$ and $1$. A substring $[l,r]$ of $s$ is a string $s_l$$s_{l+1}$$s_{l+2}$$…$$s_r$, and its length equals to $r-l+1$. A substring is called balanced if the number of zeroes (0) equals to the number of ones in this substring.You have to determine the length of the longest balanced substring of $s$. 输入格式The first line contains $n$ $(1 \le n \le 100000)$ — the number of characters in $s$.The second line contains a string $s$ consisting of exactly $n$ characters. Only characters $0$ and $1$ can appear in $s$. 输出格式If there is no non-empty balanced substring in $s$, print $0$. Otherwise, print the length of the longest balanced substring. 样本12811010111 14 123111 10 提示In the first example you can choose the substring $[3,6]$. It is balanced, and its length is $4$. Choosing the substring $[2,5]$ is also possible.In the second example it’s impossible to find a non-empty balanced substring. 思路前缀和的思想。从头往后扫，遇到1就加一，遇到0就减一，维护数列的前缀和。一旦r的前缀和l的前缀相等，那么[l+1,r]这个区间里的0和1的数量一定相等。mark数组中0到100000存储的是前缀和为-100000到0的首次出现位置。100001到200000存储的是前缀和为1到100000的首次出现位置。mark数组首先初始化为-2，然后将mark[0]设置为-1。每次计算前缀和，一旦发现某个mark对应某个前缀和在之前出现过，即不等于-2，那么就和res作比较。否则就更新mark的值为当前下标。 代码1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;int n;char c;int num;int mark[200005];int main()&#123; while(~scanf("%d\n", &amp;n))&#123; for(int i = -1*n; i &lt;= n; i++)&#123; mark[i+100000] = -2; &#125; mark[100000] = -1; int sum = 0; int res = 0; for(int i = 0; i &lt; n; i++)&#123; scanf("%c", &amp;c); num = c-'0'; num == 0 ? sum-- : sum++; if(mark[100000+sum] != -2)&#123; res = max(i-mark[100000+sum], res); &#125; else&#123; mark[100000+sum] = i; &#125; &#125; printf("%d\n", res); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>基础题</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>CodeForces</tag>
        <tag>基础题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM CodeForces 888 B 题解 基础题]]></title>
    <url>%2F2018%2F06%2F07%2Facm-cf-888b-simple%2F</url>
    <content type="text"><![CDATA[Buggy Robot，水题，计数就行了。详见本文内容。 题目B. Buggy Robot 限制time limit per test: 2 secondsmemory limit per test: 256 megabytesinput: standard inputoutput: standard output 描述Ivan has a robot which is situated on an infinite grid. Initially the robot is standing in the starting cell $(0,0)$. The robot can process commands. There are four types of commands it can perform: U — move from the cell $(x,y)$ to $(x,y+1)$; D — move from $(x,y)$ to $(x,y-1)$; L — move from $(x,y)$ to $(x-1,y)$; R — move from $(x,y)$ to $(x+1,y)$. Ivan entered a sequence of $n$ commands, and the robot processed it. After this sequence the robot ended up in the starting cell $(0,0)$, but Ivan doubts that the sequence is such that after performing it correctly the robot ends up in the same cell. He thinks that some commands were ignored by robot. To acknowledge whether the robot is severely bugged, he needs to calculate the maximum possible number of commands that were performed correctly. Help Ivan to do the calculations! 输入格式The first line contains one number $n$ — the length of sequence of commands entered by Ivan $(1 \le n \le 100)$.The second line contains the sequence itself — a string consisting of $n$ characters. Each character can be $U$, $D$, $L$ or $R$. 输出格式Print the maximum possible number of commands from the sequence the robot could perform to end up in the starting cell. 样本124LDUR 14 125RRRUU 10 126LLRRRR 14 思路水题。算一下L、R、U、D四个字符的个数，然后为了回到原点，所以选取的L、R的个数必须相等，选取的U、D的个数也必须相等。详见代码。 代码1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int n;char c;int main()&#123; while(~scanf("%d\n", &amp;n))&#123; int cntl = 0, cntr = 0, cntu = 0, cntd = 0; for(int i = 1; i &lt;= n; i++)&#123; scanf("%c", &amp;c); if(c == 'L') cntl++; else if(c == 'R') cntr++; else if(c == 'U') cntu++; else if(c == 'D') cntd++; &#125; printf("%d\n", min(cntl, cntr)*2 + min(cntu, cntd)*2); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>基础题</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>CodeForces</tag>
        <tag>基础题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM CodeForces 891 A 题解 DP]]></title>
    <url>%2F2018%2F06%2F06%2Facm-cf-891a-dp%2F</url>
    <content type="text"><![CDATA[Pride，DP题，本题关键就是找到一段最短区间[l,r]，该区间的gcd是1。详见本文内容 题目A. Pride 限制time limit per test: 2 secondsmemory limit per test: 256 megabytesinput: standard inputoutput: standard output 描述You have an array $a$ with length $n$, you can perform operations. Each operation is like this: choose two adjacent elements from $a$, say $x$ and $y$, and replace one of them with $gcd(x,y)$, where gcd denotes the greatest common divisor.What is the minimum number of operations you need to make all of the elements equal to $1$? 输入格式The first line of the input contains one integer $n$$(1 \le n \le 2000)$ — the number of elements in the array.The second line contains $n$ space separated integers $a_1,a_2,…,a_n$ $(1 \le a_i \le 10^9)$ — the elements of the array. 输出格式Print $-1$, if it is impossible to turn all numbers to $1$. Otherwise, print the minimum number of operations needed to make all numbers equal to $1$. 样本1252 2 3 4 6 15 1242 4 6 8 1-1 1232 6 9 14 提示In the first sample you can turn all numbers to 1 using the following 5 moves: $[2,2,3,4,6]$ $[2,1,3,4,6]$ $[2,1,3,1,6]$ $[2,1,1,1,6]$ $[1,1,1,1,6]$ $[1,1,1,1,1]$ We can prove that in this case it is not possible to make all numbers one using less than 5 moves. 思路如果序列中有1的话，结果是n减去1的个数。本题关键就是找到一段最短区间[l,r]，该区间的gcd是1，结果是r-l+n-1。r-l是这个区间变出一个1的步数，n-1是变出了一个1之后，将剩余的n-1个数都变成1的步数代码中dp[i][j]存储的是区间[i,j]的gcd。dp[i][i]存储的是序列中的数。dp数组中只有右上半个数组实际被用到。第25行的i是循环的区间长度，从1到n-1。第26行的j循环的是区间的起始元素。递推公式是dp[j][j+i] = gcd(dp[j][j+i-1], dp[j+i][j+i])__gcd(a, b)是algorithm库中的函数 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int n;int dp[2005][2005];int main()&#123; while(~scanf("%d", &amp;n))&#123; memset(dp, 0, sizeof dp); int cnt = 0; for (int i = 0; i &lt; n; i++)&#123; scanf("%d", &amp;dp[i][i]); if(dp[i][i] == 1)&#123; cnt++; &#125; &#125; if(cnt &gt; 0)&#123; printf("%d\n", n-cnt); &#125; else&#123; int ans = 0; bool flag = false; for (int i = 1; i &lt; n; i++)&#123; for (int j = 0; j+i &lt; n; j++)&#123; dp[j][j+i] = __gcd(dp[j][j+i-1], dp[j+i][j+i]); if(dp[j][j+i] == 1)&#123; flag = true; ans = i; break; &#125; &#125; if(flag) break; &#125; if(flag) printf("%d\n", n-1+ans); else printf("-1\n"); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>CodeForces</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM 组合数学 母函数 生成函数 详解]]></title>
    <url>%2F2018%2F06%2F05%2Facm-generating-function-learning%2F</url>
    <content type="text"><![CDATA[每次做母函数的题都会忘记，于是我学习了一下母函数，写了一篇博客，希望自己能记住。本文有代码模版。mark一下。 介绍在组合数学中，母函数，又叫生成函数，是一种形式幂级数。每一项的系数可以提供关于这个项的信息。使用母函数解决问题的方法就是母函数法。母函数有很多种，普通母函数、指数母函数、L级数、贝尔级数、狄利克雷级数。根据一个序列不同的性质，或是需要得到的信息，要选择以上不同的母函数进行套用。母函数方法的思想就是将数列间的相加关系与幂级数间的乘幂运算对应起来。 定义序列$a_0, a_1, a_2, a_3, …$构造一个函数$G(x)=a_0+a_1x+a_2x^2+…$称$G(x)$为$a_0, a_1, a_2, a_3, …$序列的母函数 普通母函数该类母函数比较常用，可以用于解决整数拆分，组合数量问题。 一次多项式乘法母函数一次是指每一个多项式的最高次是1$\quad(1+a_1x)(1+a_2x)…(1+a_nx)$$=1+(a_1+a_2+…+a_n)x+(a_1a_2+a_1a_3+…+a_{n-1}a_n)x^2+…+a_1a_2…a_nx^n$$x$的系数是$a_1, a_2, … a_n$的$1$个组合的和$x^2$的系数是$a_1, a_2, … a_n$的$2$个组合的和…$x^n$的系数是$a_1, a_2, … a_n$的$n$个组合的和 杨辉三角母函数$\quad(1+x)^n$$=C_n^0x^0+C_n^1x^1+C_n^2x^2+…+C_n^nx^n$$=1+C_n^1x+C_n^2x^2+…+C_n^nx^n$ 高次有限项多项式乘法母函数高次指每个多项式的最高次大于1，有限项指的是每个多项式的项数是有限的比如有这样一个问题。有1元2张、5元4张、10元1张、20元3张，问可以组合出多少种面额，每种面额的组合方式数量是多少问题可以转化为如下的多项式$\quad(1\times x^{0 \times 1}+1\times x^{1 \times 1}+1\times x^{2 \times 1})(1\times x^{0 \times 5}+1\times x^{1 \times 5}+1\times x^{2 \times 5}+1\times x^{3 \times 5}+1\times x^{4 \times 5})\cdot$$\quad(1\times x^{0 \times 10}+1\times x^{1 \times 10})(1\times x^{0 \times 20}+1\times x^{1 \times 20}+1\times x^{2 \times 20}+1\times x^{3 \times 20})$$=(1+x+x^2)(1+x^5+x^{10}+x^{15}+x^{20})(1+x^{10})(1+x^{20}+x^{40}+x^{60})$一共四个多项式相乘，分别代表1元、5元、10元、20元的选择情况。用第一个多项式举例。多项式中每一项的指数代表组合情况，即$x^{0 \times 1}$代表取0个1元，系数1代表组合种数有1种$x^{1 \times 1}$代表取1个1元，系数1代表组合种数有1种$x^{2 \times 1}$代表取2个1元，系数1代表组合种数有1种因为1元有两张，所以到这里就结束了，这个多项式的项是有限项。将数列间的相加关系与幂级数间的乘幂运算对应起来在这里的体现就是：在计算这个多项式乘积的时候，x的幂相乘运算就是指数相加，而这个指数相加正好对应了数列间的加法运算。而相乘之后得到的多项式的各项系数就是组合方式数。 高次无限项多项式乘法母函数高次指每个多项式的最高次大于1，无限项指的是每个多项式的项数是无限的考虑这样一个问题，有1,2,3克砝码无限个。求某一质量的方案数。类比高次有限项多项式乘法母函数，直接写出多项式乘积：$(1+x+x^2+x^3+…)(1+x^2+x^4+x^6+…)(1+x^3+x^6+x^9+…)$计算这个多项式的和，质量为$n$的方案数就是$x^n$的系数考虑这样一个题，有120个数，每个数的个数不限。求组成某个数的方案数。$4=3+1$与$4=1+3$属于同一种方案给出模版代码123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int n;int num1[125];int num2[125];int main()&#123; memset(num1, 0, sizeof num1); memset(num2, 0, sizeof num2); for(int i = 0; i &lt; 125; i++)&#123; num1[i] = 1; &#125; for(int i = 2; i &lt;= 120; i++)&#123; for(int j = 0; j &lt;= 120; j++)&#123; for (int k = 0; k+j &lt;= 120; k += i)&#123; num2[k+j] += num1[j]; &#125; &#125; for(int j = 0; j &lt;= 120; j++)&#123; num1[j] = num2[j]; num2[j] = 0; &#125; &#125; while(~scanf("%d", &amp;n))&#123; printf("%d\n", num1[n]); &#125;&#125; 解释一下代码，这个代码其实就是在模拟多项式乘法的过程。$(1+x^1+x^2+…+x^{120})(1+x^2+x^4+x^6+…+x^{120})…(1+x^{120})$一共120个多项式相乘。 num1在每轮循环结束后存储的都是第一个多项式的系数。num2是一个中转数组，用来暂存过程中的新的多项式的系数。每次循环结束，num2中的值都要倒换到num1中。 第13-15行就是第一轮，是$(1+x^1+x^2+…+x^{120})$多项式的各项系数。这是初始化num1，num2数组第16行是对120个多项式进行循环。每轮乘一个多项式进去。第i轮乘的是各项系数是i的倍数的多项式。也就是说第2轮乘的是$(1+x^2+x^4+…)$，第三轮乘的是$(1+x^3+x^6+…)$，第i轮乘的是$(1+x^i+x^{2i}+…)$。第i轮结束后，num1中的系数是前i个多项式的乘积多项式的系数。即$(1+x^1+x^2+…)(1+x^2+x^4+…)…(1+x^i+x^{2i}+…)$的结果的系数第17行的j是对第i-1轮得到的乘积多项式的各项进行循环。即，$(1+x^1+x^2+…)(1+x^2+x^4+…)…(1+x^{i-1}+x^{2i-2}+…)$的结果中的各项第18行的k是对第i个多项式，即$(1+x^i+x^{2i}+…)$的各项进行循环。将这个多项式和前i-1个多项式的乘积相乘，得到前i个多项式的乘积。k的增量是i第19行，num2存的是相乘运算的过程中的中间结果系数，num1存的是前i-1个多项式的乘积的系数。因为第i个多项式中的每项的系数都是1，所以num2[k+j]直接加了num1[j]，其实是1*num1[j]。第22-24行，就是将num2的结果跟num1的结果倒腾一下。注意，有的题，可能要求比如，某个值最少用多少，最多用多少这种情况。这个时候，就是k不从0开始了，并且k+=i的次数有限制。需要灵活变通]]></content>
      <categories>
        <category>数学</category>
        <category>组合数学</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>数学</tag>
        <tag>组合数学</tag>
        <tag>母函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM HDU 1028 题解 母函数 生成函数]]></title>
    <url>%2F2018%2F06%2F05%2Facm-hdu-1028-generating-function%2F</url>
    <content type="text"><![CDATA[Ignatius and the Princess III，普通母函数题，也叫生成函数。整数拆分。打表做。详见本文具体内容 题目Ignatius and the Princess III 限制Time Limit: 2000/1000 MS (Java/Others)Memory Limit: 65536/32768 K (Java/Others) 描述“Well, it seems the first problem is too easy. I will let you know how foolish you are later.” feng5166 says.“The second problem is, given an positive integer $N$, we define an equation like this:$N=a[1]+a[2]+a[3]+…+a[m];$$a[i]&gt;0,$$1&lt;=m&lt;=N;$My question is how many different equations you can find for a given $N$.For example, assume $N$ is $4$, we can find:$4 = 4;$$4 = 3 + 1;$$4 = 2 + 2;$$4 = 2 + 1 + 1;$$4 = 1 + 1 + 1 + 1;$so the result is $5$ when $N$ is $4$. Note that “$4 = 3 + 1$” and “$4 = 1 + 3$” is the same in this problem. Now, you do it!” 输入格式The input contains several test cases. Each test case contains a positive integer $N$$(1 \le N \le 120)$ which is mentioned above. The input is terminated by the end of file. 输出格式For each test case, you have to output a line contains an integer $P$ which indicate the different equations you have found. 样本12341020 123542627 思路普通母函数题，也叫生成函数。整数拆分。打表做。先打出0到120的表。然后直接输出。应用到的母函数公式$$G(x)=(1+x+x^2+…)(1+x^2+x^4+…)(1+x^3+x^6+…)…(1+x^n+x^{2n}+…)$$母函数公式如何套用，详见本人博客母函数详解 代码123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int n;int num1[125];int num2[125];int main()&#123; memset(num1, 0, sizeof num1); memset(num2, 0, sizeof num2); for(int i = 0; i &lt; 125; i++)&#123; num1[i] = 1; &#125; for(int i = 2; i &lt;= 120; i++)&#123; for(int j = 0; j &lt;= 120; j++)&#123; for (int k = 0; k+j &lt;= 120; k += i)&#123; num2[k+j] += num1[j]; &#125; &#125; for(int j = 0; j &lt;= 120; j++)&#123; num1[j] = num2[j]; num2[j] = 0; &#125; &#125; while(~scanf("%d", &amp;n))&#123; printf("%d\n", num1[n]); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>组合数学</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>组合数学</tag>
        <tag>母函数</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM HDU 2844 题解 多重背包]]></title>
    <url>%2F2018%2F06%2F05%2Facm-hdu-2844-dp%2F</url>
    <content type="text"><![CDATA[Coins，多重背包问题。如果某个硬币的面额乘数量大于m，那么就是完全背包；否则就是01背包。详见本文具体内容 题目Coins 限制Time Limit: 2000/1000 MS (Java/Others)Memory Limit: 32768/32768 K (Java/Others) 描述Whuacmers use coins. They have coins of value $A_1,A_2,A_3…A_n$ Silverland dollar. One day Hibix opened purse and found there were some coins. He decided to buy a very nice watch in a nearby shop. He wanted to pay the exact price(without change) and he known the price would not more than $m$.But he didn’t know the exact price of the watch.You are to write a program which reads $n,m,A_1,A_2,A_3…A_n$ and $C_1,C_2,C_3…C_n$ corresponding to the number of Tony’s coins of value $A_1,A_2,A_3…A_n$ then calculate how many prices(form $1$ to $m$) Tony can pay use these coins. 输入格式The input contains several test cases. The first line of each test case contains two integers $n$$(1 \le n \le 100),$ $m$$(m \le 100000)$. The second line contains $2n$ integers, denoting $A_1,A_2,A_3…A_n,$ $C_1,C_2,C_3…C_n$ $(1 \le Ai \le 100000,$ $1 \le Ci \le 1000)$. The last test case is followed by two zeros. 输出格式For each test case output the answer on a single line. 样本123453 101 2 4 2 1 12 51 4 2 10 0 1284 思路多重背包问题。如果某个硬币的面额乘数量大于m，那么就是完全背包；否则就是01背包。注意不能全按照01背包处理，会超时。拆01背包时候按照类似2分的样子拆。这样能够保证拆出来之后增加的物品数量最小。代码中m是背包容量。v数组是存储的面额，c数组存储的是数量，函数参数中的c是花费，v是价值。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int n, m;int v[105];int c[105];int dp[100005];void init(int m)&#123; for(int i = 1; i &lt;= m; i++)&#123; dp[i] = -1000000000; &#125; dp[0] = 0;&#125;void completepack(int m, int c, int v)&#123; for(int i = c; i &lt;= m; i++)&#123; dp[i] = max(dp[i], dp[i-c]+v); &#125;&#125;void O1pack(int m, int c, int v)&#123; for(int i = m; i &gt;= c; i--)&#123; dp[i] = max(dp[i], dp[i-c]+v); &#125;&#125;void multiplepack(int m, int c, int v, int num)&#123; if(c*num &gt;= m)&#123; completepack(m, c, v); return ; &#125; for(int i = 1; i &lt;= num; i*=2)&#123; O1pack(m, c*i, v*i); num -= i; &#125; if(num)&#123; O1pack(m, c*num, v*num); &#125;&#125;int main()&#123; while(~scanf("%d%d", &amp;n, &amp;m))&#123; if(n == 0 &amp;&amp; m == 0) break; for(int i = 0; i &lt; n; i++)&#123; scanf("%d", &amp;v[i]); &#125; for(int i = 0; i &lt; n; i++)&#123; scanf("%d", &amp;c[i]); &#125; init(m); if(m &gt; 0)&#123; for(int i = 0; i &lt; n; i++)&#123; multiplepack(m, v[i], 1, c[i]); &#125; &#125; int ret = 0; for(int i = 1; i &lt;= m; i++)&#123; if(dp[i] &gt; 0)&#123; ret++; &#125; &#125; printf("%d\n", ret); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DP</tag>
        <tag>HDU</tag>
        <tag>背包问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM CodeForces 910 A 题解 DP]]></title>
    <url>%2F2018%2F05%2F26%2Facm-cf-910a-dp%2F</url>
    <content type="text"><![CDATA[The Way to Home，一个不怎么明显的dp题。详见本文内容 题目A. The Way to Home 限制time limit per test: 1 secondmemory limit per test: 256 megabytesinput: standard inputoutput: standard output 描述outputstandard outputA frog lives on the axis $Ox$ and needs to reach home which is in the point $n$. She starts from the point $1$. The frog can jump to the right at a distance not more than $d$. So, after she jumped from the point $x$ she can reach the point $x+a$, where $a$ is an integer from $1$ to $d$.For each point from $1$ to $n$ is known if there is a lily flower in it. The frog can jump only in points with a lilies. Guaranteed that there are lilies in the points $1$ and $n$.Determine the minimal number of jumps that the frog needs to reach home which is in the point $n$ from the point $1$. Consider that initially the frog is in the point $1$. If the frog can not reach home, print $-1$. 输入格式The first line contains two integers $n$ and $d$ $(2 \le n \le 100, 1 \le d \le n-1)$ — the point, which the frog wants to reach, and the maximal length of the frog jump.The second line contains a string $s$ of length $n$, consisting of zeros and ones. If a character of the string s equals to zero, then in the corresponding point there is no lily flower. In the other case, in the corresponding point there is a lily flower. Guaranteed that the first and the last characters of the string $s$ equal to one. 输出格式If the frog can not reach the home, print $-1$.In the other case, print the minimal number of jumps that the frog needs to reach the home which is in the point $n$ from the point $1$. 样本128 410010101 12 124 21001 1-1 128 411100101 13 1212 3101111100101 14 提示In the first example the from can reach home in two jumps: the first jump from the point $1$ to the point $4$ (the length of the jump is three), and the second jump from the point $4$ to the point $8$ (the length of the jump is four).In the second example the frog can not reach home, because to make it she need to jump on a distance three, but the maximum length of her jump equals to two. 思路一个不怎么明显的dp题。遍历字符串s，如果是1那么就考虑如下，假设当前是i位置，那么i位置的最小跳数是，从i-d到i-1这个区间内跳数的最小值，再加一。所以关键就是怎么取得最小值。用优先队列，封装一个node，idx代表某个位置的下标，num代表这个位置的最小跳数，这个node的operator函数是将q队列弄成了以num排序的小顶堆。遍历字符串的时候，如果是1，那么就先看堆顶的idx是否在i-d和i-1之间，如果不在，那么就pop，直到队列为空或者找到一个在区间内的为止。队列为空，就直接是-1，如果找到了，那么就说明i位置能够到达，然后就更新i位置，将i位置的node加入堆中。 代码1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;int n, d;char str[105];struct node&#123; int idx, num; bool operator &lt; (const node&amp; no) const&#123; return num &gt; no.num; &#125;&#125;;int main()&#123; while(~scanf("%d %d", &amp;n, &amp;d))&#123; scanf("%s", str); priority_queue&lt;node&gt; q; q.push((node)&#123;0, 0&#125;); for (int i = 0; i &lt; n; i++)&#123; if(str[i] == '1')&#123; while(!q.empty() &amp;&amp; q.top().idx + d &lt; i)&#123; q.pop(); &#125; if(q.empty())&#123; printf("-1\n"); break; &#125; node no = q.top(); if(i == n-1)&#123; printf("%d\n", no.num+1); break; &#125; q.push((node)&#123;i, no.num + 1&#125;); &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>CodeForces</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows10 PC 无法进入选择启动项界面 无法进入BIOS界面]]></title>
    <url>%2F2018%2F05%2F23%2Fwindows-pc-cannot-select-boot-device%2F</url>
    <content type="text"><![CDATA[windows10关机后，在重启电脑的瞬间，狂按F2，无法进入对应的BIOS，狂按F12，无法进入选择启动项界面。这是windows10的快速启动的特性。本文讲关闭快速启动的方法。 症状想要安装双系统，或是干什么事情的时候，需要选择启动项，但是发现怎么按F12或者其他对应的按键，都不能进入选择启动项的界面，当然BIOS界面也是进不去。 原因Windows10有快速启动这一个功能，就是为了让每次开机更快，它并没有彻底关机，而是做了一些小操作，像是休眠，给你一种关机的假象。 标准解决方法当然是关掉快速启动功能了。如何关闭呢？打开控制面板点击系统和安全点击电源选项下的更改电源按钮的功能先点击上边的更改当前不可用的设置，然后取消勾选启用快速启动，最后保存更改就OK了 暴力解决方法其实还有一种解决方法，但是只能当次适用。就是强制关机，强制关机后的第一次启动电脑可以进入选择启动项界面，之后就不行了。 注有的电脑尽管勾选了快速启动，还是能够正常的进入选择启动项界面，BIOS界面。比如工作站之类的。这些电脑就比较强大了。]]></content>
      <categories>
        <category>系统安装</category>
      </categories>
      <tags>
        <tag>系统安装</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM CodeForces 933 A 题解 DP]]></title>
    <url>%2F2018%2F05%2F23%2Facm-cf-933a-dp%2F</url>
    <content type="text"><![CDATA[A Twisty Movement，用dp。注意别读错题。reverse这个词，不是将某一个区间的值1变2,2变1，而是翻转这个区间。详见本文具体内容。 题目A. A Twisty Movement 限制time limit per test: 1 secondmemory limit per test: 256 megabytesinput: standard inputoutput: standard output 描述A dragon symbolizes wisdom, power and wealth. On Lunar New Year’s Day, people model a dragon with bamboo strips and clothes, raise them with rods, and hold the rods high and low to resemble a flying dragon.A performer holding the rod low is represented by a $1$, while one holding it high is represented by a $2$. Thus, the line of performers can be represented by a sequence $a_1, a_2, …, a_n$.Little Tommy is among them. He would like to choose an interval $[l, r] (1 \le l \le r \le n)$, then reverse $a_l, a_{l+1}, …, a_r$ so that the length of the longest non-decreasing subsequence of the new sequence is maximum.A non-decreasing subsequence is a sequence of indices $p_1, p_2, …, p_k$, such that $p_1 &lt; p_2 &lt; … &lt; p_k$ and $a_{p1} \le a_{p2} \le … \le a_{pk}$. The length of the subsequence is $k$. 输入格式The first line contains an integer $n (1 \le n \le 2000)$, denoting the length of the original sequence.The second line contains n space-separated integers, describing the original sequence $a_1, a_2, …, a_n$ $(1 \le a_i \le 2, i = 1, 2, …, n)$. 输出格式Print a single integer, which means the maximum possible length of the longest non-decreasing subsequence of the new sequence. 样本1241 2 1 2 14 12101 1 2 2 2 1 1 2 2 1 19 提示In the first example, after reversing $[2, 3]$, the array will become $[1, 1, 2, 2]$, where the length of the longest non-decreasing subsequence is 4.In the second example, after reversing $[3, 7]$, the array will become $[1, 1, 1, 1, 2, 2, 2, 2, 2, 1$], where the length of the longest non-decreasing subsequence is 9. 思路最开始读错题了，还错误理解了两个位置。首先是子序列，即不要求连续。第二是reverse这个词，不是将某一个区间的值1变2,2变1，而是翻转这个区间，即1,2,1,1变成1,1,2,1。用dp。考虑四种情况。1…的子序列，1…2…的子序列，1…2…1…的子序列，1…2…1…2…的子序列。因为可以用reverse，所以让1…2…1…2…这种子序列最长就好了。dp[0][i]代表前i个字符内1…的子序列最长的长度是多少。dp[1][i]代表前i个字符内1…2…的子序列的最长的长度是多少。dp[2][i]代表前i个字符内1…2…1…的子序列的最长的长度是多少。dp[3][i]代表前i个字符内1…2…1…2…的子序列的最长的长度是多少。注意最后输出dp[0][n-1]到dp[3][n-1]中最大值。因为序列中不一定会有满足1…2…1…2…的子序列，比如”111”, “222”, “12”, “21”, “212”这种。可以用滚动数组，代码中没用滚动数组。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int n;int num[2010];int dp[4][2010];int main()&#123; while(~scanf("%d", &amp;n))&#123; memset(dp, 0, sizeof dp); for(int i = 0; i &lt; n; i++)&#123; scanf("%d", &amp;num[i]); &#125; for (int i = 0; i &lt; n; i++)&#123; if(i == 0)&#123; if(num[i] == 1)&#123; dp[0][i] = 1; &#125; else&#123; dp[1][i] = 1; &#125; continue; &#125; if(num[i] == 1)&#123; dp[0][i] = dp[0][i-1] + 1; dp[1][i] = dp[1][i-1]; dp[2][i] = max(dp[2][i-1] + 1, dp[1][i-1] + 1); dp[3][i] = dp[3][i-1]; &#125; else&#123; dp[0][i] = dp[0][i-1]; dp[1][i] = max(dp[0][i-1] + 1, dp[1][i-1] + 1); dp[2][i] = dp[2][i-1]; dp[3][i] = max(dp[2][i-1] + 1, dp[3][i-1] + 1); &#125; &#125; int res = 0; for(int i = 0; i &lt; 4; i++)&#123; if(res &lt; dp[i][n-1]) res = dp[i][n-1]; &#125; printf("%d\n", res); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>CodeForces</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 中 Markdown 与 MathJax 冲突解决]]></title>
    <url>%2F2018%2F05%2F22%2Fmarkdown-mathjax-syntax-collision%2F</url>
    <content type="text"><![CDATA[Hexo博客中会遇到mathjax公式渲染出现问题的情况，原来是markdown和mathjax的渲染出现冲突，本文解决冲突。 症状在网上找到的MathJax的公式，直接粘贴到Markdown文档中发现，显示格式不正确。比如：1234mathjax的大括号$$\&#123;x\&#125;$$mathjax的换行符$$f(b) = \begin&#123;cases&#125; b[1] \\ b[2] \end&#123;cases&#125;$$ 在hexo中的实际效果为$${x}$$$$f(b) = \begin{cases} b[1] \ b[2] \end{cases}$$我的大括号呢？说好的换行符呢？怎么不显示了？ 分析在hexo生成中，markdown会将文档先一步渲染，将某些字符转义，之后再是MathJax的渲染。在这个过程中会有冲突。对于大括号，markdown渲染器会将\{或是\}转义为{或是}，再等到MathJax渲染的时候当然就不对了。因为\没了啊。对于换行符，markdown渲染器会将\\转义为\，再到MathJax渲染的时候发现就剩一个了，所以就不换行了。 解决方法网上的一些解决方式都是修改mark.js中的正则表达式，来限制markdown的转义。或是npm安装一些东西来控制这些。有点粗暴。遇到类似的情况，发现是markdown先转义了，我的解决方法是，允许markdown转义，但要保证轮到MathJax转义的时候表达式是正确的。1234mathjax的大括号$$\\&#123;x\\&#125;$$mathjax的换行符$$f(b) = \begin&#123;cases&#125; b[1] \\\\ b[2] \end&#123;cases&#125;$$ 改成上边这样，结果实际效果就正确了。$$\{x\}$$$$f(b) = \begin{cases} b[1] \\ b[2] \end{cases}$$]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Markdown</tag>
        <tag>MathJax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MathJax 基本语法学习笔记]]></title>
    <url>%2F2018%2F05%2F22%2Fmathjax-learning-note%2F</url>
    <content type="text"><![CDATA[博客中遇到复杂的数学公式怎么办？来学习一波MathJax的语法，遇到难写的数学公式不用再去查了。mark一下。 显示公式在行中显示，就用$...$单独一行显示，则用$$...$$ 上标和下标上标用^，下标用_。如果上下标符号要显示两个以上的字符，用{}括起来。 $x^2$ 表示 $x^2$$\log_2 x$ 表示 $\log_2 x$$x^{10}$ 表示 $x^{10}$ 希腊字母小写开头字母就小写，大写的话开头字母就大写，前提是该希腊字符有大写。 $\alpha, \beta, …, \omega$ 表示 $\alpha, \beta, …, \omega$$\Gamma, \Delta, …, \Omega$ 表示 $\Gamma, \Delta, …, \Omega$ 括号 小括号，$()$ 表示 $()$方括号，$[]$ 表示 $[]$花括号，$\\{\\}$ 表示 $\{\}$绝对值符号，$\vert x \vert$ 表示 $\vert x \vert$范数符号，$\Vert x \Vert$ 表示 $\Vert x \Vert$尖角符号，$\langle x \rangle$ 表示 $\langle x \rangle$向上取整符号，$\lceil \rceil$ 表示 $\lceil \rceil$向下取整符号，$\lfloor \rfloor$ 表示 $\lfloor \rfloor$ 括号默认不会随着高度伸缩，如果需要伸缩，用\left(…\right)来进行自动伸缩。\left和\right在三种括号，绝对值符号，范数符号，尖角符号，向上下取整符号中有用 不伸缩，$(\frac{\sqrt x}{y^3})$ 表示 $(\frac{\sqrt x}{y^3})$伸缩，$\left(\frac{\sqrt x}{y^3}\right)$ 表示 $\left(\frac{\sqrt x}{y^3}\right)$ 如果只需显示一半的符号，可以用.来表示另一边为空。$\left. \frac 1 2 \right \rbrace$ 表示 $\left. \frac 1 2 \right \rbrace$当然也可以手动调整括号的大小，如$\Bigl(\bigl((x)\bigr)\Bigr)$ 表示 $\Bigl(\bigl((x)\bigr)\Bigr)$ 求和与积分 求和，$\sum_1^n$ 表示 $\sum_1^n$积分，$\int_1^n$ 表示 $\int_1^n$连乘，$\prod$ 表示 $\prod$并集，$\bigcup$ 表示 $\bigcup$交集，$\bigcap$ 表示 $\bigcap$重积分，$\iint$ 表示 $\iint$ 分数 $\frac a b$ 表示 $\frac a b$${a+1 \over b+1}$ 表示 ${a+1 \over b+1}$ 根号 $\sqrt {x^3}$ 表示 $\sqrt {x^3}$$\sqrt[3] {\frac x y}$ 表示 $\sqrt[3] {\frac x y}$ 极限 $\lim_{x \to 0}$ 表示 $\lim_{x \to 0}$ 空格$a\, a\; a\quad a\qquad a$ 表示 $a\, a\; a\quad a\qquad a$加入一段文字，可用$\\{x \in s \mid x \text{ is extra large}\\}$表示 $\{x \in s \mid x \text{ is extra large}\}$在\text{...}里面还可以嵌套$...$ 转义符一般情况下用\来作转义，但如果想要转义\，需要用\backslash，\\表示换行。 符号总结$\pm$ 表示 $\pm$$\times$ 表示 $\times$$\div$ 表示 $\div$$\sum$ 表示 $\sum$$\prod$ 表示 $\prod$$\coprod$ 表示 $\coprod$$\mid$ 表示 $\mid$$\nmid$ 表示 $\nmid$$\cdot$ 表示 $\cdot$$\leq$ 表示 $\leq$$\geq$ 表示 $\geq$$\neq$ 表示 $\neq$$\approx$ 表示 $\approx$$\equiv$ 表示 $\equiv$$\circ$ 表示 $\circ$$\ast$ 表示 $\ast$$\bigodot$ 表示 $\bigodot$$\bigotimes$ 表示 $\bigotimes$$\bigoplus$ 表示 $\bigoplus$$\mapsto$ 表示 $\mapsto$$\longmapsto$ 表示 $\longmapsto$$\hookleftarrow$ 表示 $\hookleftarrow$$\hookrightarrow$ 表示 $\hookrightarrow$$\leftharpoonup$ 表示 $\leftharpoonup$$\rightharpoonup$ 表示 $\rightharpoonup$$\leftharpoondown$ 表示 $\leftharpoondown$$\rightharpoondown$ 表示 $\rightharpoondown$$\rightleftharpoons$ 表示 $\rightleftharpoons$$\leadsto$ 表示 $\leadsto$$\nearrow$ 表示 $\nearrow$$\searrow$ 表示 $\searrow$$\swarrow$ 表示 $\swarrow$$\nwarrow$ 表示 $\nwarrow$$\nleftarrow$ 表示 $\nleftarrow$$\nrightarrow$ 表示 $\nrightarrow$$\nLeftarrow$ 表示 $\nLeftarrow$$\nRightarrow$ 表示 $\nRightarrow$$\nleftrightarrow$ 表示 $\nleftrightarrow$$\nLeftrightarrow$ 表示 $\nLeftrightarrow$$\dashrightarrow$ 表示 $\dashrightarrow$$\dashleftarrow$ 表示 $\dashleftarrow$$\leftleftarrows$ 表示 $\leftleftarrows$$\leftrightarrows$ 表示 $\leftrightarrows$$\Lleftarrow$ 表示 $\Lleftarrow$$\twoheadleftarrow$ 表示 $\twoheadleftarrow$$\leftarrowtail$ 表示 $\leftarrowtail$$\looparrowleft$ 表示 $\looparrowleft$$\leftrightharpoons$ 表示 $\leftrightharpoons$$\curvearrowleft$ 表示 $\curvearrowleft$$\circlearrowleft$ 表示 $\circlearrowleft$$\Lsh$ 表示 $\Lsh$$\upuparrows$ 表示 $\upuparrows$$\upharpoonleft$ 表示 $\upharpoonleft$$\downharpoonleft$ 表示 $\downharpoonleft$$\multimap$ 表示 $\multimap$$\leftrightsquigarrow$ 表示 $\leftrightsquigarrow$$\rightrightarrows$ 表示 $\rightrightarrows$$\rightleftarrows$ 表示 $\rightleftarrows$$\rightrightarrows$ 表示 $\rightrightarrows$$\rightleftarrows$ 表示 $\rightleftarrows$$\twoheadrightarrow$ 表示 $\twoheadrightarrow$$\rightarrowtail$ 表示 $\rightarrowtail$$\looparrowright$ 表示 $\looparrowright$$\rightleftharpoons$ 表示 $\rightleftharpoons$$\curvearrowright$ 表示 $\curvearrowright$$\circlearrowright$ 表示 $\circlearrowright$$\Rsh$ 表示 $\Rsh$$\downdownarrows$ 表示 $\downdownarrows$$\upharpoonright$ 表示 $\upharpoonright$$\downharpoonright$ 表示 $\downharpoonright$$\rightsquigarrow$ 表示 $\rightsquigarrow$$\uparrow$ 表示 $\uparrow$$\downarrow$ 表示 $\downarrow$$\Uparrow$ 表示 $\Uparrow$$\Downarrow$ 表示 $\Downarrow$$\updownarrow$ 表示 $\updownarrow$$\Updownarrow$ 表示 $\Updownarrow$$\rightarrow$ 表示 $\rightarrow$$\leftarrow$ 表示 $\leftarrow$$\Rightarrow$ 表示 $\Rightarrow$$\Leftarrow$ 表示 $\Leftarrow$$\leftrightarrow$ 表示 $\leftrightarrow$$\Leftrightarrow$ 表示 $\Leftrightarrow$$\longrightarrow$ 表示 $\longrightarrow$$\longleftarrow$ 表示 $\longleftarrow$$\Longrightarrow$ 表示 $\Longrightarrow$$\Longleftarrow$ 表示 $\Longleftarrow$$\longleftrightarrow$ 表示 $\longleftrightarrow$$\Longleftrightarrow$ 表示 $\Longleftrightarrow$$\emptyset$ 表示 $\emptyset$$\in$ 表示 $\in$$\notin$ 表示 $\notin$$\subset$ 表示 $\subset$$\supset$ 表示 $\supset$$\subseteq$ 表示 $\subseteq$$\supseteq$ 表示 $\supseteq$$\bigcap$ 表示 $\bigcap$$\bigcup$ 表示 $\bigcup$$\bigvee$ 表示 $\bigvee$$\bigwedge$ 表示 $\bigwedge$$\biguplus$ 表示 $\biguplus$$\bigsqcup$ 表示 $\bigsqcup$$\because$ 表示 $\because$$\therefore$ 表示 $\therefore$$\forall$ 表示 $\forall$$\exists$ 表示 $\exists$$\not=$ 表示 $\not=$$\not&gt;$ 表示 $\not&gt;$$\not\subset$ 表示 $\not\subset$$\aleph$ 表示 $\aleph$$\beth$ 表示 $\beth$$\daleth$ 表示 $\daleth$$\gimel$ 表示 $\gimel$$\alpha$ 表示 $\alpha$$\beta$ 表示 $\beta$$\gamma$ 表示 $\gamma$$\Gamma$ 表示 $\Gamma$$\digamma$ 表示 $\digamma$$\delta$ 表示 $\delta$$\Delta$ 表示 $\Delta$$\epsilon$ 表示 $\epsilon$$\varepsilon$ 表示 $\varepsilon$$\zeta$ 表示 $\zeta$$\eta$ 表示 $\eta$$\theta$ 表示 $\theta$$\Theta$ 表示 $\Theta$$\vartheta$ 表示 $\vartheta$$\iota$ 表示 $\iota$$\kappa$ 表示 $\kappa$$\varkappa$ 表示 $\varkappa$$\lambda$ 表示 $\lambda$$\Lambda$ 表示 $\Lambda$$\mu$ 表示 $\mu$$\nu$ 表示 $\nu$$\xi$ 表示 $\xi$$\Xi$ 表示 $\Xi$$\pi$ 表示 $\pi$$\Pi$ 表示 $\Pi$$\varpi$ 表示 $\varpi$$\rho$ 表示 $\rho$$\varrho$ 表示 $\varrho$$\sigma$ 表示 $\sigma$$\Sigma$ 表示 $\Sigma$$\varsigma$ 表示 $\varsigma$$\varsigma$ 表示 $\varsigma$$\tau$ 表示 $\tau$$\upsilon$ 表示 $\upsilon$$\Upsilon$ 表示 $\Upsilon$$\phi$ 表示 $\phi$$\Phi$ 表示 $\Phi$$\varphi$ 表示 $\varphi$$\chi$ 表示 $\chi$$\psi$ 表示 $\psi$$\Psi$ 表示 $\Psi$$\omega$ 表示 $\omega$$\Omega$ 表示 $\Omega$]]></content>
      <categories>
        <category>Language</category>
      </categories>
      <tags>
        <tag>MathJax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM CodeForces 894 A 题解 DP]]></title>
    <url>%2F2018%2F05%2F21%2Facm-cf-894a-dp%2F</url>
    <content type="text"><![CDATA[QAQ，简单DP题，详见本文内容。 题目A. QAQ 限制time limit per test: 1 secondmemory limit per test: 256 megabytesinput: standard inputoutput: standard output 描述“QAQ” is a word to denote an expression of crying. Imagine “Q” as eyes with tears and “A” as a mouth.Now Diamond has given Bort a string consisting of only uppercase English letters of length n. There is a great number of “QAQ” in the string (Diamond is so cute!).Bort wants to know how many subsequences “QAQ” are in the string Diamond has given. Note that the letters “QAQ” don’t have to be consecutive, but the order of letters should be exact. 输入格式The only line contains a string of length $n$$(1 \le n \le 100)$. It’s guaranteed that the string only contains uppercase English letters. 输出格式Print a single integer — the number of subsequences “QAQ” in the string. 样本1QAQAQYSYIOIWIN 14 1QAQQQZZYNOIWIN 13 提示In the first example there are 4 subsequences “QAQ”: “QAQAQYSYIOIWIN”, “QAQAQYSYIOIWIN”, “QAQAQYSYIOIWIN”, “QAQAQYSYIOIWIN”. 思路用dp;dp[0][i]代表前i个字符内Q字符出现的次数。dp[1][i]代表前i个字符内QA序列出现的次数。QA序列是QA对，QA两个字符不一定连续。dp[2][i]代表前i个字符内QAQ序列出现的次数。可以用滚动数组来减少空间复杂度。本代码中没有使用滚动数组。 代码12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;char str[110];int dp[3][110];int main()&#123; while(~scanf("%s", str))&#123; memset(dp, 0, sizeof dp); int len = strlen(str); for(int i = 0; i &lt; len; i++)&#123; if(i == 0)&#123; if(str[i] == 'Q')&#123; dp[0][i] = 1; &#125; continue; &#125; if(str[i] == 'Q')&#123; dp[0][i] = dp[0][i-1] + 1; dp[1][i] = dp[1][i-1]; dp[2][i] = dp[2][i-1] + dp[1][i-1]; &#125; else if(str[i] == 'A')&#123; dp[0][i] = dp[0][i-1]; dp[1][i] = dp[0][i-1] + dp[1][i-1]; dp[2][i] = dp[2][i-1]; &#125; else&#123; dp[0][i] = dp[0][i-1]; dp[1][i] = dp[1][i-1]; dp[2][i] = dp[2][i-1]; &#125; &#125; printf("%d\n", dp[2][len-1]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>CodeForces</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows10 C盘 空间容量提升]]></title>
    <url>%2F2018%2F05%2F20%2Fwindows-c-partition-space-clean%2F</url>
    <content type="text"><![CDATA[windows10的C盘总是莫名其妙的变小，到底是什么在占用C盘？看看如何将C盘里能请出去的请出去。 症状作为一个开发者，在使用windows的过程中，发现windows的C盘空间越来越小，这可怎么办呢？经过排查发现主要是C盘用户目录下的东西增长了。下面我们说几种能够提升一下C盘空间的方法。 用户目录移动windows10有了一个功能，能够将用户目录移动到别的目录。在C:\Users\yunhao目录下，基本上大部分的文件夹都能够移动到别的目录，右键文件夹，打开属性。可以在位置选项下选择新的位置存放该文件夹，然后会弹出对话框问你是不是要将原文件夹的内容移动过去。选是就行。 设置更改存储位置windows10的设置也能够更改内容的默认存储位置。windows键+I唤出设置，系统-&gt;存储，可以看到右侧更改新内容的保存位置。然后改到对应的目录就行了。 想法以下字符请自行产生映射 想法 -&gt; IDEA 因特尔 -&gt; intel 属性 -&gt; properties 如果你安装了想法，那么在用户目录下会看到.因特尔lij想法这个目录。想要移动这个目录，需要在想法安装目录下的bin文件夹下找到想法.属性这个文件，然后改user.home那两行。 Gradle用户目录下.gradle目录的移动，需要新建环境变量GRADLE_USER_HOME，值为你要移动的到的目录\.gradle，需要写上.gradle。 Android SDK用户目录下.android目录的移动，需要新建环境变量ANDROID_SDK_HOME，值为你要移动到的目录，最后不用写上.android。 Maven用户目录下的.m2目录的移动，需要在maven安装目录下conf文件夹下的setting.xml中改&lt;localRepository&gt;你要移动到的目录/.m2/repository&lt;/localRepository&gt; Vagrant用户目录下的.vagrant.d目录的移动，需要新建环境变量VAGRANT_HOME，值为你要移动到的目录\.vagrant.d，需要写上.vagrant.d。]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM CodeForces 983 B 题解 DP]]></title>
    <url>%2F2018%2F05%2F20%2Facm-cf-983b-dp%2F</url>
    <content type="text"><![CDATA[XOR-pyramid，用dp，提前打表，用递归的方式会超时。详见本文具体内容 题目B. XOR-pyramid 限制time limit per test: 2 secondsmemory limit per test: 512 megabytesinput: standard inputoutput: standard output 描述For an array $b$ of length $m$ we define the function $f$ as$$f(b) = \begin{cases} b[1] &amp; \quad \text{if } m = 1 \\ f(b[1] \oplus b[2],b[2] \oplus b[3],\dots,b[m-1] \oplus b[m]) &amp; \quad \text{otherwise,} \end{cases}$$where $\oplus$ is bitwise exclusive OR.For example,$$f(1,2,4,8)=f(1\oplus2,2\oplus4,4\oplus8)=f(3,6,12)=f(3\oplus6,6\oplus12)=f(5,10)=f(5\oplus10)=f(15)=15$$You are given an array $a$ and a few queries. Each query is represented as two integers $l$ and $r$. The answer is the maximum value of $f$ on all continuous subsegments of the array $a_l, a_{l+1}, \ldots, a_r$ 输入格式The first line contains a single integer $n$ $(1 \le n \le 5000)$ — the length of $a$.The second line contains $n$ integers $a_1, a_2, \dots, a_n (0 \le a_i \le 2^{30}-1)$ — the elements of the array.The third line contains a single integer $q$ $(1 \le q \le 100000)$ — the number of queries.Each of the next $q$ lines contains a query represented as two integers $l, r$ $(1 \le l \le r \le n)$. 输出格式Print q lines — the answers for the queries. 样本1234538 4 122 31 2 12512 123456761 2 4 8 16 3241 62 53 41 2 12346030123 提示In first sample in both queries the maximum value of the function is reached on the subsegment that is equal to the whole segment.In second sample, optimal segment for first query are $[3,6]$, for second query — $[2,5]$, for third — $[3,4]$, for fourth — $[1,2]$ 思路用dp，dp右上半个数组存储f(l到r)的值，dp左下半个数组存储l到r区间内子串的最大f函数值提前打表，用递归的方式会超时。亲测。 代码123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int n, q, l, r;int dp[5005][5005];void calc()&#123; for (int i = 2; i &lt;= n; i++)&#123; for(int j = 0; j &lt; n-i+1; j++)&#123; int x = j+1, y = i+j; dp[x][y] = dp[x+1][y] ^ dp[x][y-1]; dp[y][x] = max(dp[x][y], max(dp[y][x+1], dp[y-1][x])); &#125; &#125;&#125;int main()&#123; while(~scanf("%d", &amp;n))&#123; for (int i = 1; i &lt;= n; i++)&#123; scanf("%d", &amp;dp[i][i]); &#125; calc(); scanf("%d", &amp;q); for (int w = 0; w &lt; q; w++)&#123; scanf("%d%d", &amp;l, &amp;r); printf("%d\n", dp[r][l]); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>CodeForces</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM HDU 2577 题解 DP]]></title>
    <url>%2F2018%2F05%2F19%2Facm-hdu-2577-dp%2F</url>
    <content type="text"><![CDATA[How to Type，简单DP，详见本文具体内容 题目How to Type 限制Time Limit: 2000/1000 MS(JAVA/Others)Memory Limit: 32768/32768 K (JAVA/Others) 描述Pirates have finished developing the software.He called Cathy to test his typing software. She is good at thinking. After testing for several days, she finds that if she types a string by some ways, she will type the key at least. But she has a bad habit that if the caps lock is on, she must turn off it, after she finishes typing. Now she wants to know the smallest times of typing the key to finish typing a string. 输入格式The first line is an integer $t$ $(t \le 100)$, which is the number of test case in the input file. For each test case, there is only one string which consists of lowercase letter and upper case letter. The length of the string is at most 100. 输出格式For each test case, you must output the smallest times of typing the key to finish typing this string. 样本12343PiratesHDUacmHDUACM 123888 提示The string “Pirates”, can type this way, Shift, p, i, r, a, t, e, s, the answer is 8.The string “HDUacm”, can type this way, Caps lock, h, d, u, Caps lock, a, c, m, the answer is 8The stirng “HDUACM”, can type this way, Caps lock, h, d, u, a, c, m, Caps lock, the answer is 8 思路用动态规划dp[0][j]代表，输入完j个字符之后保持在小写状态的情况下，最小的按键次数。dp[1][j]代表，输入完j个字符之后保持在大写状态的情况下，最小的按键次数。可以考虑用滚动数组，这样可以将数组缩小到dp[2][2]。本解法没用滚动数组。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int t;char s[110];int dp[2][110];int main()&#123; scanf("%d", &amp;t); while(t--)&#123; scanf("%s", s); int len = strlen(s); memset(dp, 0x3f, sizeof dp); for (int i = 0; i &lt; len; i++)&#123; if(s[i] &gt;= 'a' &amp;&amp; s[i] &lt;= 'z')&#123; if(i == 0)&#123; dp[0][i] = 1; dp[1][i] = 2; &#125; else&#123; dp[0][i] = min(dp[0][i-1]+1, dp[1][i-1]+2); dp[1][i] = min(dp[1][i-1]+2, dp[0][i-1]+2); &#125; &#125; else&#123; if(i == 0)&#123; dp[0][i] = 2; dp[1][i] = 2; &#125; else&#123; dp[0][i] = min(dp[0][i-1]+2, dp[1][i-1]+2); dp[1][i] = min(dp[1][i-1]+1, dp[0][i-1]+2); &#125; &#125; &#125; int res = min(dp[0][len-1], dp[1][len-1]+1); printf("%d\n", res); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DP</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu16.04 Nginx 反向代理 Apache]]></title>
    <url>%2F2017%2F04%2F07%2Fubuntu-nginx-apache-reverse-proxy%2F</url>
    <content type="text"><![CDATA[Nginx 处理静态界面的性能比 Apache 要高很多，Nginx 同样能够抗并发。但是对于 php 等，Nginx 可以通过 FastCGI 转给 php-fpm 处理。在这个过程中，还是可能会出现403等问题。如果能够让 Nginx 反向代理 Apache 就完美了。 Nginx 的优缺点 轻量级，比apache占用更少的内存及资源 抗并发，nginx处理请求是异步非阻塞的，而apache则是阻塞型的，在高并发下nginx能保持低资源低消耗高性能 没Apache稳定 Apache 的优缺点 rewrite，比nginx的rewrite强大 模块化，结构清晰 稳定，bug较少 思路让Nginx始终监听80端口，做反向代理服务器，Apache退居二线，当遇到Nginx处理不了的请求时候，让Apache处理，处理之后，在返回给Nginx。帖子以php为例。 取消 Nginx 的 FastCGI 代理如果只用Nginx来跑php项目的同学，一定设置过FastCGI代理给php-fpm，我们先取消这个代理，这样的话，Nginx就不能处理php了，能够便于之后的测试。在/etc/nginx/sites-available/default文件中。12cd /etc/nginx/sites-availablesudo vim default 找到如下的地方。12345678910# pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000#location ~ \.php$ &#123;# include snippets/fastcgi-php.conf;## # With php7.0-cgi alone:# fastcgi_pass 127.0.0.1:9000;# # With php7.0-fpm:# fastcgi_pass unix:/run/php/php7.0-fpm.sock;&#125; 将上面的东西注释掉。之后让nginx的配置文件重新载入一下。123sudo systemctl reload nginxcd /var/www/htmlsudo vim index.php 在/var/www/html目录下新建index.php文件。文件中输入1&lt;?php echo phpinfo(); ?&gt; 这个时候，我们访问http://localhost/index.php会发现直接进行下载，没有进行解析。显然，nginx已经失去了解析php的功能。然后我们停止nginx。1sudo systemctl stop nginx 安装 Apache如果没有安装Apache的同学请安装apache1sudo apt install apache2 修改 Apache 的 ports.conf现在我们修改apache的配置文件，好让apache，退居二线。在/etc/apache2目录下，找到ports.conf文件，这个文件中，我们可以看到，是用来注册监听端口的文件。在apache2.conf文件中被包含进去了。12cd /etc/apache2sudo vim ports.conf 文件中的内容如下。123456789101112131415# If you just change the port or add more ports here, you will likely also# have to change the VirtualHost statement in# /etc/apache2/sites-enabled/000-default.confListen 80&lt;IfModule ssl_module&gt; Listen 443&lt;/IfModule&gt;&lt;IfModule mod_gnutls.c&gt; Listen 443&lt;/IfModule&gt;# vim: syntax=apache ts=4 sw=4 sts=4 sr noet 我们可以看到这个文件中最上面的说明。如果更改或者增加了监听端口的话，有也得在000-default.conf文件中做更改。好，现在我们把Listen 80改成Listen 8080，也就是说，我们取消监听80端口，改成监听8080端口。然后保存。 修改 Apache 的 000-default.conf我们修改好了ports.conf，还要修改000-default.conf。12cd /etc/apache2/sites-availablesudo vim 000-default.conf 打开文件之后，我们就可以看到12345678910111213141516171819202122232425262728293031&lt;VirtualHost *:80&gt; # The ServerName directive sets the request scheme, hostname and port that # the server uses to identify itself. This is used when creating # redirection URLs. In the context of virtual hosts, the ServerName # specifies what hostname must appear in the request's Host: header to # match this virtual host. For the default virtual host (this file) this # value is not decisive as it is used as a last resort host regardless. # However, you must set it for any further virtual host explicitly. #ServerName www.example.com ServerAdmin webmaster@localhost DocumentRoot /var/www/html # Available loglevels: trace8, ..., trace1, debug, info, notice, warn, # error, crit, alert, emerg. # It is also possible to configure the loglevel for particular # modules, e.g. #LogLevel info ssl:warn ErrorLog $&#123;APACHE_LOG_DIR&#125;/error.log CustomLog $&#123;APACHE_LOG_DIR&#125;/access.log combined # For most configuration files from conf-available/, which are # enabled or disabled at a global level, it is possible to # include a line for only one particular virtual host. For example the # following line enables the CGI configuration for this host only # after it has been globally disabled with "a2disconf". #Include conf-available/serve-cgi-bin.conf&lt;/VirtualHost&gt;# vim: syntax=apache ts=4 sw=4 sts=4 sr noet 上面的第一行&lt;VirtualHost *:80&gt;。是虚拟主机的配置项。*:80的意思是所有ip的80端口。刚刚我们在ports.conf中只注册了8080端口，那么，我们同样也需要将这个位置的80改成8080。退出保存。1sudo systemctl reload apache2 现在apache就退居二线了。也就是说，80端口已经不被apache占用了。我们可以启动nginx了。1sudo systemctl start nginx 这个时候，nginx就能够成功启动了。如果不更改Apache监听端口的话，nginx是无法启动的，因为他们同时监听80端口。 测试1我们先来测试一波，现在我们访问http://localhost/index.php会发现，直接下载index.php。但是我们访问http://localhost:8080/index.php会发现，能够成功解析界面。因为，前者是通过nginx来处理的，而后者是通过apache来处理的，所以显示的结果不一样。 Nginx 做 Apache 的反向代理现在我们要让nginx遇到php文件的时候，交给apache去处理，然后，返回结果。期待已久了吧？我们要修改nginx的default文件。12cd /etc/nginx/sites-availablesudo vim default 我们需要在处理匹配php的正则表达式的location下加一个代理。1234567891011# pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000#location ~ \.php$ &#123;# include snippets/fastcgi-php.conf;## # With php7.0-cgi alone:# fastcgi_pass 127.0.0.1:9000;# # With php7.0-fpm:# fastcgi_pass unix:/run/php/php7.0-fpm.sock; proxy_pass http://localhost:8080;&#125; 这句话的意思就是，匹配到php文件的时候，交给localhost:8080去处理。我们都知道localhost:8080是apache所在的位置。所以，这个反向代理就成功了。1sudo systemctl reload nginx 我们重新载入一下nginx的配置文件。 测试2现在，一切都OK了。我们再测试一下。首先访问http://localhost/index.php。这个时候，就能够成功的显示界面了。可以看出php已经被解析了。然后如果，我们关闭apache的服务。1sudo systemctl stop apache2 这个时候，我们再访问，http://localhost/index.php。我们会发现，还是解析不了，是因为apache关闭的原因了。所以，这个真的是apache处理的php文件。当然，我们也可以通过，界面显示内容的server API 来判断是谁解析的php文件。记得将nginx和apache都设置一下开机启动。]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>服务器</tag>
        <tag>代理</tag>
        <tag>Nginx</tag>
        <tag>Apache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正向代理与反向代理]]></title>
    <url>%2F2017%2F04%2F07%2Fforward-proxy-and-reverse-proxy%2F</url>
    <content type="text"><![CDATA[什么是代理呢？用了这么久的Nginx，也听说过Nginx搭建反向代理服务器。正向代理是什么？反向代理是什么？两者的区别呢？ 代理打个比方，代理就是我们生活中所熟知的中介。他负责联系服务方和客户方。在服务器层面，就是客户端和服务器中间的一个服务器。这个服务器其实和正常的服务器没什么两样。只不过，他将客户发来的请求，转发到真正处理请求的服务器。或者是下一个代理服务器。正因为有了代理服务器的存在，才有了墙的存在。墙其实就是代理服务器。比如我们访问google.com，代理服务器接受到了这个请求，正常的话，他应该去转发请求的。但是，墙这个代理很邪恶，他不转发，然后告诉你，哎呀，这个没有啊，找不到。然后就访问不了了。 正向代理举个生活中的例子。比如你向隔壁老王借钱，但是隔壁老王和你不熟，不借给你。然后呢？你想到了，隔壁老王和你媳妇熟啊，于是，你让你媳妇跟隔壁老王借钱，隔壁老王一看是你媳妇和他借钱，十分爽快的答应了。然后你媳妇把借来的钱又给你了。综上，隔壁老王只知道把钱借给你媳妇了，不知道实际上是借给你了。而你，知道这一切。你就是客户，你媳妇就是正向代理服务器，老王就是真正的服务器。客户向代理服务器请求，代理服务器向真正的服务器请求。然后处理之后的请求，代理服务器再转给你。整个过程中，客户知道代理服务器的存在。而真正的服务器，感知不到客户的存在，只能感知到代理服务器的存在。 对他来说，代理服务器就是他的客户，所以他感知不到真正的客户。 反向代理举个生活中的例子，你遇到了坏人，然后急中生智，你掏出了手机，打电话给110。然后打通了，过了一会儿，警察来了，然后把坏人抓走了。等等，仔细想一下，全国都哪都有警察，为什么都打一个电话？拨打110之后，会有一个处理系统，来确认你的位置，然后派出相应的警察来帮助你解决问题。这个过程中，如果你不仔细想，你不会感觉到有这个处理系统的存在的。你也不知道，到底哪个地方的110来帮你解决问题，你只知道有警察来了，问题解决了。在上面这个过程中，你就是客户，处理系统就是反向代理服务器，警察就是对应的服务器。反向代理服务器，让客户感觉到方便，向反向代理服务器请求，就好像向真的服务器请求一样。客户无法感知到真正的服务器的存在的。 区别图中的两个方框对与方框之外的事物，像黑盒一样。正向代理服务器是对真正服务器透明，真正的服务器，感知不到客户存在。反向代理服务器是对客户透明，客户，感知不到真正的服务器。]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu16.04 Sogou 输入法的备选词框不见了解决方法]]></title>
    <url>%2F2017%2F03%2F30%2Fubuntu-sogou-input-doesnot-work%2F</url>
    <content type="text"><![CDATA[正在写着博客，突然Ubuntu报了一个内部错误，查看详细一看，貌似是关于sogou输入法的。没当回事儿。过了一会儿，搜狗输入法的备选词框不见了，只能输入英文，这可怎么整。赶紧解决了它。 本帖子针对Ubuntu16.04。 症状Sogou输入法的备选词框不见了。只能输入英文，而且按空格键还不能将英文输进去。 解决方法重新安装输入法。首先要卸载之前的输入法。--purge选项是清除配置文件的。更彻底的一种卸载。1sudo apt remove sogoupinyin --purge 当然，单靠这一句话的力量好像并不能解决掉问题。1234cd ~/.configsudo rm -r SogouPY.userssudo rm -r SogouPYsudo rm -r sogou-qimpanel 然后，在这些操作之后，我重启了一下电脑。不知道需不需要这一步之后，安装sogou输入法的依赖1sudo apt install libopencc1 fcitx-libs fcitx-libs-qt fonts-droid-fallback 然后去sogou输入法的官网，找到上面的linux输入法。然后下载最新的deb包。12sudo dpkg -i ~/下载/sogoupinyin_2.1.0.0082_amd64.debreboot 然后再重启一下电脑，sogou输入法就能正常使用了。]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>搜狗输入法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu16.04 FireFox Flash 插件安装]]></title>
    <url>%2F2017%2F03%2F30%2Ffirefox-add-flash-plugins%2F</url>
    <content type="text"><![CDATA[firefox浏览器下载了之后，默认都是没有安装插件的。如何给firefox浏览器安装插件呢？希望下这篇帖子能够帮助你。 flash插件官网去https://get.adobe.com/flashplayer/这个网站，下载对应的flash插件。选择tar.gz下载。 解压解压下载之后的文件。1tar -xzvf flash_player_npapi_linux.x86_64.tar.gz 目录结构解压了之后，我们可以清晰的看到目录结构。12345678910111213.├── flash_player_npapi_linux.x86_64.tar.gz├── LGPL│ ├── LGPL.txt│ └── notice.txt├── libflashplayer.so├── license.pdf├── readme.txt└── usr ├── bin ├── lib ├── lib64 └── share 拷贝文件将libflashplayer.so这个文件拷贝到/usr/lib/firefox-addons/plugins，将usr下的东西拷贝到/usr下。12sudo cp libflashplayer.so /usr/lib/firefox-addons/pluginssudo cp -r usr/ /usr 重启firefox重新启动，firefox，我们就会发现，能够使用flash插件了。]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>浏览器</tag>
        <tag>FireFox</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu16.04 Nginx 配置站点学习笔记]]></title>
    <url>%2F2017%2F03%2F30%2Fnginx-server-config-guide%2F</url>
    <content type="text"><![CDATA[突然想看一看nginx的文件中应该如何写配置信息，于是看了nginx的官方文档。本文讲述nginx的目录结构，以及如何配置静态服务器等。 nginx 的目录结构nginx的目录结构如下12345678910111213141516171819202122.├── conf.d│ └── my.conf├── fastcgi.conf├── fastcgi_params├── koi-utf├── koi-win├── mime.types├── nginx.conf├── proxy_params├── scgi_params├── sites-available│ ├── default│ └── openapi.com├── sites-enabled│ ├── default -&gt; /etc/nginx/sites-available/default│ └── openapi.com -&gt; /etc/nginx/sites-available/openapi.com├── snippets│ ├── fastcgi-php.conf│ └── snakeoil.conf├── uwsgi_params└── win-utf 这个目录结构是用tree这个东西搞出来的。感兴趣的同学可以安装一下。个人感觉挺好用的。1234sudo apt-get install treetree --helpcd /etc/nginxtree 这样就会出现上面的文件目录了。 nginx.conf首先我们查看一下nginx.conf的文件内容。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364user www-data;worker_processes auto;pid /run/nginx.pid;events &#123; worker_connections 768; # multi_accept on;&#125;http &#123; ## # Basic Settings ## sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; # server_tokens off; # server_names_hash_bucket_size 64; # server_name_in_redirect off; include /etc/nginx/mime.types; default_type application/octet-stream; ## # SSL Settings ## ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # Dropping SSLv3, ref: POODLE ssl_prefer_server_ciphers on; ## # Logging Settings ## access_log /var/log/nginx/access.log; error_log /var/log/nginx/error.log; ## # Gzip Settings ## gzip on; gzip_disable "msie6"; # gzip_vary on; # gzip_proxied any; # gzip_comp_level 6; # gzip_buffers 16 8k; # gzip_http_version 1.1; # gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript; ## # Virtual Host Configs ## include /etc/nginx/conf.d/*.conf; include /etc/nginx/sites-enabled/*;&#125;... 迷之用户我们可以看到，上面的user是www-data，这个是一个用户，没错。linux会创造一些用户，这些用户和普通用户是不一样的。他们主要用来进行一些系统上的的操作。大家可以看一下用户列表。1cat -n /etc/passwd | grep www-data 返回的结果中有一个什么什么nologin，这个东西其实就是限制用户登陆的。好了，不多做介绍。 多个进程nginx是有一个master进程和若干个worker进程的。worker进程负责各种细致的工作，master进程负责管理各种worker进程。我们可以通过一下的命令来查看一下nginx的进程。1ps -aux | grep nginx 具体的输出如下:12345root 1002 0.0 0.0 124972 1444 ? Ss 14:45 0:00 nginx: master process /usr/sbin/nginx -g daemon on; master_process on;www-data 1003 0.0 0.0 125348 3212 ? S 14:45 0:00 nginx: worker processwww-data 1004 0.0 0.0 125348 3212 ? S 14:45 0:00 nginx: worker processwww-data 1005 0.0 0.0 125348 3212 ? S 14:45 0:00 nginx: worker processwww-data 1006 0.0 0.0 125348 3212 ? S 14:45 0:00 nginx: worker process 启动的命令启动nginx的命令有好多种方式。在这里我介绍一种方式。12345sudo systemctl start nginx 启动nginxsudo systemctl restart nginx 重启nginxsudo systemctl stop nginx 关闭nginxsudo systemctl reload nginx 重新加载nginx的配置文件sudo systemctl status nginx 查看nginx的状态 建议保持一种方式对nginx进行操作。也就是说如果总是用systemctl来操作nginx的状态就一直用systemctl来操作，如果还用别的命令的话，免不了会出问题。之前我就出过问题。如果出了问题怎么办呢？也不要太慌张。kill -9强制杀死就好了。 log文件做一些比较基本的介绍。配置文件中，我们可以很清晰的找到。access_log 和 error_log这两行，这两行后面的目录就是存错误信息的目录，如果访问的时候出现什么404啊什么的。去这两个文件中查看，能够帮助定位错误信息。 注释nginx的配置文件中注释的风格是在一行的开头加#号。这是一句废话。。。 虚拟主机配置我们可以看到nginx.conf最下面的两行include，这个就是在启动nginx的时候，加载的配置文件。在修改配置文件的时候不建议在nginx.conf文件中做改动，建议在conf.d/目录下新建.conf文件，或是在sites-available/目录下新建文件，然后在sites-enabled/目录下做软连接。 配置文件的嵌套格式最外层是http context(上下文)，然后是server context， 最后是location context1234567http&#123; server &#123; location &#123; &#125; &#125;&#125; 配置静态服务器首先打开nginx服务器。12sudo systemctl start nginxsudo systemctl enable nginx 设置开启自启动 我们在新建/test/data目录，与/test/images目录。然后我们在/test目录下新建index.html文件，文件中写/test。在/test/data目录下新建index.html文件，文件中写/test/ data，同样在/test/images下的index.html文件中写/test/images。首先请确保，其他的位置没有定义location /。确保/test/data与/test/images至少有r-xr-xr-x权限。我们在conf.d目录下新建一个my.conf文件。然后编辑该文件。12345678server &#123; location / &#123; root /test/data; &#125; location /images/ &#123; root /test; &#125;&#125; 修改完该文件之后，我们要reload一下1sudo systemctl reload nginx root代表绑定到路由的文件系统。如果如果不写监听端口的话，默认监听80端口。因此这样的话，在浏览器中访问http://localhost/的时候，我们会看到/test/data，如果访问http://localhost/images/我们会看到/test/images。如果出现问题的话，那么可以参考/var/log/nginx/error.log这个文件的最后一行。就是刚刚访问出现问题的地方，或许会有所帮助。 配置代理服务器代理服务器(proxy server)是指将用户发来的请求，发送给被代理方，然后再将被代理方返回的结果，发给用户。也就是说正常的服务器和用户之间的通信被一个类似中介的服务器分成了2段，用户和原来的服务器不直接通信，而是通过代理服务器进行通信。将刚刚的配置文件改成这个样子123456789server &#123; listen 8080; location / &#123; root /test/data; &#125; location /images/ &#123; root /test; &#125;&#125; 然后我们reload一下nginx1sudo systemctl reload nginx 这个时候，我们会发现访问http://localhost/不能显示界面了。这是因为我们把刚刚的两个服务，定到了8080端口。这个时候我们访问的时候需要在后面加上端口号http://localhost:8080/这样的话，就会和刚刚一样了。现在我们再次修改配置文件123456789101112131415server &#123; listen 8080; location / &#123; root /test/data; &#125; location /images/ &#123; root /test; &#125;&#125;server &#123; location / &#123; proxy_pass http://localhost:8080; &#125;&#125; 我们再reload一下。proxy_pass，这个意思是被代理的服务器的地址。我们这个时候访问http://localhost/这个时候，我们会发现，页面显示/test/data。localhost:8080被localhost代理了。如果出现了错误的话，我们就在/var/log/nginx/error.log文件中查看具体的错误信息。 正则匹配location的url还可以使用正则匹配，～号代表的是正则匹配，而后面的就是正则表达式啦。\.(gif|jpg|png)$的意思是，以.gif或者.jpg或者.png结尾的就用这个location定位。当然，你需要在/test/images目录下有对应的图片。123456789101112131415161718server &#123; listen 8080; location / &#123; root /test/data; &#125; location /images/ &#123; root /test; &#125;&#125;server &#123; location / &#123; proxy_pass http://localhost:8080; &#125; location ~ \.(gif|jpg|png)$ &#123; root /test/images; &#125;&#125; 1sudo systemctl reload nginx 记得reload一下。当你访问http://localhost/haha.png的时候，就会发现在/test/images/haha.png的图片显示在了网页上。 FastCGI 代理用过php的大家都知道，nginx是没办法直接和php连起来的。需要一个php-fpm的东西。这个的话，就需要在nginx的配置文件中增加fastcgi_pass这个东西。和proxy_pass类似。在这篇博客中不做叙述。在Ubuntu16.04 PHP Nginx 配置这篇博客中详细说明。 匹配方式nginx官方文档中说明。在匹配location的时候，首先匹配直接指明的location前缀，之后再匹配正则表达式。匹配直接指明的location前缀的时候，按能匹配到最长前缀进行匹配。之后，再进行正则表达式匹配，正则表达式匹配中，如果有多个能够匹配上，按出现时间最早的进行匹配。]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>服务器</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo NexT Disqus 评论插件]]></title>
    <url>%2F2017%2F03%2F29%2Fhexo-disqus-comments%2F</url>
    <content type="text"><![CDATA[自从多说关闭之后，第三方的评论工具让人找了又找。于是我找到了Disqus。本文针对说明NexT主题与Disqus的配置。 注册Disqus账号登陆disqus.com注册账号。注册过程，不多做说明。 进行邮箱确认注册了disqus账号之后，一定要去邮箱点击一下确认。我当时就是没有点击确认，好像就没有进行下去，还是区点击一下确认吧。 进入 Disqus Home 页应该在disqus.com/home之后点击右上角的齿轮，再点击 Add Disqus To Site。找到页面最下边的 Get Started 按钮。之后点击下面的install Disqus。注意WebsiteName，这个名字要用到配置文件中的。起一个你喜欢的。 设置主题配置文件打开主题配置文件。找到如下的位置：12345# Disqusdisqus: enable: true shortname: ****** count: true shortname的位置就填写刚刚的 WebSite Name 的名字。这样就配置好了。 重新部署123hexo cleanhexo ghexo d PS不过，Disqus墙没墙掉我也不太清楚，让我很是无奈。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atom 插件 browser-plus 修改默认搜索]]></title>
    <url>%2F2017%2F03%2F27%2Fatom-packages-browser-plus-change-default-search-engine%2F</url>
    <content type="text"><![CDATA[安装了atom的browser-plus插件之后，发现url栏的默认搜索是google搜索，想要改成百度搜索怎么办？ 查找很简单。找到配置文件，首先进行备份，以免以后想要改回来。12cd ~/.atom/packages/browser-plus/libcp ./browser-plus-view.coffee ./browser-plus-view.coffee.backup 修改用vim打开。/http://www.google.com/search?as_q=。查找到三处。将这三处替换为http://www.baidu.com/s?ie=UTF-8&amp;wd=。然后重启atom，测试，生效。]]></content>
      <categories>
        <category>编辑器</category>
      </categories>
      <tags>
        <tag>编辑器</tag>
        <tag>Atom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atom 编辑器的插件总结]]></title>
    <url>%2F2017%2F03%2F27%2Fatom-plugins-guide%2F</url>
    <content type="text"><![CDATA[总结一下我的 Atom 编辑器的 Package，个人认为比较好的一些。 安装插件找到编辑-&gt;设置-&gt;Install，在里面搜索插件的名字，可以直接点安装。有些插件安装出现问题，可以到 atom.io/packages 这个网站上去所搜，然后找到github地址。1234cd ~/.atom/packagesgit clone github地址cd 插件目录apm install 或者是 npm install 注意有些插件是需要前置插件的！ Remote-FTP能够连接FTP，显示目录结构。比较有用。 activate-power-modeatom 互动的一个插件，比较有意思。打字的时候会有互动。 atom-beautifyatom 美化代码排版的。当代码格式很乱的时候，就beautify一下。就整齐了。 browser-plusatom集成浏览器，能够在atom中搜索，是不是让搜索更加便捷了呢。 color-picker颜色选择器，前端程序员必备利器。 file-icons让atom的图标更丰富。 git-plus能够在命令界面控制git，感觉不太好用。感觉直接唤出命令行，更容易一些。 language-ocamlocaml语言的高亮，自动自动补全什么的。 markdown-preview-plusmarkdown预览，Ctrl+Shift+M唤出。 markdown-writermarkdown编写的助手吧，不知道具体是做什么的，反正写markdown，我就安装了。 merge-conflicts能够图形化的解决git中的冲突，可以一试。 minimap向sublime一样的右上角的代码缩略图。 ocaml-indentocaml语言的自动缩进。 platformio-ide-terminal让atom能够唤出终端，利器，良心推荐。 remote-edit能够连接服务器并且编辑编辑文件。感觉不够方便，与remote-ftp结合起来，还不错。 simplified-chinese-menu简体中文汉化包，翻译了绝大部分的选项。]]></content>
      <categories>
        <category>编辑器</category>
      </categories>
      <tags>
        <tag>编辑器</tag>
        <tag>Atom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu16.04 GitHub SSH密钥 配置]]></title>
    <url>%2F2017%2F03%2F27%2Fgithub-ssh-config%2F</url>
    <content type="text"><![CDATA[很多地方都需要用到SSH服务，本文简述SSH技术，如何生成并使用SSH密钥，Ubuntu 16.04 GitHub SSH连接。 SSH的简介SSH技术是指通信的双方A，B，分别有自己的公钥和私钥，公钥负责加密信息，私钥负责解密信息。设定是这样的A公钥加密的信息，只能通过A的私钥来解密，不能通过其他的私钥来解密，而且通过A的公钥很难推断出A的私钥。通信开始前，双方得知对方的公钥，A给B发送数据，用B的公钥来加密。B给A发送数据用A的公钥来加密。此项技术能够保证通信之间的安全性。即使信息被第三方获取，也无法解密。避免了信息被窃取，篡改，和冒充的情况。 SSH的生成首先查看/home/username/.ssh目录下是否有类似id_rsa和id_rsa.pub这样的一对文件存在。如果存在的话，不需要生成ssh。如果不存在的话，首先生成这样的文件。1ssh-keygen 生成的过程中会有提示，会让你输入两次密码，这个密码是在使用ssh时候输入的，如果不想设置密码，直接按回车。 SSH在Github上的配置登陆Github网站，找到个人设置界面。左侧有 SSH and GPG keys 类似字样的选项，点击。然后新建一个 SSH 的 key， 把/home/username/.ssh/id_rsa.pub中的内容复制过去。然后保存。之后就OK了。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Git</tag>
        <tag>GitHub</tag>
        <tag>OpenSSH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub Hexo blog 绑定域名]]></title>
    <url>%2F2017%2F03%2F27%2Fgithub-hexo-blog-bundle-domain%2F</url>
    <content type="text"><![CDATA[Github 上的 username.github.io 的博客绑定域名操作。 创建CNAME文件首先我们要在master分之下创建CNAME文件，文件中写‘你自己想的二级域名.你购买的一级域名’。假设我想访问www.yunhao.space的时候，访问博客，那么二级域名是www，再加上一级域名，所以CNAME文件中写www.yunhao.space。假设想访问yunhao.space的时候，访问博客，那么二级域名就是空的，所以CNAME文件中写yunhao.space这时候就会遇到一个问题，每次在hexo d的时候，CNAME文件会被删除，不要慌，我们将CNAME文件创建在source目录下，然后再进行hexo g的时候，会生成。不用担心CNAME文件被删除的情况。 开启仓库的GitHub Pages服务一般是开启了，最好确认一下。去仓库的settings，注意是仓库的settings。找到GitHub Pages位置，将Source位置设置成master branch，然后点击Save。 添加解析去购买域名的网站。找到购买的一级域名。点击解析，然后添加记录。记录类型写CNAME，然后主机记录，就是你要起的二级域名，然后记录值，就是你的github的username.github.io了。如果不会添加记录，参考域名解析配置教程我们看介绍可以知道CNAME是针对的两个域名之间的解析，即把记录值的域名，解析成二级域名和一级域名组合成的域名。添加完解析之后，稍等几分钟，访问域名就能看到你的博客了。 更多文章写得比较早，有点管中窥豹的感觉，想要了解更多的话，请参考我的另外几篇文章。域名解析配置教程，GitHub Hexo 博客 GitHub Pages 个人站点 多域名绑定问题，GoDaddy 域名 托管于腾讯云解析]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>域名</tag>
        <tag>DNS</tag>
        <tag>Git</tag>
        <tag>GitHub</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 备份]]></title>
    <url>%2F2017%2F03%2F27%2Fhexo-backup%2F</url>
    <content type="text"><![CDATA[hexo 备份和移植 创建仓库PS：如果远程已经备份好，只是要pull下来，请跳到恢复一节假设我们的博客的项目目录为blog我们可以看到在blog目录下是没有.git文件夹的。首先，我们先将所有的更改，提交到本地库12git add .git commit -m "backup" 创建backup分支我们新建一个叫做backup的分支。然后切换到该分支，再删除master分支。1234git branch backupgit checkout backupgit branch -d mastergit branch 我们可以通过git branch 查看，只剩一个backup分支。 连接远程我们连接远程库，并进行push操作，如下，远程库会自动建立backup分支。12git remote add origin 你的username.github.io的项目地址git push origin backup:backup 修改push和pull的默认分支保险起见，设置默认的跟踪分支，之后会看到本地的backup分支跟踪origin/backup分支12git push -u origin backupgit branch --set-upstream-to=origin/backup backup 设置了之后，我们再进行git push 或者是git pull的操作的时候就不用担心，会影响到origin/master分支了。 备份之后我们再上传新的帖子的时候，要进行下面的操作。123456hexo cleanhexo ggit add .git commit -m "backup"git pushhexo d 这样就能够备份了 恢复本地的博客丢了怎么办？这样就能够弄一份一模一样的了。1234567891011121314mkdir blogcd bloggit initgit remote add origin 你的username.github.io的项目地址git pull origin backup:backupgit branchgit checkout backupgit branch -d mastergit push -u origin backupgit branch --set-upstream-to=origin/backup backupnpm installhexo cleanhexo ghexo d 多仓库的备份最近又倒腾了倒腾。然后把博客和博客备份和博客主题分成三个仓库存储。利用Git的submodule特性，使博客主题作为博客备份仓库的一个子模块。如果不知道submodule特性是什么的话，Git Submodule 特性详解简要说下，首先我先把next的主题从theme-next的仓库fork过来了。然后新建了一个blog-backuper的仓库。然后将本地的博客项目中的.git文件夹删除，将themes文件夹下的next另存一份，并从博客项目中移除。然后在博客项目根目录执行下面操作：1234567cd bloggit initgit submodule add git@github.com:lmnsyunhao/hexo-theme-next.git themes/nextgit remote add origin git@github.com:lmnsyunhao/blog-backuper.gitgit add .git commit -m &quot;reconstruction&quot;git push -u origin master 然后重新修改主题。这种情况下不出意外，应该就重构好了。以后每次备份的时候，如下：12345678910cd bloghexo cl &amp; hexo g &amp; hexo dcd themes/nextgit add .git commit -m &quot;update&quot;git pushcd ../..git add .git commit -m &quot;update&quot;git push 恢复的时候，执行如下操作：123git clone git@github.com:lmnsyunhao/blog-backuper.git --recursivegit submodule foreach git pullnpm install 然后就能正常的创作了。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu16.04 PPPoE 拨号上网]]></title>
    <url>%2F2017%2F03%2F27%2Fubuntu-PPPoE-dsl-connection%2F</url>
    <content type="text"><![CDATA[学校给了我们一个客户端来有线登陆，但是只能是windows的，ubuntu想要连接有线怎么办？ubuntu PPPoE 拨号登陆校园网 配置信息打开终端，输入sudo pppoeconf之后会出现界面，让你输入用户名，注意这个界面上默认有username，一定要把username全都删掉，再输入用户名才行。之前一直没注意。后面一路选是，直到有一个是询问是否开机自动连接，这个选否。 三条命令我们可以通过plog这条命令来，查看状态。我们可以通过sudo poff -a来断开所有连接。我们下次连接的时候通过pon dsl-provider来连接。]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>PPPoE</tag>
        <tag>DSL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown 学习笔记]]></title>
    <url>%2F2017%2F03%2F26%2Fmarkdown-learning-note%2F</url>
    <content type="text"><![CDATA[Markdown基本语法，帖子的布局格式，开始Hexo写博客的旅程 段落和换行一个段落的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。如果想要插入换行符&lt;br /&gt;的话，在插入处键入两个以上的空格，然后回车。 标题一共有6级，随着#号增多级数增加123456# 1级标题## 2级标题### 3级标题#### 4级标题##### 5级标题###### 6级标题 2级标题3级标题4级标题5级标题6级标题表格12345表头1 | 表头2 | 表头3---|---|---1.1 | 2.1 | 3.11.2 | 2.2 | 3.21.3 | 2.3 | 3.3 表头1 表头2 表头3 1.1 2.1 3.1 1.2 2.2 3.2 1.3 2.3 3.3 列表无序列表123* 以星号开头+ 以加号开头- 以减号开头 以星号开头 以加号开头 以减号开头 有序列表1231. 火龙窝2. 小火龙3. 火龙果 火龙窝 小火龙 火龙果 强调斜体12*斜体*_斜体_ 斜体_斜体_ 加粗12**加粗**__加粗__ 加粗加粗 删除1~~删除~~ 删除 代码短代码1use `printf()` use printf() 长代码123```c++#include &lt;iostream&gt;``` 1#include &lt;iostream&gt; 引用12345678910111213141516171819202122&gt; 开头加 ‘&gt;’，即可&gt; &gt; 引用中仍然可以使用强调&gt; __haha__&gt; &gt; 引用中仍然可以使用列表&gt; * yes&gt; * no&gt; &gt; 引用中仍然可以使用引用&gt; &gt; haha&gt; &gt; huhu&gt; &gt; 引用中仍然可以使用标题&gt; ## 引用中的标题&gt; &gt; 引用中仍然可以使用代码&gt; `hello`&gt; ```#include &lt;iostream&gt;```&gt; 开头加 ‘&gt;’，即可 引用中仍然可以使用强调haha 引用中仍然可以使用列表 yes no 引用中仍然可以使用引用 hahahuhu 引用中仍然可以使用标题 引用中的标题引用中仍然可以使用代码hello1#include &lt;iostream&gt; 图片与链接图片123![Alt text](/path/to/img.jpg)![Alt text](/path/to/img.jpg "Optional title") 链接1[链接名](http://lmnsyunhao.github.io "标题是鼠标悬停在链接名上是弹出栏的名字") 链接名 水平线12345* * *********- - ---------------------------------------- 转义Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号123456789101112\ 反斜线` 反引号* 星号_ 底线&#123;&#125; 花括号[] 方括号() 括弧# 井字号+ 加号- 减号. 英文句点! 惊叹号]]></content>
      <categories>
        <category>Language</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
