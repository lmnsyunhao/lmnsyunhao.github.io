<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[npm 指令学习笔记]]></title>
    <url>%2F2018%2F06%2F30%2Fnpm-instruction-learning-note%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>NodeJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo NexT 添加 DaoVoice 在线聊天]]></title>
    <url>%2F2018%2F06%2F30%2Fhexo-next-add-daovoice-contact%2F</url>
    <content type="text"><![CDATA[DaoVoice一个实时在线沟通的工具。可以及时解答客户的问题。还能够绑定微信。具体请看一分钟了解DaoVoice 新建应用首先现在DaoVoice上注册一个账号。打开DaoCloud首页。找到DaoVoice服务，然后点击，如下图：然后再下边的界面中选择注册，或登录。如果是新注册的用户，那么注册之后，就会看到下面的这个界面。这个是让你添加一个应用的，填写你的公司名称，你的电话号码，然后点击保存就好了如果你是老用户了，找不到上边这个界面了，在下面的位置可以找到，找到之后向上边设置一下。 安装到网站如下图，点击应用设置，安装到网站，JS，仅匿名用户，然后找到下面两个代码。打开博客的主题目录下的文件/themes/next/layout/_custom/head.swig。然后粘贴成下面这样：123456789101112&#123;#Custom head.#&#125;&#123;% if config.daovoice %&#125; &lt;script&gt; (function(i,s,o,g,r,a,m)&#123;i[&quot;DaoVoiceObject&quot;]=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset=&quot;utf-8&quot;;m.parentNode.insertBefore(a,m)&#125;)(window,document,&quot;script&quot;,(&apos;https:&apos; == document.location.protocol ? &apos;https:&apos; : &apos;http:&apos;) + &quot;//widget.daovoice.io/widget/&#123;&#123;config.daovoice_app_id&#125;&#125;.js&quot;,&quot;daovoice&quot;) daovoice(&apos;init&apos;, &#123; app_id: &quot;&#123;&#123;config.daovoice_app_id&#125;&#125;&quot; &#125;); daovoice(&apos;update&apos;); &lt;/script&gt;&#123;% endif %&#125; 注意app_id后边的那个要换一下，然后那个网址后边哪儿也要换成变量。就是上边图片中，那两段代码中被黑条盖住的部分要替换那个被黑条盖住的部分就是你的app_id。打开博客配置文件然后增加下面内容：123# 实时联系daovoice: truedaovoice_app_id: 你的app_id 将你的app_id替换成黑条盖住的部分就行了。然后执行hexo cl &amp; hexo g &amp; hexo d，之后ping一下，如下图如果成功了，现在就已经接入了，网站右下角就应该有一个悬浮钮了。 微信绑定绑定到微信，可以实时处理消息，回复消息。扫码之后，就能看到下面的绑定成功。 设置悬浮钮如果悬浮钮遮挡其他元素了，或者是想设置悬浮钮的颜色，什么的。点击应用设置，聊天设置，如下图：在这里，我们可以设置欢迎语，按钮的颜色，位置什么的。 新消息指派设置一下新消息指派，点击应用设置，新消息设置，默认指派选择自己。如下图 费用问题这个应用是免费的。不过也有付费版。你的网站用户数小于5000的时候，就是免费的。具体的需不需要付费，请看资费情况 用户手册其他问题，请自行查阅官方用户手册]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
        <tag>DaoVoice</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo NexT 站内搜索 站点统计 RSS订阅 字数统计 阅读时长 进度条 图片放大 canvas背景 功能配置]]></title>
    <url>%2F2018%2F06%2F29%2Fhexo-next-function-setting%2F</url>
    <content type="text"><![CDATA[Hexo的NexT主题的一些功能如何开启。如下：站内搜索功能、站点访客量、站点阅读量、站点总字数、站点总阅读时长、RSS订阅、博文字数、博文阅读时长、博文阅读量、优雅的进度条、点击博文内图片放大、canvas背景 站内搜索NexT支持集成Swiftype、微搜索、Local Search和Algolia。Swiftype、微搜索我没具体了解。Algolia界面很优雅，因为这个是第三方的，每次都得hexo algolia来上传一下，多了一步操作。而且，Algolia有试用期，试用期过后就降为免费版了，免费版的搜索时不能对文章内容进行搜索。所以，我没用这个。我用的是Local Search，这个是每次hexo g的时候都会产生一个search.xml的文件，搜索就是从这个文件里搜索，这个比较方便。而且支持文章内容搜索。下面说Local Search怎么配置。先打开博客根目录，安装hexo-generator-searchdb1npm install hexo-generator-searchdb --save 然后去博客配置文件中加入下面的12345search: path: search.xml field: post format: html limit: 10000 解释一下各个字段含义：摘自官方 path - file path. By default is search.xml . If the file extension is .json, the output format will be JSON. Otherwise XML format file will be exported. field - the search scope you want to search, you can chose: post (Default) - will only covers all the posts of your blog. page - will only covers all the pages of your blog. all - will covers all the posts and pages of your blog. format - the form of the page contents, works with xml mode, options are: html (Default) - original html string being minified. raw - markdown text of each posts or pages. excerpt - only collect excerpt. more - act as you think. limit - define the maximum number of posts being indexed, always prefer the newest. limit就是xml中的包含的最大论文篇数。去主题配置文件中，打开local search。enable设置true1234567891011# Local search# Dependencies: https://github.com/theme-next/hexo-generator-searchdblocal_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1 # unescape html strings to the readable one unescape: false 站点访客量 站点阅读量这个用不蒜子，去主题配置文件中打开busuanzi就好。12345678910# Show Views/Visitors of the website/page with busuanzi.# Get more information on http://ibruce.info/2015/04/04/busuanzi/busuanzi_count: enable: true total_visitors: true total_visitors_icon: user total_views: true total_views_icon: eye post_views: false post_views_icon: eye 特别说明一下，不蒜子就是统计每个url访问了多少次。虽然能够统计单片博文的访问量，但是没办法在主页显示某个博文的访问量，只有点进去这个博文，才能显示访问量。所以单篇博文访问量我们用leancloud，详见Hexo NexT 主题 LeanCloud 插件安装教程 站点总字数 站点总阅读时长 博文字数 博文阅读时长首先安装hexo-symbols-count-time，在博客根目录输入，1npm install hexo-symbols-count-time --save 修改博客配置文件，打开博客配置文件，添加如下内容。12345symbols_count_time: symbols: true time: true total_symbols: true total_time: true symbols是博文字数，time是博文阅读时长，total_symbols是站点总字数，total_time是站点总阅读时长。检查一下主题配置文件:12345678# Post wordcount display settings# Dependencies: https://github.com/theme-next/hexo-symbols-count-timesymbols_count_time: separated_meta: true item_text_post: true item_text_total: false awl: 4 wpm: 275 awl是平均字长度average word length，默认是4，wpm是阅读速度，word per minute。 RSS订阅打开主题配置文件，找到如下：1234# Set rss to false to disable feed link.# Leave rss as empty to use site's feed link, and install hexo-generator-feed: `npm install hexo-generator-feed --save`.# Set rss to specific value if you have burned your feed already.rss: 如果你自己生成了rss，那么上边就填地址，否则的话留空。安装hexo-generator-feed，在博客根目录输入，1npm install hexo-generator-feed --save 每次hexo g的时候就会生成了atom.xml。 博文阅读量不蒜子统计每个url访问了多少次。虽然能够统计单篇博文的访问量，但是没办法在主页显示某个博文的访问量，只有点进去这个博文，才能显示访问量。所以单篇博文访问量我们用leancloud，详见Hexo NexT 主题 LeanCloud 插件安装教程 优雅的进度条NexT主题里面能够使用Pace来设置优雅的进度条，可以看下Demo首先需要git clone一下，打开NexT主题目录下的source\lib目录，执行下面操作1git clone https://github.com/theme-next/theme-next-pace pace 然后配置一下主题配置文件将pace设置成true。1234567891011121314151617181920# Progress bar in the top during page loading.# Dependencies: https://github.com/theme-next/theme-next-pacepace: true# Themes list:#pace-theme-big-counter#pace-theme-bounce#pace-theme-barber-shop#pace-theme-center-atom#pace-theme-center-circle#pace-theme-center-radar#pace-theme-center-simple#pace-theme-corner-indicator#pace-theme-fill-left#pace-theme-flash#pace-theme-loading-bar#pace-theme-mac-osx#pace-theme-minimal# For example# pace_theme: pace-theme-center-simplepace_theme: pace-theme-corner-indicator 可以从上面的那些里面选一个喜欢的主题，写在pace_theme那里。 图片放大使用fancybox来让博文里面的图片能够点击放大查看。首先需要git clone一下，打开NexT主题目录下的source\lib目录注意，如果这个目录下有fancybox文件夹，需要先删了才行。然后执行下面操作：1git clone https://github.com/theme-next/theme-next-fancybox3 fancybox 然后配置一下主题配置文件将fancybox设置成true。12345# Fancybox. There is support for old version 2 and new version 3.# Please, choose only any one variant, do not need to install both.# For install 2.x: https://github.com/theme-next/theme-next-fancybox# For install 3.x: https://github.com/theme-next/theme-next-fancybox3fancybox: true canvas背景设置博客背景之后，就能跟我这个背景一样了。首先需要git clone一下，打开NexT主题目录下的source\lib目录，执行下面操作：12git clone https://github.com/theme-next/theme-next-canvas-nest canvas-nestgit clone https://github.com/theme-next/theme-next-three three 然后配置一下主题配置文件下面四个选一个true，其他设置成false123456789101112# Canvas-nest# Dependencies: https://github.com/theme-next/theme-next-canvas-nestcanvas_nest: false# JavaScript 3D library.# Dependencies: https://github.com/theme-next/theme-next-three# three_wavesthree_waves: false# canvas_linescanvas_lines: true# canvas_spherecanvas_sphere: false]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 警告错误 LF will be replaced by CRLF]]></title>
    <url>%2F2018%2F06%2F29%2Fgit-warning-lf-replaced-by-crlf%2F</url>
    <content type="text"><![CDATA[症状每次使用git的时候，都会出现这个问题：12warning: LF will be replaced by CRLF in tags/组合数学/index.html.The file will have its original line endings in your working directory. 一报一大溜，真的烦。 原因windows中的换行符为 CRLF，而在Linux下的换行符为LF。所以会给换过来。就是说，我们在工作区的文件中，有的是以LF作为换行符结尾的，然后在添加到暂存区的时候，git会暂存区的LF换成CRLF。然后统一提交时候，都是CRLF换行了。 Hexo请看这里如果是Hexo d的时候出的这个问题。我就是这个时候出的那么直接禁用转换就好了。不需要删除.git什么的。因为hexo d的时候，他会在.deploy_git文件夹内自动从新生成.git1git config –global core.autocrlf false 解决方法输入下面命令禁用转换。1git config –global core.autocrlf false 但是禁用转换之后，必须得把.git删了，然后重新git init一下才行。所以记得保存一下本地的修改什么的。或者push一下。然后：12rm -rf .gitgit init 到这就行了。我不太确定是不是只有windows上边才会有这种问题。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo-leancloud-counter-security 插件 Too many requests 错误]]></title>
    <url>%2F2018%2F06%2F29%2Fhexo-leancloud-counter-security-too-many-requests-error%2F</url>
    <content type="text"><![CDATA[症状如果你懒得看解释的话，直接去看修改代码一节。每次进行hexo d的时候会概率性的出现如下错误：12345678910ERROR Too many requests. [429 POST https://xtppdvlr.api.lncld.net/1.1/classes/Counter]Error: Too many requests. [429 POST https://xtppdvlr.api.lncld.net/1.1/classes/Counter] at E:\code\blog\node_modules\leancloud-storage\dist\node\request.js:163:17 at tryCatch (E:\code\blog\node_modules\es6-promise\dist\es6-promise.js:410:12) at invokeCallback (E:\code\blog\node_modules\es6-promise\dist\es6-promise.js:425:13) at publish (E:\code\blog\node_modules\es6-promise\dist\es6-promise.js:399:7) at publishRejection (E:\code\blog\node_modules\es6-promise\dist\es6-promise.js:340:3) at flush (E:\code\blog\node_modules\es6-promise\dist\es6-promise.js:128:5) at _combinedTickCallback (internal/process/next_tick.js:131:7) at process._tickCallback (internal/process/next_tick.js:180:9) 官方解释如下： 信息 - Too many requests.含义 - 超过应用的流控限制，即超过每个应用同一时刻最多可使用的工作线程数，或者说同一时刻最多可以同时处理的数据请求。通过 控制台 &gt; 存储 &gt; API 统计 &gt; API 性能 &gt; 总览 可以查看应用产生的请求统计数据，如平均工作线程、平均响应时间等。使用 LeanCloud 商用版或企业版 的用户，如有需要，可以联系我们来调整工作线程数。 原因我查看了源代码，node_modules\hexo-leancloud-counter-security\index.js这个就是源代码。发现每次进行hexo d的时候，他对每个博文的title和url，向leancloud发送一次查询请求，如果发现leancloud那边儿没有该条记录的话，那么再发送一条插入请求。原逻辑如下：12345678910111213141516171819_.forEach(urls, function (x) &#123; var query = new AV.Query('Counter'); query.equalTo('url', x.url); query.count().then(function (count) &#123; if (count === 0) &#123; var counter = new Counter(); counter.set('url', x.url); counter.set('title', x.title); counter.set('time', 0); counter.save().then(function (obj) &#123; log.info(x.title + ' is saved as: ' + obj.id); &#125;, function (error) &#123; log.error(error); &#125;); &#125; &#125;, function (error) &#123; log.error(error); &#125;);&#125;); 也就是说，每一次hexo d的时候最少的查询次数等于你的博文个数。如果你的leancloud的应用的处理能力不够强大的时候，对于这种高强度的请求，当然会出现Too Many Requests的错误代码。 改进思路我们要做的就是较少不必要的请求咯。本地记录一个title和url的json数组，每次查询这个数组，看看哪些是真正的需要查询的，然后再去查询leancloud。其实可以这样理解，这个本地的数组存储就是leancloud的远程数据库表。因为筛除了一些记录，所以每次hexo d时的请求数量仅仅是相比上一次hexo d时候的增量。 修改代码如果你遇到了问题，看看问题解决一节。修改的是node_modules\hexo-leancloud-counter-security\index.js这个文件hexo-leancloud-counter-security版本是1.3.2一共修改下面几处，在代码中已经做了标记。代码70-84代码87-102代码113-117代码120-123代码126-132代码135-138代码140-142代码225-268123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268'use strict';var _regenerator = require('babel-runtime/regenerator');var _regenerator2 = _interopRequireDefault(_regenerator);var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);var _stringify = require('babel-runtime/core-js/json/stringify');var _stringify2 = _interopRequireDefault(_stringify);var sync = function () &#123; var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee() &#123; var log, config, APP_ID, APP_KEY, publicDir, UrlsFile, urls, currentUser, userName, passWord, Counter; return _regenerator2.default.wrap(function _callee$(_context) &#123; while (1) &#123; switch (_context.prev = _context.next) &#123; case 0: log = this.log; config = this.config; if (!config.leancloud_counter_security.enable_sync) &#123; _context.next = 19; break; &#125; APP_ID = config.leancloud_counter_security.app_id; APP_KEY = config.leancloud_counter_security.app_key; publicDir = this.public_dir; UrlsFile = pathFn.join(publicDir, 'leancloud_counter_security_urls.json'); urls = JSON.parse(fs.readFileSync(UrlsFile, 'utf8')); AV.init(&#123; appId: APP_ID, appKey: APP_KEY &#125;); currentUser = AV.User.current(); if (currentUser) &#123; _context.next = 16; break; &#125; userName = config.leancloud_counter_security.username; passWord = config.leancloud_counter_security.password; if (!userName) &#123; userName = readlineSync.question('Enter your username: '); passWord = readlineSync.question('Enter your password: ', &#123; hideEchoBack: true &#125;); &#125; else if (!passWord) &#123; passWord = readlineSync.question('Enter your password: ', &#123; hideEchoBack: true &#125;); &#125; _context.next = 16; return AV.User.logIn(userName, passWord).then(function (loginedUser) &#123; log.info('Logined as: ' + loginedUser.getUsername()); &#125;, function (error) &#123; log.error(error); &#125;); case 16: log.info('Now syncing your posts list to leancloud counter...'); Counter = AV.Object.extend('Counter'); //----add---- urls.sort(cmp); var memoFile = pathFn.join(publicDir, "leancloud_memo"); if(!fs.existsSync(memoFile))&#123; fs.writeFileSync(memoFile, "[\n]"); &#125; var memoData = fs.readFileSync(memoFile, "utf-8").split("\n"); var memoIdx = 1; var newData = []; var cnt = 0; var limit = 0; var env = this; //----end---- _.forEach(urls, function (x) &#123; //----add---- var y = &#123;&#125;; y.title = ""; y.url = ""; var flag = false; while(true)&#123; if(memoData[memoIdx] == ']') break; y = JSON.parse(memoData[memoIdx].substring(0, memoData[memoIdx].length-1)); if(y.url &gt;= x.url) break; memoIdx++; &#125; if(y.url != x.url || y.title != x.title) &#123; log.info("Dealing with record of " + x.title); limit++; //----end---- var query = new AV.Query('Counter'); query.equalTo('url', x.url); query.count().then(function (count) &#123; if (count === 0) &#123; var counter = new Counter(); counter.set('url', x.url); counter.set('title', x.title); counter.set('time', 0); counter.save().then(function (obj) &#123; log.info(x.title + ' is saved as: ' + obj.id); //----add---- newData.push(x); cnt++; postOperation(env, cnt, limit, newData, memoData); //----end---- &#125;, function (error) &#123; log.error(error); //----add---- cnt++; postOperation(env, cnt, limit, newData, memoData); //----end---- &#125;); &#125; //----add---- else&#123; newData.push(x); cnt++; postOperation(env, cnt, limit, newData, memoData); &#125; //----end---- &#125;, function (error) &#123; log.error(error); //----add---- cnt++; postOperation(env, cnt, limit, newData, memoData); //----end---- &#125;); //----add---- &#125; //----end---- &#125;); case 19: case 'end': return _context.stop(); &#125; &#125; &#125;, _callee, this); &#125;)); return function sync() &#123; return _ref.apply(this, arguments); &#125;;&#125;();function _interopRequireDefault(obj) &#123; return obj &amp;&amp; obj.__esModule ? obj : &#123; default: obj &#125;; &#125;var AV = require('leancloud-storage');var _ = require('lodash');var readlineSync = require('readline-sync');var packageInfo = require('./package.json');var pathFn = require('path');var fs = require('fs');function generate_post_list(locals) &#123; var config = this.config; if (config.leancloud_counter_security.enable_sync) &#123; var urlsPath = 'leancloud_counter_security_urls.json'; var urls = [].concat(locals.posts.toArray()).filter(function (x) &#123; return x.published; &#125;).map(function (x) &#123; return &#123; title: x.title, url: '/' + x.path &#125;; &#125;); return &#123; path: urlsPath, data: (0, _stringify2.default)(urls) &#125;; &#125;&#125;hexo.extend.generator.register('leancloud_counter_security_generator', generate_post_list);hexo.extend.deployer.register('leancloud_counter_security_sync', sync);var commandOptions = &#123; desc: packageInfo.description, usage: ' &lt;argument&gt;', 'arguments': [&#123; 'name': 'register | r &lt;username&gt; &lt;password&gt;', 'desc': 'Register a new user.' &#125;]&#125;;function commandFunc(args) &#123; var log = this.log; var config = this.config; if (args._.length !== 3) &#123; log.error('Too Few or Many Arguments.'); &#125; else if (args._[0] === 'register' || args._[0] === 'r') &#123; var APP_ID = config.leancloud_counter_security.app_id; var APP_KEY = config.leancloud_counter_security.app_key; AV.init(&#123; appId: APP_ID, appKey: APP_KEY &#125;); var user = new AV.User(); user.setUsername(String(args._[1])); user.setPassword(String(args._[2])); user.signUp().then(function (loginedUser) &#123; log.info(loginedUser.getUsername() + ' is successfully signed up'); &#125;, function (error) &#123; log.error(error); &#125;); &#125; else &#123; log.error('Unknown Command.'); &#125;&#125;hexo.extend.console.register('lc-counter', 'hexo-leancloud-counter-security', commandOptions, commandFunc);//----add----function cmp(x, y)&#123; if(x.url &lt; y.url) return -1; else if(x.url == y.url) return 0; else return 1;&#125;var postOperation = function (env, cnt, limit, newData, memoData)&#123; if(cnt == limit)&#123; var log = env.log; newData.sort(cmp); var sourceDir = env.source_dir; var publicDir = env.public_dir; var memoFile = pathFn.join(sourceDir, "leancloud_memo"); fs.writeFileSync(memoFile, "[\n"); var memoIdx = 1; for(var i = 0; newData[i]; i++)&#123; while(true)&#123; if(memoData[memoIdx] == ']') break; var y = JSON.parse(memoData[memoIdx].substring(0, memoData[memoIdx].length-1)); if(y.url &gt; newData[i].url) break; fs.writeFileSync(memoFile, memoData[memoIdx] + "\n", &#123;'flag':'a'&#125;); memoIdx++; &#125; fs.writeFileSync(memoFile, "&#123;\"title\":\"" + newData[i].title + "\",\"url\":\"" + newData[i].url + "\"&#125;,\n", &#123;'flag':'a'&#125;); &#125; while(memoData[memoIdx] != ']')&#123; fs.writeFileSync(memoFile, memoData[memoIdx] + "\n", &#123;'flag':'a'&#125;); memoIdx++; &#125; fs.writeFileSync(memoFile, memoData[memoIdx], &#123;'flag':'a'&#125;); var srcFile = pathFn.join(sourceDir, "leancloud_memo"); var destFile = pathFn.join(publicDir, "leancloud_memo"); var readStream = fs.createReadStream(srcFile); var writeStream = fs.createWriteStream(destFile); readStream.pipe(writeStream); console.log("leancloud_memo successfully updated."); &#125;&#125; 关键逻辑维护memoData和urls数组有序，能够在O(2n)的复杂度内判断出有哪些博文（包括改了题目的，改了文件名的）不在表中。最后的memoData和newData也是有序的，产生的新的文件也是有序的。详见代码，不做过多解释。 额外代价分析一下，额外引入的代价。时间上的代价： 对urls数组进行排序。O(nlogn) urls数组和memoData数组比较以确定某个记录需要向leancloud查询。O(2n) 排序newData数组。O(nlogn) 将memoData和newData数组整合成一个新的数组。O(2n) 将memoData字符串split成数组一次。 读取memoData一次。 写memoData n次。 拷贝memoData一次。 空间上的代价： 引入newData数组，O(n) 引入memoData数组，O(n) 引入一个文件leancloud_memo n是博文的数量，一般的话假设有1万篇，这个额外代价感觉还可以。 最后一行不加注释为什么不在上面代码最后艺一行加上//—-end—-？因为加上注释以后会报错。报错如下：12345678910111213141516171819202122232425ERROR Plugin load failed: hexo-leancloud-counter-securityE:\code\blog\node_modules\hexo-leancloud-counter-security\index.js:213&#125;^SyntaxError: Unexpected end of input at createScript (vm.js:80:10) at Object.runInThisContext (vm.js:139:10) at fs.readFile.then.script (E:\code\blog\node_modules\hexo\lib\hexo\index.js:230:19) at tryCatcher (E:\code\blog\node_modules\bluebird\js\release\util.js:16:23) at Promise._settlePromiseFromHandler (E:\code\blog\node_modules\bluebird\js\release\promise.js:512:31) at Promise._settlePromise (E:\code\blog\node_modules\bluebird\js\release\promise.js:569:18) at Promise._settlePromise0 (E:\code\blog\node_modules\bluebird\js\release\promise.js:614:10) at Promise._settlePromises (E:\code\blog\node_modules\bluebird\js\release\promise.js:693:18) at Promise._fulfill (E:\code\blog\node_modules\bluebird\js\release\promise.js:638:18) at Promise._resolveCallback (E:\code\blog\node_modules\bluebird\js\release\promise.js:432:57) at Promise._settlePromiseFromHandler (E:\code\blog\node_modules\bluebird\js\release\promise.js:524:17) at Promise._settlePromise (E:\code\blog\node_modules\bluebird\js\release\promise.js:569:18) at Promise._settlePromise0 (E:\code\blog\node_modules\bluebird\js\release\promise.js:614:10) at Promise._settlePromises (E:\code\blog\node_modules\bluebird\js\release\promise.js:693:18) at Promise._fulfill (E:\code\blog\node_modules\bluebird\js\release\promise.js:638:18) at E:\code\blog\node_modules\bluebird\js\release\nodeback.js:42:21 at E:\code\blog\node_modules\graceful-fs\graceful-fs.js:78:16 at FSReqWrap.readFileAfterClose [as oncomplete] (fs.js:511:3)ERROR Deployer not found: leancloud_counter_security_sync 问题解决如果你在hexo d的时候，发现leancloud那边儿没有添加上记录。排除了各种错误之后，还是没有的话。你可以把source文件夹下的leancloud_memo文件删除，然后重新hexo clean &amp; hexo g &amp; hexo d就好了。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>LeanCloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo NexT 主题 LeanCloud 插件安装教程]]></title>
    <url>%2F2018%2F06%2F27%2Fhexo-leancloud-plugin-installation-tutor%2F</url>
    <content type="text"><![CDATA[LeanCloudLeanCloud能够给每篇博客统计访问量的工具。首先注册，并登陆LeanCloud。注意：登陆密码要求还得有大写英文字母，小写英文字母，还有数字。 膜拜大佬这篇博客是学习两位大佬，DoubleMine和leaferx，的博文之后写的 应用配置进入控制台后，我们先创建一个应用。点击创建应用然后弹出如下窗口：起名字，选择开发版，之后点击创建按钮创建完之后，我们看到下面这样。然后点击右上角的设置进入之后，我们点击存储，创建Class，弹出的对话框中名字要写Counter，必须写Counter是因为需要和NexT主题兼容。然后ACL权限选择无限制，不然容易统计次数不正常。最后点击创建Class按钮。创建Class的时候容易出现这个问题，如下图，刷新几次，就好了。现在获取应用ID和应用Key。设置，应用key。 主题配置我们把LeanCloud的应用ID和应用Key写到主题配置文件中了，注意此时是主题的配置文件config.yml，找到文件中对应位置，并修改成如下：1234567891011# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.leancloud_visitors: enable: true app_id: 填写 app_key: 填写 # Dependencies: https://github.com/theme-next/hexo-leancloud-counter-security # If you don't care about security in lc counter and just want to use it directly # (without hexo-leancloud-counter-security plugin), set the `security` to `false`. security: true betterPerformance: true enable写成true。把app_id和app_key填上去。然后注意下面，如果没有安装hexo-leancloud-counter-security插件的话，security就填写false。betterPerformance是能够让阅读次数加载更快一些，但是显示的实际数值可能不够准确。配置完了之后，hexo d一下，然后看看是否生效。之前的话应该就能生效了，但是现在好像不行了。如果不能生效请继续看。 Counter类未初始化问题如果你看到这里了，应该就是发现，计数功能无效。可能会出现下面的问题。Counter类未初始化。然后它提示我们看F12的Console，显示信息如下： hexo-leancloud-counter-security插件的安装与配置打开主题配置文件，确保刚刚的那个security已经设置为true。如下：1234567891011# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.leancloud_visitors: enable: true app_id: 填写 app_key: 填写 # Dependencies: https://github.com/theme-next/hexo-leancloud-counter-security # If you don't care about security in lc counter and just want to use it directly # (without hexo-leancloud-counter-security plugin), set the `security` to `false`. security: true betterPerformance: true 打开CMD，然后切换到博客的根目录。执行下面命令，以安装hexo-leancloud-counter-security插件1npm install hexo-leancloud-counter-security --save 等待安装结束之后，我们注册一个用户。命令如下：1hexo lc-counter r 用户名 密码 用户名，密码两处用你自己起好的名字和密码替换。不用和LeanCloud的登陆名和登陆密码一样。这个用于deploy的时候输入。然后打开博客配置文件。注意是博客的配置文件。123456leancloud_counter_security: enable_sync: true app_id: &lt;&lt;your app id&gt;&gt; app_key: &lt;&lt;your app key&gt; username: &lt;&lt;your username&gt;&gt; #如留空则将在部署时询问 password: &lt;&lt;your password&gt;&gt; #建议留空以保证安全性，如留空则将在部署时询问 然后在博客配置文件中找到deploy:，在deploy下边添加一个。如下：12deploy: - type: leancloud_counter_security_sync 之后去LeanCloud查看_User表中是否已经添加刚才的用户，点击存储，_User，看是否多一条记录，如下：然后对Counter表设置权限，点击存储，Counter，其他，权限设置。如下：然后弹出对话框，点击add_fields，指定用户，输入刚才用户，点击添加，添加成功能够看到两处不同，用户ID已经上去了。接下来，我们同样对create进行指定用户。然后，对delete指定用户，这个注意，不添加任何用户。然后关闭。这就设置好了。每次运行hexo d的时候，会扫描所有的博客，对于新的博客，Counter表里没有记录的时候，会新建一条记录。如果博客的配置文件中username和password那块儿留空的话，hexo d的时候需要手动输入密码。然后我们hexo d一下。看看效果。 同时部署git和leancloud的问题如果没出现这个问题，就跳过这一节如果你的博客配置文件中的deploy已经有一个git的了，那么可能会出现下边的问题。12345678910111213141516171819202122232425262728FATAL bad indentation of a mapping entry at line 86, column 3: - type: leancloud_counter_securi ... ^YAMLException: bad indentation of a mapping entry at line 86, column 3: - type: leancloud_counter_securi ... ^ at generateError (E:\code\blog\node_modules\js-yaml\lib\js-yaml\loader.js:165:10) at throwError (E:\code\blog\node_modules\js-yaml\lib\js-yaml\loader.js:171:9) at readBlockMapping (E:\code\blog\node_modules\js-yaml\lib\js-yaml\loader.js:1080:7) at composeNode (E:\code\blog\node_modules\js-yaml\lib\js-yaml\loader.js:1332:12) at readDocument (E:\code\blog\node_modules\js-yaml\lib\js-yaml\loader.js:1492:3) at loadDocuments (E:\code\blog\node_modules\js-yaml\lib\js-yaml\loader.js:1548:5) at Object.load (E:\code\blog\node_modules\js-yaml\lib\js-yaml\loader.js:1569:19) at Hexo.yamlHelper (E:\code\blog\node_modules\hexo\lib\plugins\renderer\yaml.js:7:15) at Hexo.tryCatcher (E:\code\blog\node_modules\bluebird\js\release\util.js:16:23) at Hexo.&lt;anonymous&gt; (E:\code\blog\node_modules\bluebird\js\release\method.js:15:34) at Promise.then.text (E:\code\blog\node_modules\hexo\lib\hexo\render.js:61:21) at tryCatcher (E:\code\blog\node_modules\bluebird\js\release\util.js:16:23) at Promise._settlePromiseFromHandler (E:\code\blog\node_modules\bluebird\js\release\promise.js:512:31) at Promise._settlePromise (E:\code\blog\node_modules\bluebird\js\release\promise.js:569:18) at Promise._settlePromise0 (E:\code\blog\node_modules\bluebird\js\release\promise.js:614:10) at Promise._settlePromises (E:\code\blog\node_modules\bluebird\js\release\promise.js:693:18) at Async._drainQueue (E:\code\blog\node_modules\bluebird\js\release\async.js:133:16) at Async._drainQueues (E:\code\blog\node_modules\bluebird\js\release\async.js:143:10) at Immediate.Async.drainQueues (E:\code\blog\node_modules\bluebird\js\release\async.js:17:14) at runCallback (timers.js:794:20) at tryOnImmediate (timers.js:752:5) at processImmediate [as _immediateCallback] (timers.js:729:5) 12345678910111213141516171819202122232425262728FATAL duplicated mapping key at line 86, column 3: type: leancloud_counter_security ... ^YAMLException: duplicated mapping key at line 86, column 3: type: leancloud_counter_security ... ^ at generateError (E:\code\blog\node_modules\js-yaml\lib\js-yaml\loader.js:165:10) at throwError (E:\code\blog\node_modules\js-yaml\lib\js-yaml\loader.js:171:9) at storeMappingPair (E:\code\blog\node_modules\js-yaml\lib\js-yaml\loader.js:308:7) at readBlockMapping (E:\code\blog\node_modules\js-yaml\lib\js-yaml\loader.js:1071:9) at composeNode (E:\code\blog\node_modules\js-yaml\lib\js-yaml\loader.js:1332:12) at readBlockMapping (E:\code\blog\node_modules\js-yaml\lib\js-yaml\loader.js:1062:11) at composeNode (E:\code\blog\node_modules\js-yaml\lib\js-yaml\loader.js:1332:12) at readDocument (E:\code\blog\node_modules\js-yaml\lib\js-yaml\loader.js:1492:3) at loadDocuments (E:\code\blog\node_modules\js-yaml\lib\js-yaml\loader.js:1548:5) at Object.load (E:\code\blog\node_modules\js-yaml\lib\js-yaml\loader.js:1569:19) at Hexo.yamlHelper (E:\code\blog\node_modules\hexo\lib\plugins\renderer\yaml.js:7:15) at Hexo.tryCatcher (E:\code\blog\node_modules\bluebird\js\release\util.js:16:23) at Hexo.&lt;anonymous&gt; (E:\code\blog\node_modules\bluebird\js\release\method.js:15:34) at Promise.then.text (E:\code\blog\node_modules\hexo\lib\hexo\render.js:61:21) at tryCatcher (E:\code\blog\node_modules\bluebird\js\release\util.js:16:23) at Promise._settlePromiseFromHandler (E:\code\blog\node_modules\bluebird\js\release\promise.js:512:31) at Promise._settlePromise (E:\code\blog\node_modules\bluebird\js\release\promise.js:569:18) at Promise._settlePromise0 (E:\code\blog\node_modules\bluebird\js\release\promise.js:614:10) at Promise._settlePromises (E:\code\blog\node_modules\bluebird\js\release\promise.js:693:18) at Async._drainQueue (E:\code\blog\node_modules\bluebird\js\release\async.js:133:16) at Async._drainQueues (E:\code\blog\node_modules\bluebird\js\release\async.js:143:10) at Immediate.Async.drainQueues (E:\code\blog\node_modules\bluebird\js\release\async.js:17:14) 这个问题，很简单，就是博客配置文件中deploy的那个位置，没写明白。如何让git和leancloud同时部署呢，如下：1234567deploy: - type: git repository: git@github.com:lmnsyunhao/lmnsyunhao.github.io.git branch: master - type: leancloud_counter_security_sync 这样写就行了。具体为啥这样写，简单学习一下YAML语法就好了。不做赘述 部署过程中leancloud过多请求问题如果没出现这个问题就跳过这一节。deploy d的过程中，还可能出现这个问题。看描述是请求过多。如下：12345678910ERROR Too many requests. [429 POST https://xtppdvlr.api.lncld.net/1.1/classes/Counter]Error: Too many requests. [429 POST https://xtppdvlr.api.lncld.net/1.1/classes/Counter] at E:\code\blog\node_modules\leancloud-storage\dist\node\request.js:163:17 at tryCatch (E:\code\blog\node_modules\es6-promise\dist\es6-promise.js:410:12) at invokeCallback (E:\code\blog\node_modules\es6-promise\dist\es6-promise.js:425:13) at publish (E:\code\blog\node_modules\es6-promise\dist\es6-promise.js:399:7) at publishRejection (E:\code\blog\node_modules\es6-promise\dist\es6-promise.js:340:3) at flush (E:\code\blog\node_modules\es6-promise\dist\es6-promise.js:128:5) at _combinedTickCallback (internal/process/next_tick.js:131:7) at process._tickCallback (internal/process/next_tick.js:180:9) 信息 - Too many requests.含义 - 超过应用的流控限制，即超过每个应用同一时刻最多可使用的工作线程数，或者说同一时刻最多可以同时处理的数据请求。通过 控制台 &gt; 存储 &gt; API 统计 &gt; API 性能 &gt; 总览 可以查看应用产生的请求统计数据，如平均工作线程、平均响应时间等。使用 LeanCloud 商用版或企业版 的用户，如有需要，可以联系我们来调整工作线程数。 以上是LeanCloud官方解释。这个就是你第一次部署的时候，你的博文太多了，leancloud那边儿收不过来。但是慢慢的我发现，在LeanCloud控制台那边儿所有的博文都已经有对应的记录了，但是每次hexo d时候还是报错，那是因为请求太快了。我查看了一下hexo-leancloud-counter-security的源代码，发现源代码中每次请求都会把所有博文的记录逐条查询。所以，我改了改源代码，详见hexo-leancloud-counter-security过多请求错误 查看记录这里能够查看记录。time就是阅读次数。这里可以直接改实现骚操作。title，url和createdAt字段不要乱改，不然容易出现问题。 安全中心保护点击设置，安全中心，Web安全域名。这个保证只有对应域名传过来的才有效，也就是说，别人用你的应用ID和应用Key是无效的。 云引擎保护云引擎保护访客数量不被随意篡改。点击云引擎，部署，在线编辑。然后点击创建函数。弹出的框中，选择Hook，beforeUpdate，Counter，函数内填写如下：12345678var query = new AV.Query("Counter");if (request.object.updatedKeys.indexOf('time') !== -1) &#123; return query.get(request.object.id).then(function (obj) &#123; if (obj.get("time") + 1 !== request.object.get("time")) &#123; throw new AV.Cloud.Error('Invalid update!'); &#125; &#125;)&#125; 然后点击保存。之后，我们能看到已经多了一个函数，然后点击上边的部署。弹出对话框，点击部署等待，直到部署完成，如下：]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>LeanCloud</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo d 时遇到 Host Key Verification Failed 问题]]></title>
    <url>%2F2018%2F06%2F24%2Fhexo-d-host-key-verification-failed-issue%2F</url>
    <content type="text"><![CDATA[症状今天，在hexo d的时候遇到一个奇怪的问题，这个问题之前没出现过。自打win10更新一次以后就有问题了，不知道是不是更新的问题。以下是hexo报的log1234567891011121314151617181920212223On branch masternothing to commit, working tree cleanHost key verification failed.fatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists.FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlError: Host key verification failed.fatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists. at ChildProcess.&lt;anonymous&gt; (E:\code\blog\node_modules\hexo-util\lib\spawn.js:37:17) at emitTwo (events.js:126:13) at ChildProcess.emit (events.js:214:7) at ChildProcess.cp.emit (E:\code\blog\node_modules\cross-spawn\lib\enoent.js:40:29) at maybeClose (internal/child_process.js:925:16) at Socket.stream.socket.on (internal/child_process.js:346:11) at emitOne (events.js:116:13) at Socket.emit (events.js:211:7) at Pipe._handle.close [as _onclose] (net.js:567:12) 大概说的是ssh key认证失败，不能读取远程库。然后我把自己电脑上的rsa_pub重新放到了github上一次，结果还是失败。 解决方法要提前用ssh连一下github，把github的公钥记录在本地的know_hosts里面就好了。具体方法是，在cmd中输入如下命令：1ssh git@github.com 然后输入yes。之后再进行hexo d的时候就没这个问题了。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Hexo</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Do U Need A Ladder ?]]></title>
    <url>%2F2018%2F06%2F20%2Fdo-you-need-a-ladder%2F</url>
    <content type="text"><![CDATA[映射请将本文中所有的“暗影袜子们”替换成如下字眼 安装SS在服务器端操作。我购买的是Digital Ocean的服务器，Ubuntu16.04系统。确认当前是root用户，通过pip安装。1234sudo apt-get updatesudo apt-get install python-pippip install --upgrade pippip install 暗影袜子们 pip无法安装的问题在上边安装的时候，可能会出现下面的问题，如果出现了，就解决一下，没出现当然就不用管这一节。报错如下：1234Traceback (most recent call last): File "/usr/bin/pip", line 9, in &lt;module&gt; from pip import mainImportError: cannot import name main 解决方法是修改/usr/bin/pip文件，改成下面的。123from pip import __main__if __name__ == &apos;__main__&apos;: sys.exit(__main__._main()) 配置IPv4连接在服务器端操作。创建配置文件1vim /etc/暗影袜子们.json json文件中填写，如下12345678910&#123; "server":"服务器ip", "server_port":8388, "local_address": "127.0.0.1", "local_port":1080, "password":"自己设置的密码", "timeout":300, "method":"aes-256-cfb", "fast_open": false&#125; 字段名称 各个字段的含义 Name 解释说明 server 监听的服务器地址 server_port 监听的服务器端口 local_address 本地监听的地址 local_port 本地坚挺的端口 password 登陆用的密码 timeout 按秒计算 method 加密方法 默认是”aes-256-cfb” fast_open 快速打开，TCP_FASTOPEN, 填写true或者false workers number of workers, available on Unix/Linux 大家在设置的时候最好不要弄错了，就想例子中的那样。一个空格最好都不要错，否则容易出莫名其妙的问题。 配置IPv6连接在服务器端操作如果你的服务器有ipv6的公网地址，那么你可以通过ipv6来连接你的VPS。那么配置文件中就如下填写：12345678910&#123; "server":"::", "server_port":8388, "local_address": "127.0.0.1", "local_port":1080, "password":"自己设置的密码", "timeout":300, "method":"aes-256-cfb", "fast_open": false&#125; 就是server字段填::，这么填以后，你可以使用ipv6连接，也可以使用ipv4连接，亲测。 客户端配置在客户端操作客户端点选“添加服务器”，填写“地址”、“端口”、“加密方法”和“密码”即可。其中“端口”、“加密方法”和“密码”与前面设置的服务器配置相同。如果服务器支持IPv4和IPv6双栈，那么客户端实际可以配置两个服务器参数，其仅有“地址”不相同。对于IPv4，填写服务器的IPv4地址；对于IPv6，填写服务器的IPv6地址（末尾不用加/64，也不用写[]） 启动ssserver服务在服务器端操作。1ssserver -c /etc/暗影袜子们.json 输入命令就能够开启ssserver服务了上面的命令是工作在前台的进程。如果想把ssserver放到后台工作。那么用下面的命令启动和停止。12ssserver -c /etc/暗影袜子们.json -d startssserver -c /etc/暗影袜子们.json -d stop 如果你发现你的ssserver不支持-d命令的话，那么就是你安装暗影袜子们时候有问题。重装吧就。 测试连通性为了保险起见，客户端选择IPv4连接服务器。解释一下系统代理模式中的全局模式和PAC模式，PAC就是一个规则，定义了有哪些网站在国内，有哪些网站在国外。如果选择了全局模式，不管访问国内还是国外的网站，都会走VPS代理；而PAC模式，只有在国外的走代理，国内的不走。但是PAC规则更新慢的话，有时候还得调成全局模式。全局模式访问国内网站，比PAC访问国内网站要慢一点，因为走了代理。客户端设置好之后，看是不是能够正常的登上梯子（客户端登陆youtube.com）。如果正常，那么就成功了。设置客户端中服务器为IPv6地址的，同样访问上述网站，若都能很快正常打开，则成功。可以测试一下支不支持IPv6，访问网站IPv6测试 配置systemd开机启动在服务器端操作systemd配置文件一般存在于/lib/systemd/system/和/etc/systemd/system/这两个文件夹下，我们需要在/lib/systemd/system下创建配置文件。如下：如果创建过程中有权限问题，自觉用sudo12cd /lib/systemd/systemvim ssserver.service 文件中写如下内容123456789101112# /lib/systemd/system/ssserver.service[Unit]Description=ssserverAfter=network.target[Service]ExecStart=/usr/local/bin/ssserver -c /etc/暗影袜子们.jsonRestart=on-failure[Install]WantedBy=multi-user.target 创建了文件之后，需要重新加载配置一下。1systemctl daemon-reload 然后试试把刚才创建的ssserver.service启动1systemctl start ssserver.service 如果没报任何信息的话，查看一下状态。1systemctl status ssserver.service 如果显示running的话，那么就是配置成功了，然后设置一下开机启动1systemctl enable ssserver.service 到这里，已经达到目的了，下面是一些有意思的操作，感兴趣的可以看一下。不感兴趣的不看也ok。 配置全局代理+Proxifier配置这个的目的是让VPS和本地间走ipv6流量，然后系统代理模式选择全局代理，也就是说让所有的网络访问都走VPS。这样的话，也就是说所有的网络都走ipv6。这种情况下会有一些问题。有的软件不支持用前面这种形式访问网络。这个时候我们就需要一个叫做Proxifier的软件来给这些软件搞一下，让他们也能正常了。因为都是ipv6，所以就免流量了，而且不用登录校园网，这就是我们要的效果。首先，VPS那边得是ipv6能够访问的，就是配好了上边说的ipv6连接，其次，本地也需要有ipv6的地址。二者缺一不可。然后。配置一下Proxifier。配置方法如下：打开Proxifier，然后Profile，Proxy Servers，点击右侧Add。如下这样添加。点击确定。添加之后如下图：打开，Profile，Proxification Rules。如下设置点击Profile，Name Resolution：如下设置：这个时候，注销校园网络登陆。然后看看行不行？如果qq能正常使用，说明大功告成了。下次再使用的时候，ipv6连接+Proxifier都打开，就能够免流量了。我用的是有线连接的校园网（没登录），没测试无线能不能用，不过如果无线连接的时候，本地有ipv6地址的话，应该就能用。 这时候会出问题，比如使用localhost:4000调试hexo时候，会无法访问。感觉是dns问题，因为现在是ipv6，可能会解析到ipv6的地址，然后proxifier会报错说，没法解决ipv4和ipv6混合使用的问题。这个时候不用localhost:4000，访问127.0.0.1:4000就能调试hexo了。 Google BBR 加速说是能给网络加速，实际效果感觉并不明显，还是写一下吧。root登陆服务器，输入下面命令。123wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.shchmod +x bbr.sh./bbr.sh 安装完事儿之后会让重启服务器，然后就重启吧。输入下面命令。验证是否安装最新内核并开启了BBR。1uname -r 查看一下；1sysctl net.ipv4.tcp_available_congestion_control 上面结果中，看看等号后边带不带bbr，带就行。1sysctl net.ipv4.tcp_congestion_control 上面结果应该等于bbr。1sysctl net.core.default_qdisc 上面结果应该等于fq。1lsmod | grep bbr 上面结果中，看看有没有tcp_bbr，说明已经启动。 过了两天我保证我这两天，没动服务器，也没开电脑。然后就出现了一个状况。ipv6可以连上服务器，但是ipv4死活连不上服务器。经过一番排查，我感觉是服务器那边的问题。然后，于此同时我用ssh竟然没法连接DigitalOcean的服务器了。闹心。我这个DigitalOcean最开始新建Droplet的时候，没有选ssh。不过，最开始的时候是能够用ssh连的，然后过了两天就连接超时，只能通过网页端的console连接。我查了不少教程又看了官方文档。并不会解决，然后我将droplet的系统重装了。然后依旧是这个问题。然后，我就把这个droplet删了。新建了一个droplet，新建时候上传了ssh公钥，并选择了对应的公钥。然后，当然ssh的连接超时的问题就解决了。然后照着我上边说的又走了一遍，ipv4连不上的问题也解决了。]]></content>
      <categories>
        <category>服务器</category>
        <category>Ladder</category>
      </categories>
      <tags>
        <tag>Ladder</tag>
        <tag>Proxifier</tag>
        <tag>VPS</tag>
        <tag>服务器</tag>
        <tag>代理</tag>
        <tag>DigitalOcean</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows10 开启OpenSSH服务 CMD配置SSH远程连接服务]]></title>
    <url>%2F2018%2F06%2F19%2Fwindows-openssh-and-ssh-remote-connection%2F</url>
    <content type="text"><![CDATA[开启OpenSSH服务想要cmd能够使用ssh远程连接服务。我们需要打开OpenSSH服务。首先打开设置，快捷键windows键+I。然后打开应用。然后看到右侧有管理可选功能。点击管理可选功能如果列表中有OpenSSH 客户端，或者是OpenSSH Client字样的东西，说明你的电脑已经开启了OpenSSH服务了。如果没开启OpenSSH服务，那么就点击添加功能，然后把OpenSSH安装了就行了。安装了之后，重启一下电脑，然后才能在CMD中使用ssh远程连接的服务。我们可以看到打开OpenSSH服务之后，也就开启了上图的功能。 SSH远程连接我们打开CMD或者是powershell之后，就能够发现可以使用ssh远程连接服务了。]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>OpenSSH</tag>
        <tag>Windows</tag>
        <tag>CMD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows10 生成 SSH密钥 GitHub配置]]></title>
    <url>%2F2018%2F06%2F19%2Fwindows-github-ssh-key%2F</url>
    <content type="text"><![CDATA[SSH的简介SSH技术是指通信的双方A，B，分别有自己的公钥和私钥，公钥负责加密信息，私钥负责解密信息。设定是这样的A公钥加密的信息，只能通过A的私钥来解密，不能通过其他的私钥来解密，而且通过A的公钥很难推断出A的私钥。通信开始前，双方得知对方的公钥，A给B发送数据，用B的公钥来加密。B给A发送数据用A的公钥来加密。此项技术能够保证通信之间的安全性。即使信息被第三方获取，也无法解密。避免了信息被窃取，篡改，和冒充的情况。 生成密钥首先看看，C盘用户目录(例如：C:\Users\yunhao)下，有没有.ssh这个文件夹。如果有就不用生成，没有就生成一下。或者.ssh文件夹里面没有东西的话也需要生成Windows环境下生成SSH密钥和Ubuntu下生成密钥的方法几乎相仿。windows下生成可以借助GitBash来生成。在某个文件夹下右键，然后打开GitBash。如果不想用GitBash来生成key的话。那么请看本文OpenSSH服务一节输入ssh-keygen回车。生成过程中，会有提示，然后会输入两次密码，这个密码是在使用ssh时候用的，如果不想设置密码的话，就直接回车就好了。 GitHub上配置登陆Github网站，找到个人设置界面。左侧有 SSH and GPG keys 类似字样的选项，点击。然后新建一个 SSH 的 key， 把C:\Users\username\.ssh\id_rsa.pub中的内容复制过去。然后保存。之后就OK了。 OpenSSH服务还有一种方法能够生成密钥。就是开启Windows的OpenSSH服务。之后使用cmd输入ssh-keygen命令来生成。开启方法如下：开启OpenSSH方法]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>GitHub</tag>
        <tag>OpenSSH</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GoDaddy 域名 托管于腾讯云解析]]></title>
    <url>%2F2018%2F06%2F18%2Fgodaddy-domain-dns-on-tencent-cloud%2F</url>
    <content type="text"><![CDATA[腾讯云获取域名服务器注册并登陆了腾讯云之后，找到控制台。然后找到域名服务，云解析。然后点击添加解析。将你要解析的域名加进来。添加域名就是你购买的域名，项目就默认就行。然后能看到添加的域名，点击后边的解析。我们可以看到上边的域名服务器的地址。并且它提示我们去到域名注册商处更改地址。 GoDaddy自定义域名服务器首先是去GoDaddy登陆账户（登陆密码还得要求有大写英文字母，小写英文字母，还有数字）。然后找到我的产品。然后是找到需要托管的域名的DNS。点击了DNS之后，我们可以看到，记录和域名服务器俩栏。我们需要把下面的域名服务器改成自定义的，然后将腾讯云上边的那个域名服务器的地址填上。刷新一下界面，我们就能够看到记录的位置显示信息，表示已经脱离了Godaddy的管理了。这个时候我们就只需要在腾讯云上添加解析的记录就ok了。 腾讯云添加记录添加记录的过程中，A类型是将域名指向IP，CNAME类型是将域名指向另一个域名。比如主机记录填写@，记录类型写CNAME，线路类型默认，记录值写lmnsyunhao.github.io，TTL600。这个就是表示在访问yunhao.life的时候就会解析到lmnsyunhao.github.io这个域名。相当于直接访问lmnsyunhao.github.io这个域名。比如主机记录填写www，记录类型写A，线路类型默认，记录值写8.8.8.8，TTL600。这个表示在访问www.yunhao.life的时候会解析到8.8.8.8。相当于直接访问8.8.8.8这个IP。@主机记录表示三级域名处为空。如果记录类型选CNAME那么记录值只能写域名才有效，记录类型选A，记录值只能写IP地址才有效。]]></content>
      <categories>
        <category>服务器</category>
        <category>域名</category>
      </categories>
      <tags>
        <tag>域名</tag>
        <tag>DNS</tag>
        <tag>GoDaddy</tag>
        <tag>腾讯云</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM HDU 2089 题解 数位DP]]></title>
    <url>%2F2018%2F06%2F17%2Facm-hdu-2089-digital-dp%2F</url>
    <content type="text"><![CDATA[题目不要62 限制Time Limit: 1000/1000 MS (Java/Others)Memory Limit: 32768/32768 K (Java/Others) 描述杭州人称那些傻乎乎粘嗒嗒的人为62（音：laoer）。杭州交通管理局经常会扩充一些的士车牌照，新近出来一个好消息，以后上牌照，不再含有不吉利的数字了，这样一来，就可以消除个别的士司机和乘客的心理障碍，更安全地服务大众。不吉利的数字为所有含有4或62的号码。例如：62315 73418 88914都属于不吉利号码。但是，61152虽然含有6和2，但不是62连号，所以不属于不吉利数字之列。你的任务是，对于每次给出的一个牌照区间号，推断出交管局今次又要实际上给多少辆新的士车上牌照了。 输入格式输入的都是整数对$n,m$$(0 \lt n \le m \lt 1000000)$，如果遇到都是0的整数对，则输入结束。 输出格式对于每个整数对，输出一个不含有不吉利数字的统计个数，该数值占一行位置。 样本121 1000 0 180 思路数位DP。这是记忆化搜索，从高位向低位dfs。首先s数组中存储数字是从低位到高位存储的，比如100，在s数组中就是[0,0,1]这么存的。len是数的位数dp[i][0]表示在第i+1位不是6并且低i位没有限制的情况下，低i位中满足条件的数的个数。dp[i][1]表示在第i+1位是6并且低i位没有限制的情况下，低i为中满足条件的数的个数。dp数组用于记忆化搜索。说一下代码吧。这道题是求n到m中（含边界数）满足条件的个数，也就是求m以内的满足条件个数，再减去n-1以内满足条件个数。说下dfs。pos是当前位数；lim是当前位数的上限值，-1代表没上限，0到9之间的数字代表有上限；prev是高一位的数字是几。首先判断边界，pos&lt;0的情况代表找到了一个数，所以要return 1;这个为啥不return 0?自己想一下，return 0的话结果永远都是0了。然后判断是不是没限制，即lim==-1并且，dp对应的位置不是0，即之前求过并存储下来了，那么就直接返回。否则就继续求。然后就是循环次数了。up是循环次数。for循环的意义是对于pos位是各种数字的情况下，继续dfs pos-1位的情况。循环中，如果是4那么跳过；如果是2并且上一位是4直接跳过；如果i和lim相等，即这一位到了上限，那么在继续进行dfs的时候，下一位也要注意上限的问题，免得超了，所以要把s[pos-1]作为参数，不然的话，就直接传-1了。循环结束后进行记录，如果当前没有上限，即这个值在之后还有利用价值，那么就计入dp，否则，不计入。然后返回这个tmp，tmp是结果。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int n, m;int s[10];int len;int dp[10][2];int dfs(int pos, int lim, int prev)&#123; if(pos &lt; 0) return 1; if(lim == -1 &amp;&amp; dp[pos][prev == 6] != 0) return dp[pos][prev == 6]; int up = lim==-1?9:lim; int tmp = 0; for(int i = 0; i &lt;= up; i++)&#123; if(i == 4) continue; if(i == 2 &amp;&amp; prev == 6) continue; if(i == lim) tmp += dfs(pos-1, s[pos-1], i); else tmp += dfs(pos-1, -1, i); &#125; if(lim == -1)&#123; dp[pos][prev == 6] = tmp; &#125; return tmp;&#125;int solve(int num)&#123; len = 0; memset(s, 0, sizeof s); while(num &gt; 0)&#123; s[len++] = num % 10; num /= 10; &#125; return dfs(len-1, s[len-1], -1);&#125;int main()&#123; while(~scanf("%d %d", &amp;n, &amp;m))&#123; if(n == 0 &amp;&amp; m == 0) break; memset(dp, 0, sizeof dp); printf("%d\n", solve(m)-solve(n-1)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
        <category>数位DP</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DP</tag>
        <tag>HDU</tag>
        <tag>数位DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM LightOJ 1422 题解 区间DP]]></title>
    <url>%2F2018%2F06%2F14%2Facm-lightoj-1422-dp-on-segment%2F</url>
    <content type="text"><![CDATA[题目1422 - Halloween Costumes 限制Time Limit: 2 second(s)Memory Limit: 32 MB 描述Gappu has a very busy weekend ahead of him. Because, next weekend is Halloween, and he is planning to attend as many parties as he can. Since it’s Halloween, these parties are all costume parties, Gappu always selects his costumes in such a way that it blends with his friends, that is, when he is attending the party, arranged by his comic-book-fan friends, he will go with the costume of Superman, but when the party is arranged contest-buddies, he would go with the costume of ‘Chinese Postman’.Since he is going to attend a number of parties on the Halloween night, and wear costumes accordingly, he will be changing his costumes a number of times. So, to make things a little easier, he may put on costumes one over another (that is he may wear the uniform for the postman, over the superman costume). Before each party he can take off some of the costumes, or wear a new one. That is, if he is wearing the Postman uniform over the Superman costume, and wants to go to a party in Superman costume, he can take off the Postman uniform, or he can wear a new Superman uniform. But, keep in mind that, Gappu doesn’t like to wear dresses without cleaning them first, so, after taking off the Postman uniform, he cannot use that again in the Halloween night, if he needs the Postman costume again, he will have to use a new one. He can take off any number of costumes, and if he takes off $k$ of the costumes, that will be the last $k$ ones (e.g. if he wears costume $A$ before costume $B$, to take off $A$, first he has to remove $B$).Given the parties and the costumes, find the minimum number of costumes Gappu will need in the Halloween night. 输入格式Input starts with an integer $T (\le 200)$, denoting the number of test cases.Each case starts with a line containing an integer $N$ $(1 \le N \le 100)$ denoting the number of parties. Next line contains $N$ integers, where the $i^{th}$ integer $c_i$ $(1 \le c_i \le 100)$ denotes the costume he will be wearing in party $i$. He will attend party 1 first, then party 2, and so on. 输出格式For each case, print the case number and the minimum number of required costumes. 样本12345241 2 1 271 2 1 1 3 2 1 12Case 1: 3Case 2: 4 思路区间划分DP。dp[a][b]表示区间[a,b]内最少需要多少件戏服。对于不同长度的每个区间，dp[a][b]最大是b-a+1，然后对以下情况考虑，选出最小值第一，如果区间的两端的戏服是一样的，那么就说明这件戏服在这个区间里可以一直穿着，即dp[a+1][b-1]+1第二，对区间进行划分，对于每个划分，选择最小值。min(dp[a][b], dp[a][k]+dp[k+1][b])第三，对区间划分的时候，如果中间有个数，等于两端的数。即num[k] == num[b]并且num[k] == num[a]，这种情况下，可以省一件戏服，可以从头穿到尾。所以是dp[a][k]+dp[k+1][b]-1，与dp[a][b]比较，选择最小值大概的思路就是这样。看下代码，第21行是对区间长度迭代，第22行是对区间起始节点进行迭代，29行是对不同的划分位置进行迭代。 代码123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int t;int n;int num[105];int dp[105][105];int main()&#123; while(~scanf("%d", &amp;t))&#123; for(int w = 1; w &lt;= t; w++)&#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++)&#123; scanf("%d", &amp;num[i]); &#125; memset(dp, 0, sizeof dp); for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; n-i; j++)&#123; dp[j][j+i] = i+1; if(num[j] == num[j+i])&#123; dp[j][j+i] = min(dp[j][j+i], dp[j+1][j+i-1]+1); &#125; for(int k = j; k &lt; j+i; k++)&#123; dp[j][j+i] = min(dp[j][j+i], dp[j][k]+dp[k+1][j+i]); if(k != j &amp;&amp; k != j+i &amp;&amp; num[k] == num[j] &amp;&amp; num[k] == num[j+i])&#123; dp[j][j+i] = min(dp[j][j+i], dp[j][k]+dp[k+1][j+i]-1); &#125; &#125; &#125; &#125; printf("Case %d: %d\n", w, dp[0][n-1]); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
        <category>区间DP</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DP</tag>
        <tag>区间DP</tag>
        <tag>LightOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM POJ 1651 题解 区间DP]]></title>
    <url>%2F2018%2F06%2F11%2Facm-poj-1651-dp-on-segment%2F</url>
    <content type="text"><![CDATA[题目Multiplication Puzzle 限制Time Limit: 1000MSMemory Limit: 65536K 描述The multiplication puzzle is played with a row of cards, each containing a single positive integer. During the move player takes one card out of the row and scores the number of points equal to the product of the number on the card taken and the numbers on the cards on the left and on the right of it. It is not allowed to take out the first and the last card in the row. After the final move, only two cards are left in the row.The goal is to take cards in such order as to minimize the total number of scored points.For example, if cards in the row contain numbers 10 1 50 20 5, player might take a card with 1, then 20 and 50, scoring$$10 \times 15 \times 0 + 50 \times 20 \times 5 + 10 \times 50 \times 5 = 500+5000+2500 = 8000$$If he would take the cards in the opposite order, i.e. 50, then 20, then 1, the score would be$$1 \times 50 \times 20 + 1 \times 20 \times 5 + 10 \times 1 \times 5 = 1000+100+50 = 1150$$ 输入格式The first line of the input contains the number of cards $N$ $(3 \le N \le 100)$. The second line contains $N$ integers in the range from $1$ to $100$, separated by spaces. 输出格式Output must contain a single integer - the minimal score. 样本12610 1 50 50 20 5 13650 思路划分区间DP。无条件划分区间。dp[a][b]是区间[a,b]的最小的分值。举个例子。序列$1,2,3,4,5$，这就是取$2,3,4$这三个，一共有$6$种组合方式： $2,3,4: \quad 1 \times 2 \times 3+1 \times 3 \times 4+1 \times 4 \times 5$ $2,4,3: \quad 1 \times 2 \times 3+3 \times 4 \times 5+1 \times 3 \times 5$ $3,2,4: \quad 2 \times 3 \times 4+1 \times 2 \times 4+1 \times 4 \times 5$ $3,4,2: \quad 2 \times 3 \times 4+2 \times 4 \times 5+1 \times 2 \times 5$ $4,2,3: \quad 3 \times 4 \times 5+1 \times 2 \times 3+1 \times 3 \times 5$ $4,3,2: \quad 3 \times 4 \times 5+2 \times 3 \times 5+1 \times 2 \times 5$ 也就是说$1,2,3,4,5$的最小分值是从这$6$个组合方式中计算出的。现在考虑区间划分。第一，划分成$[1,2],[2,3,4,5]$两段，$[1,2]$序列中没法计算最小分值，所以考虑序列$[2,3,4,5]$，这个区间的最小分值是从下面这两个序列中计算出来的。$3,4: \quad 2 \times 3 \times 4+2 \times 4 \times 5$$4,3: \quad 3 \times 4 \times 5+2 \times 3 \times 5$与原序列相比，2这个数字还没有移除，我们在后边加上2移除时候的值，得到：$3,4,2: \quad 2 \times 3 \times 4+2 \times 4 \times 5+1 \times 2 \times 5$$4,3,2: \quad 3 \times 4 \times 5+2 \times 3 \times 5+1 \times 2 \times 5$ 第二，划分成$[1,2,3][3,4,5]$两段，$[1,2,3]$序列的最小分值就是将2移除时的分值，$[3,4,5]$序列的最小分值就是将4移除时的分值。所以，我们可以得到这样两个式子：$2,4: \quad 1 \times 2 \times 3+3 \times 4 \times 5$$4,2: \quad 3 \times 4 \times 5+1 \times 2 \times 3$与原序列相比，3这个数字还没有移除，我们在后边再加上3移除时候的值，得到：$2,4,3: \quad 1 \times 2 \times 3+3 \times 4 \times 5+1 \times 3 \times 5$$4,2,3: \quad 3 \times 4 \times 5+1 \times 2 \times 3+1 \times 3 \times 5$ 第三，划分成$[1,2,3,4][4,5]$两段，同理，我们可以得到下面两个：$2,3: \quad 1 \times 2 \times 3+1 \times 3 \times 4$$3,2: \quad 2 \times 3 \times 4+1 \times 2 \times 4$与原序列相比，4还没移除，将4移除。$2,3,4: \quad 1 \times 2 \times 3+1 \times 3 \times 4+1 \times 4 \times 5$$3,2,4: \quad 2 \times 3 \times 4+1 \times 2 \times 4+1 \times 4 \times 5$ 可以看出，拆成了小区间之后，两个小区间的情况再加上边界的数移除的值，就是大区间的所有情况。大概就是这样，我们能看到了整体和局部的关系。这样的话，就可以用划分区间DP了。大区间的解可以从小区间的解中推到出来。上面的例子说明了，大区间求最小值可以拆成小区间，从小区间的最小值中构造出来。解释一下代码，18行对区间长度进行迭代，19行对区间起始节点进行迭代，20行对一个区间的不同划分点进行迭代。转移规则就是在所有划分中取最小值，对于某一个划分的值等于，两个小区间的dp值再加上边界数移除的值。代码中dp默认赋值为0, 所以22行要直接赋值一下，不然最小值永远都是0了，因为序列中所有的数是整数，最小值一定比0大。 代码1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int n;int num[105];int dp[105][105];int main()&#123; while(~scanf("%d", &amp;n))&#123; for(int i = 0; i &lt; n; i++)&#123; scanf("%d", &amp;num[i]); &#125; memset(dp, 0, sizeof dp); for(int i = 2; i &lt; n; i++)&#123; for(int j = 0; j &lt; n-i; j++)&#123; for(int k = j+1; k &lt; j+i; k++)&#123; if(dp[j][j+i] == 0) dp[j][j+i] = dp[j][k]+dp[k][j+i]+num[j]*num[k]*num[j+i]; else dp[j][j+i] = min(dp[j][j+i], dp[j][k]+dp[k][j+i]+num[j]*num[k]*num[j+i]); &#125; &#125; &#125; printf("%d\n", dp[0][n-1]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
        <category>区间DP</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DP</tag>
        <tag>区间DP</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM POJ 2955 题解 区间DP]]></title>
    <url>%2F2018%2F06%2F10%2Facm-poj-2955-dp-on-segment%2F</url>
    <content type="text"><![CDATA[题解Brackets 限制Time Limit: 1000MSMemory Limit: 65536K 描述We give the following inductive definition of a “regular brackets” sequence: the empty sequence is a regular brackets sequence, if s is a regular brackets sequence, then (s) and [s] are regular brackets sequences, and if a and b are regular brackets sequences, then ab is a regular brackets sequence. no other sequence is a regular brackets sequence For instance, all of the following character sequences are regular brackets sequences:(), [], (()), ()[], ()[()]while the following character sequences are not:(, ], )(, ([)], ([(]Given a brackets sequence of characters $a_1a_2…a_n$, your goal is to find the length of the longest regular brackets sequence that is a subsequence of $s$. That is, you wish to find the largest $m$ such that for indices $i_1, i_2, …, i_m$ where $1 \le i_1 \lt i_2 \lt … \lt i_m \le n$, $a_{i_1}a_{i_2} … a_{i_m}$ is a regular brackets sequence.Given the initial sequence ([([]])], the longest regular brackets subsequence is [([])]. 输入格式The input test file will contain multiple test cases. Each input test case consists of a single line containing only the characters (, ), [, and ]; each input test will have length between $1$ and $100$, inclusive. The end-of-file is marked by a line containing the word “end” and should not be processed. 输出格式For each input case, the program should print the length of the longest possible regular brackets subsequence on a single line. 样本123456((()))()()()([]]))[)(([][][)end 1234566406 思路区间划分DP，没有限制的区间划分。dp[a][b]存的是区间[a,b]内满足要求的符号表达式的最大长度。然后dp[a][b]的最大长度，是对区间[a,b]进行划分得到的所有结果中，的最大值。如果str[a]==’(‘并且str[b]==’)’或者是str[a]==’[‘并且str[b]==’]’，即a位置与b位置正好能够配对的时候，dp[a][b]还要与dp[a+1][b-1]作比较，dp[a][b]取最大值。解释一下代码，16行的i是对区间长度进行迭代。17行的j是对不同的区间起始节点进行迭代。18行是对[j,j+i]区间的不同划分点进行迭代。 代码1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int dp[105][105];char str[105];int main()&#123; while(~scanf("%s", str))&#123; if(str[0] == 'e') break; int n = strlen(str); memset(dp, 0, sizeof dp); for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; n-i; j++)&#123; for(int k = j; k &lt; j+i; k++)&#123; dp[j][j+i] = max(dp[j][j+i], dp[j][k]+dp[k+1][j+i]); &#125; if((str[j] == '(' &amp;&amp; str[j+i] == ')') || (str[j] == '[' &amp;&amp; str[j+i] == ']')) dp[j][j+i] = max(dp[j][j+i], dp[j+1][j+i-1]+2); &#125; &#125; printf("%d\n", dp[0][n-1]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
        <category>区间DP</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DP</tag>
        <tag>区间DP</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM HDU 4745 题解 区间DP]]></title>
    <url>%2F2018%2F06%2F10%2Facm-hdu-4745-dp-on-segment%2F</url>
    <content type="text"><![CDATA[题目Two Rabbits 限制Time Limit: 10000/5000 MS (Java/Others)Memory Limit: 65535/65535 K (Java/Others) 描述Long long ago, there lived two rabbits Tom and Jerry in the forest. On a sunny afternoon, they planned to play a game with some stones. There were $n$ stones on the ground and they were arranged as a clockwise ring. That is to say, the first stone was adjacent to the second stone and the n-th stone, and the second stone is adjacent to the first stone and the third stone, and so on. The weight of the i-th stone is ai.The rabbits jumped from one stone to another. Tom always jumped clockwise, and Jerry always jumped anticlockwise.At the beginning, the rabbits both choose a stone and stand on it. Then at each turn, Tom should choose a stone which have not been stepped by itself and then jumped to it, and Jerry should do the same thing as Tom, but the jumping direction is anti-clockwise.For some unknown reason, at any time , the weight of the two stones on which the two rabbits stood should be equal. Besides, any rabbit couldn’t jump over a stone which have been stepped by itself. In other words, if the Tom had stood on the second stone, it cannot jump from the first stone to the third stone or from the n-the stone to the 4-th stone.Please note that during the whole process, it was OK for the two rabbits to stand on a same stone at the same time.Now they want to find out the maximum turns they can play if they follow the optimal strategy. 输入格式The input contains at most $20$ test cases.For each test cases, the first line contains a integer $n$ denoting the number of stones.The next line contains $n$ integers separated by space, and the i-th integer $a_i$ denotes the weight of the i-th stone.$(1 \le n \le 1000, 1 \le a_i \le 1000)$The input ends with $n = 0$. 输出格式For each test case, print a integer denoting the maximum turns. 样本12345671141 1 2 162 1 1 2 1 30 123145 提示For the second case, the path of the Tom is $1, 2, 3, 4$, and the path of Jerry is $1, 4, 3, 2$.For the third case, the path of Tom is $1,2,3,4,5$ and the path of Jerry is $4,3,2,1,5$. 思路一两个人一个顺时针蹦，一个逆时针蹦。不能超过一圈。每次蹦到的数字都得相同。为了保证最大跳数，二人走的路径是重合的。不难证明，如果假设二人走的路不重合，那么就会发现一条新的路径，比原来的路径更长，并且这条路径是重合的。所以二人走的路径是重合的。因为二人走的路径是重合的。并且二人是按照相反方向跳的。所以这条路径是回文的。这道题转化为，在一个长度是n的环形序列上，找一个不连续的回文序列的最大长度。我们先说一种常用的思路，倍增。将序列拷贝一份到后面。变成2n的序列。然后区间DP。dp[a][b]是区间[a,b]内的最长回文子串的长度。dp[a][b]的最长回文子串的长度是从dp[a+1][b],dp[a][b-1]中的最大值。如果num[a]和num[b]相等，那么前面得到的最大值还需要与dp[a+1][b-1]+2比较一下，dp[a][b]取最大值。最后的结果是，以0到n-1开头且长度为n的最长回文子序列中，找最大值。找的过程中需要注意一点，就是如果最开始两个兔子不在同一点出发，那么长度就是dp[i][i+n-1]。如果从同一点出发，长度就是dp[i][i+n-2]+1。所以要考虑到从同一点出发，和不同点出发两种情况，找出最大值。解释一下代码，20行是对不同的区间长度进行迭代，21行是对区间起始节点进行迭代。33行是对所有的起始节点迭代，然后长度锁定在n-1，34行是从不同节点出发的情况，35行是从同一个节点出发的情况。 代码一12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;int n;int num[2005];int dp[2005][2005];int main()&#123; while(~scanf("%d", &amp;n))&#123; if(!n) break; for(int i = 0; i &lt; n; i++)&#123; scanf("%d", &amp;num[i]); num[i+n] = num[i]; &#125; memset(dp, 0, sizeof dp); for(int i = 0; i &lt; 2*n; i++)&#123; for(int j = 0; j &lt; 2*n-i; j++)&#123; if(i == 0) dp[j][j+i] = 1; else&#123; dp[j][j+i] = max(dp[j+1][j+i], dp[j][j+i-1]); if(num[j] == num[j+i])&#123; dp[j][j+i] = max(dp[j][j+i], dp[j+1][j+i-1]+2); &#125; &#125; &#125; &#125; int res = 0; for(int i = 0; i &lt; n; i++)&#123; res = max(res, dp[i][i+n-1]); res = max(res, dp[i][i+n-2]+1); &#125; printf("%d\n", res); &#125; return 0;&#125; 思路二题目就是在长度为n的环上，求一个最长的回文子序列的长度。题目是如何转为为这个问题的，请见思路一。这个思路主要是划分区间。即，把序列划分成2段。分别求两段的最长回文子序列。这两段回文子序列能够组成一个大的回文子序列。1…2…2…1 | 3…4…4…3…假设前段的最长回文子序列是1221，后段的最长回文子序列是3443。组成的大的回文子序列是43122134。这就是两个兔子跳的路径结果就是在n-1个不同划分中，两段最长回文子序列的长度和中，找最大值。dp[a][b]是区间[a,b]内的最长回文子串的长度。注意状态转移。dp[a][b]的最长回文子串的长度是从dp[a+1][b],dp[a][b-1]中的最大值。如果num[a]和num[b]相等，那么前面得到的最大值还需要与dp[a+1][b-1]+2比较一下，dp[a][b]取最大值。这种结果中已经考虑到了两个兔子从不同出发点出发，相同出发点出发。考虑某个回文串长度是奇数。12321 | 4554，路径可以是541232145，两个回文串都是奇数长度，12321 | 454，路径可以使54123214。这个就是从同一点出发的情况。为什么划分成两段，而不是三段，因为三段没法组成大的回文子序列。解释一下代码，19行是对不同的区间长度进行迭代，20行是对区间起始节点进行迭代，32行是对不同的划分点进行迭代。 代码二1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;int n;int num[1005];int dp[1005][1005];int main()&#123; while(~scanf("%d", &amp;n))&#123; if(!n) break; for(int i = 0; i &lt; n; i++)&#123; scanf("%d", &amp;num[i]); &#125; memset(dp, 0, sizeof dp); for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; n-i; j++)&#123; if(i == 0) dp[j][j+i] = 1; else&#123; dp[j][j+i] = max(dp[j+1][j+i], dp[j][j+i-1]); if(num[j] == num[j+i])&#123; dp[j][j+i] = max(dp[j][j+i], dp[j+1][j+i-1]+2); &#125; &#125; &#125; &#125; int res = 1; for(int i = 0; i &lt; n-1; i++)&#123; res = max(res, dp[0][i] + dp[i+1][n-1]); &#125; printf("%d\n", res); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
        <category>区间DP</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DP</tag>
        <tag>HDU</tag>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM HDU 4632 题解 区间DP]]></title>
    <url>%2F2018%2F06%2F10%2Facm-hdu-4632-dp-on-segment%2F</url>
    <content type="text"><![CDATA[题目Palindrome subsequence 限制Time Limit: 2000/1000 MS (Java/Others)Memory Limit: 131072/65535 K (Java/Others) 描述In mathematics, a subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements. For example, the sequence &lt;A, B, D&gt; is a subsequence of &lt;A, B, C, D, E, F&gt;.(http://en.wikipedia.org/wiki/Subsequence)Given a string $S$, your task is to find out how many different subsequence of $S$ is palindrome. Note that for any two subsequence $X = &lt;S_{x_1}, S_{x_2}, …, S_{x_k}&gt;$ and $Y = &lt;S_{y_1}, S_{y_2}, …, S_{y_k}&gt;$ , if there exist an integer $i$ $(1 \le i \le k)$ such that $x_i \ne y_i$, the subsequence $X$ and $Y$ should be consider different even if $S_{x_i} = S_{y_i}$. Also two subsequences with different length should be considered different. 输入格式The first line contains only one integer $T$ $(T \le 50)$, which is the number of test cases. Each test case contains a string $S$, the length of $S$ is not greater than $1000$ and only contains lowercase letters. 输出格式For each test case, output the case number first, then output the number of different subsequence of the given string, the answer should be module $10007$. 样本123454aaaaaagoodafternooneveryonewelcometoooxxourproblems 1234Case 1: 1Case 2: 31Case 3: 421Case 4: 960 思路区间DP。dp[i][j]表示的是i,j区间的回文子序列的个数。注意状态转移。在计算j-i+1长度的区间时，比j-i+1长度小的区间都已经计算过了。因此dp[i][j] = dp[i][j-1] + dp[i+1][j] - dp[i+1][j-1]。如果str[i]==str[j]，那么，dp[i][j]就还需要加上dp[i+1][j-1]+1。19行是对区间长度进行循环。20行是对每个长度的所有区间进行循环。 代码12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;#define mod 10007int t;char str[1005];int dp[1005][1005];int main()&#123; scanf("%d\n", &amp;t); for(int w = 0; w &lt; t; w++)&#123; scanf("%s", str); memset(dp, 0, sizeof dp); int n = strlen(str); for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; n-i; j++)&#123; if(i == 0) dp[j][j+i] = 1; else&#123; dp[j][j+i] = (dp[j][j+i-1]+dp[j+1][j+i])%mod; if(str[j] != str[j+i])&#123; dp[j][j+i] -= dp[j+1][j+i-1]; &#125; else&#123; dp[j][j+i] += 1; &#125; dp[j][j+i] = (dp[j][j+i]+mod)%mod; &#125; &#125; &#125; printf("Case %d: %d\n", w+1, dp[0][n-1]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
        <category>区间DP</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DP</tag>
        <tag>HDU</tag>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM POJ 2342 题解 树形DP]]></title>
    <url>%2F2018%2F06%2F10%2Facm-poj-2342-dp-on-tree%2F</url>
    <content type="text"><![CDATA[题目Anniversary party 限制Time Limit: 1000MSMemory Limit: 65536K 描述There is going to be a party to celebrate the 80-th Anniversary of the Ural State University. The University has a hierarchical structure of employees. It means that the supervisor relation forms a tree rooted at the rector V. E. Tretyakov. In order to make the party funny for every one, the rector does not want both an employee and his or her immediate supervisor to be present. The personnel office has evaluated conviviality of each employee, so everyone has some number (rating) attached to him or her. Your task is to make a list of guests with the maximal possible sum of guests’ conviviality ratings. 输入格式Employees are numbered from $1$ to $N$. A first line of input contains a number $N$. $1 \le N \le 6000$. Each of the subsequent $N$ lines contains the conviviality rating of the corresponding employee. Conviviality rating is an integer number in a range from $-128$ to $127$. After that go $N – 1$ lines that describe a supervisor relation tree. Each line of the tree specification has the form:L KIt means that the K-th employee is an immediate supervisor of the L-th employee. Input is ended with the line0 0 输出格式Output should contain the maximal sum of guests’ ratings. 样本123456789101112131415711111111 32 36 47 44 53 50 0 15 思路树形DP。就是在树上做DP。dp[i][0]代表以i节点为根的子树，在不取i节点的情况下，能够得到的最大的欢乐值。dp[i][1]代表以i节点为根的子树，在取i节点的情况下，能够得到的最大的欢乐值。最后输出根节点的dp[root][0]和dp[root][1]的最大值。以哪个节点开始遍历树，哪个节点就是根节点。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;using namespace std;int n, l, k;int val[6005];vector&lt;int&gt; tr[6005];int dp[6005][2];void dfs(int idx, int fa)&#123; dp[idx][0] = 0; dp[idx][1] = val[idx]; if(tr[idx].size() == 1 &amp;&amp; fa != 0) return; for(int i = 0; i &lt; tr[idx].size(); i++)&#123; if(tr[idx][i] == fa) continue; dfs(tr[idx][i], idx); &#125; for(int i = 0; i &lt; tr[idx].size(); i++)&#123; if(tr[idx][i] == fa) continue; dp[idx][0] += max(dp[tr[idx][i]][0], dp[tr[idx][i]][1]); dp[idx][1] += dp[tr[idx][i]][0]; &#125;&#125;int main()&#123; while(~scanf("%d", &amp;n))&#123; for(int i = 1; i &lt;= n; i++) tr[i].clear(); memset(dp, 0, sizeof dp); for(int i = 1; i &lt;= n; i++)&#123; scanf("%d", &amp;val[i]); &#125; while(scanf("%d %d", &amp;l, &amp;k))&#123; if(l == 0 &amp;&amp; k == 0) break; tr[l].push_back(k); tr[k].push_back(l); &#125; dfs(1, 0); printf("%d\n", max(dp[1][0], dp[1][1])); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
        <category>树形DP</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DP</tag>
        <tag>POJ</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM CodeForces 963 B 题解 DFS]]></title>
    <url>%2F2018%2F06%2F09%2Facm-cf-963b-dfs%2F</url>
    <content type="text"><![CDATA[题目B. Destruction of a Tree 限制time limit per test: 1 secondmemory limit per test: 256 megabytesinput: standard inputoutput: standard output 描述You are given a tree (a graph with $n$ vertices and $n-1$ edges in which it’s possible to reach any vertex from any other vertex using only its edges).A vertex can be destroyed if this vertex has even degree. If you destroy a vertex, all edges connected to it are also deleted.Destroy all vertices in the given tree or determine that it is impossible. 输入格式The first line contains integer $n$ $(1 \le n \le 2 \cdot 10^5)$ — number of vertices in a tree.The second line contains $n$ integers $p_1,p_2,…,p_n$ $(0 \le p_i \le n)$. If $p_i \ne 0$ there is an edge between vertices $i$ and $p_i$. It is guaranteed that the given graph is a tree. 输出格式If it’s possible to destroy all vertices, print “YES” (without quotes), otherwise print “NO” (without quotes).If it’s possible to destroy all vertices, in the next $n$ lines print the indices of the vertices in order you destroy them. If there are multiple correct answers, print any. 样本1250 1 2 1 2 123456YES12354 1240 1 2 3 1NO 提示In the first example at first you have to remove the vertex with index $1$ (after that, the edges $(1, 2)$ and $(1, 4)$ are removed), then the vertex with index $2$ (and edges $(2, 3)$ and $(2, 5)$ are removed). After that there are no edges in the tree, so you can remove remaining vertices in any order. 思路首先我们可以知道，n为偶数的情况下，一定是NO，因为n为偶数，总共有奇数条边，每次消除偶数条边，最后一定剩奇数，所以是NO。所以我们只需考虑n是奇数情况。我们发现叶子结点的度一定是奇数，所以要想消除叶子节点，我们需要消除叶子节点的父亲。先消除靠近叶子节点的偶数度点，再往根节点的方向靠近，按此方法能够找到可行解。我们消除某个节点的所有偶数度的子节点，剩下奇数度子节点要想消除，必须消除该节点。如果此时该节点的度是偶，那么可以消除，如果是奇数，还要消除该节点的父节点之后，才能消除该节点。这是一个递归的思路。用dfs。我们用dfs遍历一棵树，遍历过程中用一个栈stk来保存节点之间的约束情况（某个节点的所有偶数度子节点消除之后，才可以消除当前节点，然后消除所有奇数度子节点。消除当前节点时，如果度为偶数，那么直接消除，否则就要等其父节点消除之后才可消除）。这个栈其实保存了消除过程中的拓扑序。比如上图，有21个节点。dfs过程如下，下面的序列显示的是栈stk的情况，左侧为栈底:栈：1,2,5,12,13,14,55节点的所有偶度子节点都已经消除了，剩下的奇度子节点都在栈里。5节点再次入栈是因为保证拓扑序列正确。也就是说除了叶子结点之外的节点都需要，在其子节点遍历完毕之后，二次进栈。为了消除12,13,14这几个节点，需要消除5节点，看5节点此时有偶数度。5节点是偶数度。可以消除5，所以5的所有奇度子节点也可以消除了。所以栈中两个5之间的都能输出了。输出顺序5,14,13,12。栈：1,2然后继续栈：1,2,6,15,16,17,6同理，输出6,17,16,15栈：1,2,7,18,19,7发现节点7没法消除，那么就留在栈里。栈：1,2,7,18,19,7,8,20,21,8,2发现节点8没法消除，节点2也没法消除。栈：1,2,7,18,19,7,8,20,21,8,2,3,9,3发现3,4可以消除，输出3,9栈：1,2,7,18,19,7,8,20,21,8,2,4,10,11,4,1发现4也没法消除，最后到1遍历结束。然后最后1能消除了。所以按照出栈顺序继续输出。1,4,11,10,2,8,21,20,7,19,18这就是结果了。5,14,13,12,6,17,16,15,3,9,1,4,11,10,2,8,21,20,7,19,18思路大概就是这样需要注意的是最后栈里面的要都输出来。然后注意16行要fa！=0。否则的话对于下图这种根节点只有一个孩子的会误判为叶子结点。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;int n, num;int stk[400005];int cur;int cnt[200005];vector&lt;int&gt; tr[200005];void dfs(int idx, int fa)&#123; stk[cur++] = idx; if(tr[idx].size() == 1 &amp;&amp; fa != 0) return; for(int i = 0; i &lt; tr[idx].size(); i++)&#123; if(tr[idx][i] == fa) continue; dfs(tr[idx][i], idx); &#125; stk[cur++] = idx; if(cnt[idx] % 2 == 0)&#123; printf("%d\n", idx); cnt[idx] = -1; cnt[fa]--; cur--; while(cur &amp;&amp; stk[cur-1] != idx)&#123; if(cnt[stk[cur-1]] != -1)&#123; printf("%d\n", stk[cur-1]); cnt[stk[cur-1]] = -1; &#125; cur--; &#125; cur--; &#125;&#125;int main()&#123; while(~scanf("%d", &amp;n))&#123; for(int i = 1; i &lt;= n; i++) tr[i].clear(); memset(cnt, 0, sizeof cnt); cur = 0; for(int i = 1; i &lt;= n; i++)&#123; scanf("%d", &amp;num); if(num != 0)&#123; cnt[i]++; cnt[num]++; tr[i].push_back(num); tr[num].push_back(i); &#125; &#125; if(n%2==0)&#123; printf("NO\n"); &#125; else&#123; printf("YES\n"); dfs(1, 0); while(cur)&#123; if(cnt[stk[cur-1]] != -1)&#123; printf("%d\n", stk[cur-1]); cnt[stk[cur-1]] = -1; &#125; cur--; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>搜索</category>
        <category>DFS</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>CodeForces</tag>
        <tag>搜索</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM CodeForces 877 B 题解 DP]]></title>
    <url>%2F2018%2F06%2F08%2Facm-cf-877b-dp%2F</url>
    <content type="text"><![CDATA[题目B. Nikita and string 限制time limit per test: 2 secondsmemory limit per test: 256 megabytesinput: standard inputoutput: standard output 描述One day Nikita found the string containing letters “a” and “b” only.Nikita thinks that string is beautiful if it can be cut into 3 strings (possibly empty) without changing the order of the letters, where the 1-st and the 3-rd one contain only letters “a” and the 2-nd contains only letters “b”.Nikita wants to make the string beautiful by removing some (possibly none) of its characters, but without changing their order. What is the maximum length of the string he can get? 输入格式The first line contains a non-empty string of length not greater than $5000$ containing only lowercase English letters “a” and “b”. 输出格式Print a single integer — the maximum possible size of beautiful string Nikita can get. 样本1abba 14 1bab 12 提示It the first sample the string is already beautiful.In the second sample he needs to delete one of “b” to make it beautiful. 思路动态规划。dp[i][0]是指前i个字符中，a…序列(不一定连续)的最大长度。dp[i][1]是指前i个字符中，a…b…序列(不一定连续)的最大长度。dp[i][2]是指前i个字符中，a…b…a…序列(不一定连续)的最大长度。转换过程详见代码。 代码1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;char str[5005];int dp[5005][3];int main()&#123; while(~scanf("%s", str))&#123; int len = strlen(str); memset(dp, 0, sizeof dp); for(int i = 1; i &lt;= len; i++)&#123; if(str[i-1] == 'a')&#123; dp[i][0] = dp[i-1][0]+1; dp[i][1] = dp[i-1][1]; dp[i][2] = max(dp[i-1][1]+1, dp[i-1][2]+1); &#125; else&#123; dp[i][0] = dp[i-1][0]; dp[i][1] = max(dp[i-1][0]+1, dp[i-1][1]+1); dp[i][2] = dp[i-1][2]; &#125; &#125; printf("%d\n", max(dp[len][0], max(dp[len][1], dp[len][2]))); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>CodeForces</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM CodeForces 873 B 题解 前缀和]]></title>
    <url>%2F2018%2F06%2F07%2Facm-cf-873b-simple%2F</url>
    <content type="text"><![CDATA[题目B. Balanced Substring 限制time limit per test: 1 secondmemory limit per test: 256 megabytesinput: standard inputoutput: standard output 描述You are given a string $s$ consisting only of characters $0$ and $1$. A substring $[l,r]$ of $s$ is a string $s_l$$s_{l+1}$$s_{l+2}$$…$$s_r$, and its length equals to $r-l+1$. A substring is called balanced if the number of zeroes (0) equals to the number of ones in this substring.You have to determine the length of the longest balanced substring of $s$. 输入格式The first line contains $n$ $(1 \le n \le 100000)$ — the number of characters in $s$.The second line contains a string $s$ consisting of exactly $n$ characters. Only characters $0$ and $1$ can appear in $s$. 输出格式If there is no non-empty balanced substring in $s$, print $0$. Otherwise, print the length of the longest balanced substring. 样本12811010111 14 123111 10 提示In the first example you can choose the substring $[3,6]$. It is balanced, and its length is $4$. Choosing the substring $[2,5]$ is also possible.In the second example it’s impossible to find a non-empty balanced substring. 思路前缀和的思想。从头往后扫，遇到1就加一，遇到0就减一，维护数列的前缀和。一旦r的前缀和l的前缀相等，那么[l+1,r]这个区间里的0和1的数量一定相等。mark数组中0到100000存储的是前缀和为-100000到0的首次出现位置。100001到200000存储的是前缀和为1到100000的首次出现位置。mark数组首先初始化为-2，然后将mark[0]设置为-1。每次计算前缀和，一旦发现某个mark对应某个前缀和在之前出现过，即不等于-2，那么就和res作比较。否则就更新mark的值为当前下标。 代码1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;int n;char c;int num;int mark[200005];int main()&#123; while(~scanf("%d\n", &amp;n))&#123; for(int i = -1*n; i &lt;= n; i++)&#123; mark[i+100000] = -2; &#125; mark[100000] = -1; int sum = 0; int res = 0; for(int i = 0; i &lt; n; i++)&#123; scanf("%c", &amp;c); num = c-'0'; num == 0 ? sum-- : sum++; if(mark[100000+sum] != -2)&#123; res = max(i-mark[100000+sum], res); &#125; else&#123; mark[100000+sum] = i; &#125; &#125; printf("%d\n", res); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>基础题</category>
        <category>前缀和</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>CodeForces</tag>
        <tag>基础题</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM CodeForces 888 B 题解 基础题]]></title>
    <url>%2F2018%2F06%2F07%2Facm-cf-888b-simple%2F</url>
    <content type="text"><![CDATA[题目B. Buggy Robot 限制time limit per test: 2 secondsmemory limit per test: 256 megabytesinput: standard inputoutput: standard output 描述Ivan has a robot which is situated on an infinite grid. Initially the robot is standing in the starting cell $(0,0)$. The robot can process commands. There are four types of commands it can perform: U — move from the cell $(x,y)$ to $(x,y+1)$; D — move from $(x,y)$ to $(x,y-1)$; L — move from $(x,y)$ to $(x-1,y)$; R — move from $(x,y)$ to $(x+1,y)$. Ivan entered a sequence of $n$ commands, and the robot processed it. After this sequence the robot ended up in the starting cell $(0,0)$, but Ivan doubts that the sequence is such that after performing it correctly the robot ends up in the same cell. He thinks that some commands were ignored by robot. To acknowledge whether the robot is severely bugged, he needs to calculate the maximum possible number of commands that were performed correctly. Help Ivan to do the calculations! 输入格式The first line contains one number $n$ — the length of sequence of commands entered by Ivan $(1 \le n \le 100)$.The second line contains the sequence itself — a string consisting of $n$ characters. Each character can be $U$, $D$, $L$ or $R$. 输出格式Print the maximum possible number of commands from the sequence the robot could perform to end up in the starting cell. 样本124LDUR 14 125RRRUU 10 126LLRRRR 14 思路水题。算一下L、R、U、D四个字符的个数，然后为了回到原点，所以选取的L、R的个数必须相等，选取的U、D的个数也必须相等。详见代码。 代码1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int n;char c;int main()&#123; while(~scanf("%d\n", &amp;n))&#123; int cntl = 0, cntr = 0, cntu = 0, cntd = 0; for(int i = 1; i &lt;= n; i++)&#123; scanf("%c", &amp;c); if(c == 'L') cntl++; else if(c == 'R') cntr++; else if(c == 'U') cntu++; else if(c == 'D') cntd++; &#125; printf("%d\n", min(cntl, cntr)*2 + min(cntu, cntd)*2); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>基础题</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>CodeForces</tag>
        <tag>基础题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM CodeForces 891 A 题解 DP]]></title>
    <url>%2F2018%2F06%2F06%2Facm-cf-891a-dp%2F</url>
    <content type="text"><![CDATA[题目A. Pride 限制time limit per test: 2 secondsmemory limit per test: 256 megabytesinput: standard inputoutput: standard output 描述You have an array $a$ with length $n$, you can perform operations. Each operation is like this: choose two adjacent elements from $a$, say $x$ and $y$, and replace one of them with $gcd(x,y)$, where gcd denotes the greatest common divisor.What is the minimum number of operations you need to make all of the elements equal to $1$? 输入格式The first line of the input contains one integer $n$$(1 \le n \le 2000)$ — the number of elements in the array.The second line contains $n$ space separated integers $a_1,a_2,…,a_n$ $(1 \le a_i \le 10^9)$ — the elements of the array. 输出格式Print $-1$, if it is impossible to turn all numbers to $1$. Otherwise, print the minimum number of operations needed to make all numbers equal to $1$. 样本1252 2 3 4 6 15 1242 4 6 8 1-1 1232 6 9 14 提示In the first sample you can turn all numbers to 1 using the following 5 moves: $[2,2,3,4,6]$ $[2,1,3,4,6]$ $[2,1,3,1,6]$ $[2,1,1,1,6]$ $[1,1,1,1,6]$ $[1,1,1,1,1]$ We can prove that in this case it is not possible to make all numbers one using less than 5 moves. 思路如果序列中有1的话，结果是n减去1的个数。本题关键就是找到一段最短区间[l,r]，该区间的gcd是1，结果是r-l+n-1。r-l是这个区间变出一个1的步数，n-1是变出了一个1之后，将剩余的n-1个数都变成1的步数代码中dp[i][j]存储的是区间[i,j]的gcd。dp[i][i]存储的是序列中的数。dp数组中只有右上半个数组实际被用到。第25行的i是循环的区间长度，从1到n-1。第26行的j循环的是区间的起始元素。递推公式是dp[j][j+i] = gcd(dp[j][j+i-1], dp[j+i][j+i])__gcd(a, b)是algorithm库中的函数 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int n;int dp[2005][2005];int main()&#123; while(~scanf("%d", &amp;n))&#123; memset(dp, 0, sizeof dp); int cnt = 0; for (int i = 0; i &lt; n; i++)&#123; scanf("%d", &amp;dp[i][i]); if(dp[i][i] == 1)&#123; cnt++; &#125; &#125; if(cnt &gt; 0)&#123; printf("%d\n", n-cnt); &#125; else&#123; int ans = 0; bool flag = false; for (int i = 1; i &lt; n; i++)&#123; for (int j = 0; j+i &lt; n; j++)&#123; dp[j][j+i] = __gcd(dp[j][j+i-1], dp[j+i][j+i]); if(dp[j][j+i] == 1)&#123; flag = true; ans = i; break; &#125; &#125; if(flag) break; &#125; if(flag) printf("%d\n", n-1+ans); else printf("-1\n"); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>CodeForces</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM 组合数学 母函数 生成函数 详解]]></title>
    <url>%2F2018%2F06%2F05%2Facm-generating-function-learning%2F</url>
    <content type="text"><![CDATA[介绍在组合数学中，母函数，又叫生成函数，是一种形式幂级数。每一项的系数可以提供关于这个项的信息。使用母函数解决问题的方法就是母函数法。母函数有很多种，普通母函数、指数母函数、L级数、贝尔级数、狄利克雷级数。根据一个序列不同的性质，或是需要得到的信息，要选择以上不同的母函数进行套用。母函数方法的思想就是将数列间的相加关系与幂级数间的乘幂运算对应起来。 定义序列$a_0, a_1, a_2, a_3, …$构造一个函数$G(x)=a_0+a_1x+a_2x^2+…$称$G(x)$为$a_0, a_1, a_2, a_3, …$序列的母函数 普通母函数该类母函数比较常用，可以用于解决整数拆分，组合数量问题。 一次多项式乘法母函数一次是指每一个多项式的最高次是1$\quad(1+a_1x)(1+a_2x)…(1+a_nx)$$=1+(a_1+a_2+…+a_n)x+(a_1a_2+a_1a_3+…+a_{n-1}a_n)x^2+…+a_1a_2…a_nx^n$$x$的系数是$a_1, a_2, … a_n$的$1$个组合的和$x^2$的系数是$a_1, a_2, … a_n$的$2$个组合的和…$x^n$的系数是$a_1, a_2, … a_n$的$n$个组合的和 杨辉三角母函数$\quad(1+x)^n$$=C_n^0x^0+C_n^1x^1+C_n^2x^2+…+C_n^nx^n$$=1+C_n^1x+C_n^2x^2+…+C_n^nx^n$ 高次有限项多项式乘法母函数高次指每个多项式的最高次大于1，有限项指的是每个多项式的项数是有限的比如有这样一个问题。有1元2张、5元4张、10元1张、20元3张，问可以组合出多少种面额，每种面额的组合方式数量是多少问题可以转化为如下的多项式$\quad(1\times x^{0 \times 1}+1\times x^{1 \times 1}+1\times x^{2 \times 1})(1\times x^{0 \times 5}+1\times x^{1 \times 5}+1\times x^{2 \times 5}+1\times x^{3 \times 5}+1\times x^{4 \times 5})\cdot$$\quad(1\times x^{0 \times 10}+1\times x^{1 \times 10})(1\times x^{0 \times 20}+1\times x^{1 \times 20}+1\times x^{2 \times 20}+1\times x^{3 \times 20})$$=(1+x+x^2)(1+x^5+x^{10}+x^{15}+x^{20})(1+x^{10})(1+x^{20}+x^{40}+x^{60})$一共四个多项式相乘，分别代表1元、5元、10元、20元的选择情况。用第一个多项式举例。多项式中每一项的指数代表组合情况，即$x^{0 \times 1}$代表取0个1元，系数1代表组合种数有1种$x^{1 \times 1}$代表取1个1元，系数1代表组合种数有1种$x^{2 \times 1}$代表取2个1元，系数1代表组合种数有1种因为1元有两张，所以到这里就结束了，这个多项式的项是有限项。将数列间的相加关系与幂级数间的乘幂运算对应起来在这里的体现就是：在计算这个多项式乘积的时候，x的幂相乘运算就是指数相加，而这个指数相加正好对应了数列间的加法运算。而相乘之后得到的多项式的各项系数就是组合方式数。 高次无限项多项式乘法母函数高次指每个多项式的最高次大于1，无限项指的是每个多项式的项数是无限的考虑这样一个问题，有1,2,3克砝码无限个。求某一质量的方案数。类比高次有限项多项式乘法母函数，直接写出多项式乘积：$(1+x+x^2+x^3+…)(1+x^2+x^4+x^6+…)(1+x^3+x^6+x^9+…)$计算这个多项式的和，质量为$n$的方案数就是$x^n$的系数考虑这样一个题，有120个数，每个数的个数不限。求组成某个数的方案数。$4=3+1$与$4=1+3$属于同一种方案给出模版代码123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int n;int num1[125];int num2[125];int main()&#123; memset(num1, 0, sizeof num1); memset(num2, 0, sizeof num2); for(int i = 0; i &lt; 125; i++)&#123; num1[i] = 1; &#125; for(int i = 2; i &lt;= 120; i++)&#123; for(int j = 0; j &lt;= 120; j++)&#123; for (int k = 0; k+j &lt;= 120; k += i)&#123; num2[k+j] += num1[j]; &#125; &#125; for(int j = 0; j &lt;= 120; j++)&#123; num1[j] = num2[j]; num2[j] = 0; &#125; &#125; while(~scanf("%d", &amp;n))&#123; printf("%d\n", num1[n]); &#125;&#125; 解释一下代码，这个代码其实就是在模拟多项式乘法的过程。$(1+x^1+x^2+…+x^{120})(1+x^2+x^4+x^6+…+x^{120})…(1+x^{120})$一共120个多项式相乘。 num1在每轮循环结束后存储的都是第一个多项式的系数。num2是一个中转数组，用来暂存过程中的新的多项式的系数。每次循环结束，num2中的值都要倒换到num1中。 13-15行就是第一轮，是$(1+x^1+x^2+…+x^{120})$多项式的各项系数。这是初始化num1，num2数组 第16行是对120个多项式进行循环。每轮乘一个多项式进去。第i轮乘的是各项系数是i的倍数的多项式。也就是说第2轮乘的是$(1+x^2+x^4+…)$，第三轮乘的是$(1+x^3+x^6+…)$，第i轮乘的是$(1+x^i+x^{2i}+…)$。第i轮结束后，num1中的系数是前i个多项式的乘积多项式的系数。即$(1+x^1+x^2+…)(1+x^2+x^4+…)…(1+x^i+x^{2i}+…)$的结果的系数 第17行的j是对第i-1轮得到的乘积多项式的各项进行循环。即，$(1+x^1+x^2+…)(1+x^2+x^4+…)…(1+x^{i-1}+x^{2i-2}+…)$的结果中的各项 第18行的k是对第i个多项式，即$(1+x^i+x^{2i}+…)$的各项进行循环。将这个多项式和前i-1个多项式的乘积相乘，得到前i个多项式的乘积。k的增量是i 第19行，num2存的是相乘运算的过程中的中间结果系数，num1存的是前i-1个多项式的乘积的系数。因为第i个多项式中的每项的系数都是1，所以num2[k+j]直接加了num1[j]，其实是1*num1[j]。 第22-24行，就是将num2的结果跟num1的结果倒腾一下。 注意，有的题，可能要求比如，某个值最少用多少，最多用多少这种情况。这个时候，就是k不从0开始了，并且k+=i的次数有限制。需要灵活变通]]></content>
      <categories>
        <category>ACM</category>
        <category>组合数学</category>
        <category>母函数</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>组合数学</tag>
        <tag>母函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM HDU 1028 题解 母函数 生成函数]]></title>
    <url>%2F2018%2F06%2F05%2Facm-hdu-1028-generating-function%2F</url>
    <content type="text"><![CDATA[题目Ignatius and the Princess III 限制Time Limit: 2000/1000 MS (Java/Others)Memory Limit: 65536/32768 K (Java/Others) 描述“Well, it seems the first problem is too easy. I will let you know how foolish you are later.” feng5166 says.“The second problem is, given an positive integer $N$, we define an equation like this:$N=a[1]+a[2]+a[3]+…+a[m];$$a[i]&gt;0,$$1&lt;=m&lt;=N;$My question is how many different equations you can find for a given $N$.For example, assume $N$ is $4$, we can find:$4 = 4;$$4 = 3 + 1;$$4 = 2 + 2;$$4 = 2 + 1 + 1;$$4 = 1 + 1 + 1 + 1;$so the result is $5$ when $N$ is $4$. Note that “$4 = 3 + 1$” and “$4 = 1 + 3$” is the same in this problem. Now, you do it!” 输入格式The input contains several test cases. Each test case contains a positive integer $N$$(1 \le N \le 120)$ which is mentioned above. The input is terminated by the end of file. 输出格式For each test case, you have to output a line contains an integer $P$ which indicate the different equations you have found. 样本12341020 123542627 思路普通母函数题，也叫生成函数。整数拆分。打表做。先打出0到120的表。然后直接输出。应用到的母函数公式$$G(x)=(1+x+x^2+…)(1+x^2+x^4+…)(1+x^3+x^6+…)…(1+x^n+x^{2n}+…)$$母函数公式如何套用，详见本人博客母函数详解 代码123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int n;int num1[125];int num2[125];int main()&#123; memset(num1, 0, sizeof num1); memset(num2, 0, sizeof num2); for(int i = 0; i &lt; 125; i++)&#123; num1[i] = 1; &#125; for(int i = 2; i &lt;= 120; i++)&#123; for(int j = 0; j &lt;= 120; j++)&#123; for (int k = 0; k+j &lt;= 120; k += i)&#123; num2[k+j] += num1[j]; &#125; &#125; for(int j = 0; j &lt;= 120; j++)&#123; num1[j] = num2[j]; num2[j] = 0; &#125; &#125; while(~scanf("%d", &amp;n))&#123; printf("%d\n", num1[n]); &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>组合数学</category>
        <category>母函数</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>组合数学</tag>
        <tag>母函数</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM HDU 2844 题解 多重背包]]></title>
    <url>%2F2018%2F06%2F05%2Facm-hdu-2844-dp%2F</url>
    <content type="text"><![CDATA[题目Coins 限制Time Limit: 2000/1000 MS (Java/Others)Memory Limit: 32768/32768 K (Java/Others) 描述Whuacmers use coins. They have coins of value $A_1,A_2,A_3…A_n$ Silverland dollar. One day Hibix opened purse and found there were some coins. He decided to buy a very nice watch in a nearby shop. He wanted to pay the exact price(without change) and he known the price would not more than $m$.But he didn’t know the exact price of the watch.You are to write a program which reads $n,m,A_1,A_2,A_3…A_n$ and $C_1,C_2,C_3…C_n$ corresponding to the number of Tony’s coins of value $A_1,A_2,A_3…A_n$ then calculate how many prices(form $1$ to $m$) Tony can pay use these coins. 输入格式The input contains several test cases. The first line of each test case contains two integers $n$$(1 \le n \le 100),$ $m$$(m \le 100000)$. The second line contains $2n$ integers, denoting $A_1,A_2,A_3…A_n,$ $C_1,C_2,C_3…C_n$ $(1 \le Ai \le 100000,$ $1 \le Ci \le 1000)$. The last test case is followed by two zeros. 输出格式For each test case output the answer on a single line. 样本123453 101 2 4 2 1 12 51 4 2 10 0 1284 思路多重背包问题。如果某个硬币的面额乘数量大于m，那么就是完全背包；否则就是01背包。注意不能全按照01背包处理，会超时。拆01背包时候按照类似2分的样子拆。这样能够保证拆出来之后增加的物品数量最小。代码中m是背包容量。v数组是存储的面额，c数组存储的是数量，函数参数中的c是花费，v是价值。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int n, m;int v[105];int c[105];int dp[100005];void init(int m)&#123; for(int i = 1; i &lt;= m; i++)&#123; dp[i] = -1000000000; &#125; dp[0] = 0;&#125;void completepack(int m, int c, int v)&#123; for(int i = c; i &lt;= m; i++)&#123; dp[i] = max(dp[i], dp[i-c]+v); &#125;&#125;void O1pack(int m, int c, int v)&#123; for(int i = m; i &gt;= c; i--)&#123; dp[i] = max(dp[i], dp[i-c]+v); &#125;&#125;void multiplepack(int m, int c, int v, int num)&#123; if(c*num &gt;= m)&#123; completepack(m, c, v); return ; &#125; for(int i = 1; i &lt;= num; i*=2)&#123; O1pack(m, c*i, v*i); num -= i; &#125; if(num)&#123; O1pack(m, c*num, v*num); &#125;&#125;int main()&#123; while(~scanf("%d%d", &amp;n, &amp;m))&#123; if(n == 0 &amp;&amp; m == 0) break; for(int i = 0; i &lt; n; i++)&#123; scanf("%d", &amp;v[i]); &#125; for(int i = 0; i &lt; n; i++)&#123; scanf("%d", &amp;c[i]); &#125; init(m); if(m &gt; 0)&#123; for(int i = 0; i &lt; n; i++)&#123; multiplepack(m, v[i], 1, c[i]); &#125; &#125; int ret = 0; for(int i = 1; i &lt;= m; i++)&#123; if(dp[i] &gt; 0)&#123; ret++; &#125; &#125; printf("%d\n", ret); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
        <category>背包问题</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DP</tag>
        <tag>HDU</tag>
        <tag>背包问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM CodeForces 910 A 题解 DP]]></title>
    <url>%2F2018%2F05%2F26%2Facm-cf-910a-dp%2F</url>
    <content type="text"><![CDATA[题目A. The Way to Home 限制time limit per test: 1 secondmemory limit per test: 256 megabytesinput: standard inputoutput: standard output 描述outputstandard outputA frog lives on the axis $Ox$ and needs to reach home which is in the point $n$. She starts from the point $1$. The frog can jump to the right at a distance not more than $d$. So, after she jumped from the point $x$ she can reach the point $x+a$, where $a$ is an integer from $1$ to $d$.For each point from $1$ to $n$ is known if there is a lily flower in it. The frog can jump only in points with a lilies. Guaranteed that there are lilies in the points $1$ and $n$.Determine the minimal number of jumps that the frog needs to reach home which is in the point $n$ from the point $1$. Consider that initially the frog is in the point $1$. If the frog can not reach home, print $-1$. 输入格式The first line contains two integers $n$ and $d$ $(2 \le n \le 100, 1 \le d \le n-1)$ — the point, which the frog wants to reach, and the maximal length of the frog jump.The second line contains a string $s$ of length $n$, consisting of zeros and ones. If a character of the string s equals to zero, then in the corresponding point there is no lily flower. In the other case, in the corresponding point there is a lily flower. Guaranteed that the first and the last characters of the string $s$ equal to one. 输出格式If the frog can not reach the home, print $-1$.In the other case, print the minimal number of jumps that the frog needs to reach the home which is in the point $n$ from the point $1$. 样本128 410010101 12 124 21001 1-1 128 411100101 13 1212 3101111100101 14 提示In the first example the from can reach home in two jumps: the first jump from the point $1$ to the point $4$ (the length of the jump is three), and the second jump from the point $4$ to the point $8$ (the length of the jump is four).In the second example the frog can not reach home, because to make it she need to jump on a distance three, but the maximum length of her jump equals to two. 思路一个不怎么明显的dp题。遍历字符串s，如果是1那么就考虑如下，假设当前是i位置，那么i位置的最小跳数是，从i-d到i-1这个区间内跳数的最小值，再加一。所以关键就是怎么取得最小值。用优先队列，封装一个node，idx代表某个位置的下标，num代表这个位置的最小跳数，这个node的operator函数是将q队列弄成了以num排序的小顶堆。遍历字符串的时候，如果是1，那么就先看堆顶的idx是否在i-d和i-1之间，如果不在，那么就pop，直到队列为空或者找到一个在区间内的为止。队列为空，就直接是-1，如果找到了，那么就说明i位置能够到达，然后就更新i位置，将i位置的node加入堆中。 代码1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;int n, d;char str[105];struct node&#123; int idx, num; bool operator &lt; (const node&amp; no) const&#123; return num &gt; no.num; &#125;&#125;;int main()&#123; while(~scanf("%d %d", &amp;n, &amp;d))&#123; scanf("%s", str); priority_queue&lt;node&gt; q; q.push((node)&#123;0, 0&#125;); for (int i = 0; i &lt; n; i++)&#123; if(str[i] == '1')&#123; while(!q.empty() &amp;&amp; q.top().idx + d &lt; i)&#123; q.pop(); &#125; if(q.empty())&#123; printf("-1\n"); break; &#125; node no = q.top(); if(i == n-1)&#123; printf("%d\n", no.num+1); break; &#125; q.push((node)&#123;i, no.num + 1&#125;); &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>CodeForces</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows10 PC 无法进入选择启动项界面 无法进入BIOS界面]]></title>
    <url>%2F2018%2F05%2F23%2Fwindows-pc-cannot-select-boot-device%2F</url>
    <content type="text"><![CDATA[症状想要安装双系统，或是干什么事情的时候，需要选择启动项，但是发现怎么按F12或者其他对应的按键，都不能进入选择启动项的界面，当然BIOS界面也是进不去。 原因Windows10有快速启动这一个功能，就是为了让每次开机更快，它并没有彻底关机，而是做了一些小操作，像是休眠，给你一种关机的假象。 标准解决方法当然是关掉快速启动功能了。如何关闭呢？打开控制面板点击系统和安全点击电源选项下的更改电源按钮的功能先点击上边的更改当前不可用的设置，然后取消勾选启用快速启动，最后保存更改就OK了 暴力解决方法其实还有一种解决方法，但是只能当次适用。就是强制关机，强制关机后的第一次启动电脑可以进入选择启动项界面，之后就不行了。 注有的电脑尽管勾选了快速启动，还是能够正常的进入选择启动项界面，BIOS界面。比如工作站之类的。这些电脑就比较强大了。]]></content>
      <categories>
        <category>系统安装</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>系统安装</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM CodeForces 933 A 题解 DP]]></title>
    <url>%2F2018%2F05%2F23%2Facm-cf-933a-dp%2F</url>
    <content type="text"><![CDATA[题目A. A Twisty Movement 限制time limit per test: 1 secondmemory limit per test: 256 megabytesinput: standard inputoutput: standard output 描述A dragon symbolizes wisdom, power and wealth. On Lunar New Year’s Day, people model a dragon with bamboo strips and clothes, raise them with rods, and hold the rods high and low to resemble a flying dragon.A performer holding the rod low is represented by a $1$, while one holding it high is represented by a $2$. Thus, the line of performers can be represented by a sequence $a_1, a_2, …, a_n$.Little Tommy is among them. He would like to choose an interval $[l, r] (1 \le l \le r \le n)$, then reverse $a_l, a_{l+1}, …, a_r$ so that the length of the longest non-decreasing subsequence of the new sequence is maximum.A non-decreasing subsequence is a sequence of indices $p_1, p_2, …, p_k$, such that $p_1 &lt; p_2 &lt; … &lt; p_k$ and $a_{p1} \le a_{p2} \le … \le a_{pk}$. The length of the subsequence is $k$. 输入格式The first line contains an integer $n (1 \le n \le 2000)$, denoting the length of the original sequence.The second line contains n space-separated integers, describing the original sequence $a_1, a_2, …, a_n$ $(1 \le a_i \le 2, i = 1, 2, …, n)$. 输出格式Print a single integer, which means the maximum possible length of the longest non-decreasing subsequence of the new sequence. 样本1241 2 1 2 14 12101 1 2 2 2 1 1 2 2 1 19 提示In the first example, after reversing $[2, 3]$, the array will become $[1, 1, 2, 2]$, where the length of the longest non-decreasing subsequence is 4.In the second example, after reversing $[3, 7]$, the array will become $[1, 1, 1, 1, 2, 2, 2, 2, 2, 1$], where the length of the longest non-decreasing subsequence is 9. 思路最开始读错题了，还错误理解了两个位置。首先是子序列，即不要求连续。第二是reverse这个词，不是将某一个区间的值1变2,2变1，而是翻转这个区间，即1,2,1,1变成1,1,2,1。用dp。考虑四种情况。1…的子序列，1…2…的子序列，1…2…1…的子序列，1…2…1…2…的子序列。因为可以用reverse，所以让1…2…1…2…这种子序列最长就好了。dp[0][i]代表前i个字符内1…的子序列最长的长度是多少。dp[1][i]代表前i个字符内1…2…的子序列的最长的长度是多少。dp[2][i]代表前i个字符内1…2…1…的子序列的最长的长度是多少。dp[3][i]代表前i个字符内1…2…1…2…的子序列的最长的长度是多少。注意最后输出dp[0][n-1]到dp[3][n-1]中最大值。因为序列中不一定会有满足1…2…1…2…的子序列，比如”111”, “222”, “12”, “21”, “212”这种。可以用滚动数组，代码中没用滚动数组。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int n;int num[2010];int dp[4][2010];int main()&#123; while(~scanf("%d", &amp;n))&#123; memset(dp, 0, sizeof dp); for(int i = 0; i &lt; n; i++)&#123; scanf("%d", &amp;num[i]); &#125; for (int i = 0; i &lt; n; i++)&#123; if(i == 0)&#123; if(num[i] == 1)&#123; dp[0][i] = 1; &#125; else&#123; dp[1][i] = 1; &#125; continue; &#125; if(num[i] == 1)&#123; dp[0][i] = dp[0][i-1] + 1; dp[1][i] = dp[1][i-1]; dp[2][i] = max(dp[2][i-1] + 1, dp[1][i-1] + 1); dp[3][i] = dp[3][i-1]; &#125; else&#123; dp[0][i] = dp[0][i-1]; dp[1][i] = max(dp[0][i-1] + 1, dp[1][i-1] + 1); dp[2][i] = dp[2][i-1]; dp[3][i] = max(dp[2][i-1] + 1, dp[3][i-1] + 1); &#125; &#125; int res = 0; for(int i = 0; i &lt; 4; i++)&#123; if(res &lt; dp[i][n-1]) res = dp[i][n-1]; &#125; printf("%d\n", res); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>CodeForces</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 中 Markdown 与 MathJax 冲突解决]]></title>
    <url>%2F2018%2F05%2F22%2Fmarkdown-mathjax-syntax-collision%2F</url>
    <content type="text"><![CDATA[症状在网上找到的MathJax的公式，直接粘贴到Markdown文档中发现，显示格式不正确。比如：1234mathjax的大括号$$\&#123;x\&#125;$$mathjax的换行符$$f(b) = \begin&#123;cases&#125; b[1] \\ b[2] \end&#123;cases&#125;$$ 在hexo中的实际效果为$${x}$$$$f(b) = \begin{cases} b[1] \ b[2] \end{cases}$$我的大括号呢？说好的换行符呢？怎么不显示了？ 分析在hexo生成中，markdown会将文档先一步渲染，将某些字符转义，之后再是MathJax的渲染。在这个过程中会有冲突。对于大括号，markdown渲染器会将\{或是\}转义为{或是}，再等到MathJax渲染的时候当然就不对了。因为\没了啊。对于换行符，markdown渲染器会将\\转义为\，再到MathJax渲染的时候发现就剩一个了，所以就不换行了。 解决方法网上的一些解决方式都是修改mark.js中的正则表达式，来限制markdown的转义。或是npm安装一些东西来控制这些。有点粗暴。遇到类似的情况，发现是markdown先转义了，我的解决方法是，允许markdown转义，但要保证轮到MathJax转义的时候表达式是正确的。1234mathjax的大括号$$\\&#123;x\\&#125;$$mathjax的换行符$$f(b) = \begin&#123;cases&#125; b[1] \\\\ b[2] \end&#123;cases&#125;$$ 改成上边这样，结果实际效果就正确了。$$\{x\}$$$$f(b) = \begin{cases} b[1] \\ b[2] \end{cases}$$]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Markdown</tag>
        <tag>MathJax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MathJax 基本语法学习笔记]]></title>
    <url>%2F2018%2F05%2F22%2Fmathjax-learning-note%2F</url>
    <content type="text"><![CDATA[显示公式在行中显示，就用$...$单独一行显示，则用$$...$$ 上标和下标上标用^，下标用_。如果上下标符号要显示两个以上的字符，用{}括起来。 $x^2$ 表示 $x^2$$\log_2 x$ 表示 $\log_2 x$$x^{10}$ 表示 $x^{10}$ 希腊字母小写开头字母就小写，大写的话开头字母就大写，前提是该希腊字符有大写。 $\alpha, \beta, …, \omega$ 表示 $\alpha, \beta, …, \omega$$\Gamma, \Delta, …, \Omega$ 表示 $\Gamma, \Delta, …, \Omega$ 括号 小括号，$()$ 表示 $()$方括号，$[]$ 表示 $[]$花括号，$\\{\\}$ 表示 $\{\}$绝对值符号，$\vert x \vert$ 表示 $\vert x \vert$范数符号，$\Vert x \Vert$ 表示 $\Vert x \Vert$尖角符号，$\langle x \rangle$ 表示 $\langle x \rangle$向上取整符号，$\lceil \rceil$ 表示 $\lceil \rceil$向下取整符号，$\lfloor \rfloor$ 表示 $\lfloor \rfloor$ 括号默认不会随着高度伸缩，如果需要伸缩，用\left(…\right)来进行自动伸缩。\left和\right在三种括号，绝对值符号，范数符号，尖角符号，向上下取整符号中有用 不伸缩，$(\frac{\sqrt x}{y^3})$ 表示 $(\frac{\sqrt x}{y^3})$伸缩，$\left(\frac{\sqrt x}{y^3}\right)$ 表示 $\left(\frac{\sqrt x}{y^3}\right)$ 如果只需显示一半的符号，可以用.来表示另一边为空。$\left. \frac 1 2 \right \rbrace$ 表示 $\left. \frac 1 2 \right \rbrace$当然也可以手动调整括号的大小，如$\Bigl(\bigl((x)\bigr)\Bigr)$ 表示 $\Bigl(\bigl((x)\bigr)\Bigr)$ 求和与积分 求和，$\sum_1^n$ 表示 $\sum_1^n$积分，$\int_1^n$ 表示 $\int_1^n$连乘，$\prod$ 表示 $\prod$并集，$\bigcup$ 表示 $\bigcup$交集，$\bigcap$ 表示 $\bigcap$重积分，$\iint$ 表示 $\iint$ 分数 $\frac a b$ 表示 $\frac a b$${a+1 \over b+1}$ 表示 ${a+1 \over b+1}$ 根号 $\sqrt {x^3}$ 表示 $\sqrt {x^3}$$\sqrt[3] {\frac x y}$ 表示 $\sqrt[3] {\frac x y}$ 极限 $\lim_{x \to 0}$ 表示 $\lim_{x \to 0}$ 空格$a\, a\; a\quad a\qquad a$ 表示 $a\, a\; a\quad a\qquad a$加入一段文字，可用$\\{x \in s \mid x \text{ is extra large}\\}$表示 $\{x \in s \mid x \text{ is extra large}\}$在\text{...}里面还可以嵌套$...$ 转义符一般情况下用\来作转义，但如果想要转义\，需要用\backslash，\\表示换行。 符号总结$\pm$ 表示 $\pm$$\times$ 表示 $\times$$\div$ 表示 $\div$$\sum$ 表示 $\sum$$\prod$ 表示 $\prod$$\coprod$ 表示 $\coprod$$\mid$ 表示 $\mid$$\nmid$ 表示 $\nmid$$\cdot$ 表示 $\cdot$$\leq$ 表示 $\leq$$\geq$ 表示 $\geq$$\neq$ 表示 $\neq$$\approx$ 表示 $\approx$$\equiv$ 表示 $\equiv$$\circ$ 表示 $\circ$$\ast$ 表示 $\ast$$\bigodot$ 表示 $\bigodot$$\bigotimes$ 表示 $\bigotimes$$\bigoplus$ 表示 $\bigoplus$$\mapsto$ 表示 $\mapsto$$\longmapsto$ 表示 $\longmapsto$$\hookleftarrow$ 表示 $\hookleftarrow$$\hookrightarrow$ 表示 $\hookrightarrow$$\leftharpoonup$ 表示 $\leftharpoonup$$\rightharpoonup$ 表示 $\rightharpoonup$$\leftharpoondown$ 表示 $\leftharpoondown$$\rightharpoondown$ 表示 $\rightharpoondown$$\rightleftharpoons$ 表示 $\rightleftharpoons$$\leadsto$ 表示 $\leadsto$$\nearrow$ 表示 $\nearrow$$\searrow$ 表示 $\searrow$$\swarrow$ 表示 $\swarrow$$\nwarrow$ 表示 $\nwarrow$$\nleftarrow$ 表示 $\nleftarrow$$\nrightarrow$ 表示 $\nrightarrow$$\nLeftarrow$ 表示 $\nLeftarrow$$\nRightarrow$ 表示 $\nRightarrow$$\nleftrightarrow$ 表示 $\nleftrightarrow$$\nLeftrightarrow$ 表示 $\nLeftrightarrow$$\dashrightarrow$ 表示 $\dashrightarrow$$\dashleftarrow$ 表示 $\dashleftarrow$$\leftleftarrows$ 表示 $\leftleftarrows$$\leftrightarrows$ 表示 $\leftrightarrows$$\Lleftarrow$ 表示 $\Lleftarrow$$\twoheadleftarrow$ 表示 $\twoheadleftarrow$$\leftarrowtail$ 表示 $\leftarrowtail$$\looparrowleft$ 表示 $\looparrowleft$$\leftrightharpoons$ 表示 $\leftrightharpoons$$\curvearrowleft$ 表示 $\curvearrowleft$$\circlearrowleft$ 表示 $\circlearrowleft$$\Lsh$ 表示 $\Lsh$$\upuparrows$ 表示 $\upuparrows$$\upharpoonleft$ 表示 $\upharpoonleft$$\downharpoonleft$ 表示 $\downharpoonleft$$\multimap$ 表示 $\multimap$$\leftrightsquigarrow$ 表示 $\leftrightsquigarrow$$\rightrightarrows$ 表示 $\rightrightarrows$$\rightleftarrows$ 表示 $\rightleftarrows$$\rightrightarrows$ 表示 $\rightrightarrows$$\rightleftarrows$ 表示 $\rightleftarrows$$\twoheadrightarrow$ 表示 $\twoheadrightarrow$$\rightarrowtail$ 表示 $\rightarrowtail$$\looparrowright$ 表示 $\looparrowright$$\rightleftharpoons$ 表示 $\rightleftharpoons$$\curvearrowright$ 表示 $\curvearrowright$$\circlearrowright$ 表示 $\circlearrowright$$\Rsh$ 表示 $\Rsh$$\downdownarrows$ 表示 $\downdownarrows$$\upharpoonright$ 表示 $\upharpoonright$$\downharpoonright$ 表示 $\downharpoonright$$\rightsquigarrow$ 表示 $\rightsquigarrow$$\uparrow$ 表示 $\uparrow$$\downarrow$ 表示 $\downarrow$$\Uparrow$ 表示 $\Uparrow$$\Downarrow$ 表示 $\Downarrow$$\updownarrow$ 表示 $\updownarrow$$\Updownarrow$ 表示 $\Updownarrow$$\rightarrow$ 表示 $\rightarrow$$\leftarrow$ 表示 $\leftarrow$$\Rightarrow$ 表示 $\Rightarrow$$\Leftarrow$ 表示 $\Leftarrow$$\leftrightarrow$ 表示 $\leftrightarrow$$\Leftrightarrow$ 表示 $\Leftrightarrow$$\longrightarrow$ 表示 $\longrightarrow$$\longleftarrow$ 表示 $\longleftarrow$$\Longrightarrow$ 表示 $\Longrightarrow$$\Longleftarrow$ 表示 $\Longleftarrow$$\longleftrightarrow$ 表示 $\longleftrightarrow$$\Longleftrightarrow$ 表示 $\Longleftrightarrow$$\emptyset$ 表示 $\emptyset$$\in$ 表示 $\in$$\notin$ 表示 $\notin$$\subset$ 表示 $\subset$$\supset$ 表示 $\supset$$\subseteq$ 表示 $\subseteq$$\supseteq$ 表示 $\supseteq$$\bigcap$ 表示 $\bigcap$$\bigcup$ 表示 $\bigcup$$\bigvee$ 表示 $\bigvee$$\bigwedge$ 表示 $\bigwedge$$\biguplus$ 表示 $\biguplus$$\bigsqcup$ 表示 $\bigsqcup$$\because$ 表示 $\because$$\therefore$ 表示 $\therefore$$\forall$ 表示 $\forall$$\exists$ 表示 $\exists$$\not=$ 表示 $\not=$$\not&gt;$ 表示 $\not&gt;$$\not\subset$ 表示 $\not\subset$$\aleph$ 表示 $\aleph$$\beth$ 表示 $\beth$$\daleth$ 表示 $\daleth$$\gimel$ 表示 $\gimel$$\alpha$ 表示 $\alpha$$\beta$ 表示 $\beta$$\gamma$ 表示 $\gamma$$\Gamma$ 表示 $\Gamma$$\digamma$ 表示 $\digamma$$\delta$ 表示 $\delta$$\Delta$ 表示 $\Delta$$\epsilon$ 表示 $\epsilon$$\varepsilon$ 表示 $\varepsilon$$\zeta$ 表示 $\zeta$$\eta$ 表示 $\eta$$\theta$ 表示 $\theta$$\Theta$ 表示 $\Theta$$\vartheta$ 表示 $\vartheta$$\iota$ 表示 $\iota$$\kappa$ 表示 $\kappa$$\varkappa$ 表示 $\varkappa$$\lambda$ 表示 $\lambda$$\Lambda$ 表示 $\Lambda$$\mu$ 表示 $\mu$$\nu$ 表示 $\nu$$\xi$ 表示 $\xi$$\Xi$ 表示 $\Xi$$\pi$ 表示 $\pi$$\Pi$ 表示 $\Pi$$\varpi$ 表示 $\varpi$$\rho$ 表示 $\rho$$\varrho$ 表示 $\varrho$$\sigma$ 表示 $\sigma$$\Sigma$ 表示 $\Sigma$$\varsigma$ 表示 $\varsigma$$\varsigma$ 表示 $\varsigma$$\tau$ 表示 $\tau$$\upsilon$ 表示 $\upsilon$$\Upsilon$ 表示 $\Upsilon$$\phi$ 表示 $\phi$$\Phi$ 表示 $\Phi$$\varphi$ 表示 $\varphi$$\chi$ 表示 $\chi$$\psi$ 表示 $\psi$$\Psi$ 表示 $\Psi$$\omega$ 表示 $\omega$$\Omega$ 表示 $\Omega$]]></content>
      <categories>
        <category>Language</category>
      </categories>
      <tags>
        <tag>MathJax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM CodeForces 894 A 题解 DP]]></title>
    <url>%2F2018%2F05%2F21%2Facm-cf-894a-dp%2F</url>
    <content type="text"><![CDATA[题目A. QAQ 限制time limit per test: 1 secondmemory limit per test: 256 megabytesinput: standard inputoutput: standard output 描述“QAQ” is a word to denote an expression of crying. Imagine “Q” as eyes with tears and “A” as a mouth.Now Diamond has given Bort a string consisting of only uppercase English letters of length n. There is a great number of “QAQ” in the string (Diamond is so cute!).Bort wants to know how many subsequences “QAQ” are in the string Diamond has given. Note that the letters “QAQ” don’t have to be consecutive, but the order of letters should be exact. 输入格式The only line contains a string of length $n$$(1 \le n \le 100)$. It’s guaranteed that the string only contains uppercase English letters. 输出格式Print a single integer — the number of subsequences “QAQ” in the string. 样本1QAQAQYSYIOIWIN 14 1QAQQQZZYNOIWIN 13 提示In the first example there are 4 subsequences “QAQ”: “QAQAQYSYIOIWIN”, “QAQAQYSYIOIWIN”, “QAQAQYSYIOIWIN”, “QAQAQYSYIOIWIN”. 思路用dp;dp[0][i]代表前i个字符内Q字符出现的次数。dp[1][i]代表前i个字符内QA序列出现的次数。QA序列是QA对，QA两个字符不一定连续。dp[2][i]代表前i个字符内QAQ序列出现的次数。可以用滚动数组来减少空间复杂度。本代码中没有使用滚动数组。 代码12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;char str[110];int dp[3][110];int main()&#123; while(~scanf("%s", str))&#123; memset(dp, 0, sizeof dp); int len = strlen(str); for(int i = 0; i &lt; len; i++)&#123; if(i == 0)&#123; if(str[i] == 'Q')&#123; dp[0][i] = 1; &#125; continue; &#125; if(str[i] == 'Q')&#123; dp[0][i] = dp[0][i-1] + 1; dp[1][i] = dp[1][i-1]; dp[2][i] = dp[2][i-1] + dp[1][i-1]; &#125; else if(str[i] == 'A')&#123; dp[0][i] = dp[0][i-1]; dp[1][i] = dp[0][i-1] + dp[1][i-1]; dp[2][i] = dp[2][i-1]; &#125; else&#123; dp[0][i] = dp[0][i-1]; dp[1][i] = dp[1][i-1]; dp[2][i] = dp[2][i-1]; &#125; &#125; printf("%d\n", dp[2][len-1]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>CodeForces</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows10 C盘 空间容量提升]]></title>
    <url>%2F2018%2F05%2F20%2Fwindows-c-partition-space-clean%2F</url>
    <content type="text"><![CDATA[症状作为一个开发者，在使用windows的过程中，发现windows的C盘空间越来越小，这可怎么办呢？经过排查发现主要是C盘用户目录下的东西增长了。下面我们说几种能够提升一下C盘空间的方法。 用户目录移动windows10有了一个功能，能够将用户目录移动到别的目录。在C:\Users\yunhao目录下，基本上大部分的文件夹都能够移动到别的目录，右键文件夹，打开属性。可以在位置选项下选择新的位置存放该文件夹，然后会弹出对话框问你是不是要将原文件夹的内容移动过去。选是就行。 设置更改存储位置windows10的设置也能够更改内容的默认存储位置。windows键+I唤出设置，系统-&gt;存储，可以看到右侧更改新内容的保存位置。然后改到对应的目录就行了。 想法以下字符请自行产生映射 想法 -&gt; IDEA 因特尔 -&gt; intel 属性 -&gt; properties 如果你安装了想法，那么在用户目录下会看到.因特尔lij想法这个目录。想要移动这个目录，需要在想法安装目录下的bin文件夹下找到想法.属性这个文件，然后改user.home那两行。 Gradle用户目录下.gradle目录的移动，需要新建环境变量GRADLE_USER_HOME，值为你要移动的到的目录\.gradle，需要写上.gradle。 Android SDK用户目录下.android目录的移动，需要新建环境变量ANDROID_SDK_HOME，值为你要移动到的目录，最后不用写上.android。 Maven用户目录下的.m2目录的移动，需要在maven安装目录下conf文件夹下的setting.xml中改&lt;localRepository&gt;你要移动到的目录/.m2/repository&lt;/localRepository&gt; Vagrant用户目录下的.vagrant.d目录的移动，需要新建环境变量VAGRANT_HOME，值为你要移动到的目录\.vagrant.d，需要写上.vagrant.d。]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM CodeForces 983 B 题解 DP]]></title>
    <url>%2F2018%2F05%2F20%2Facm-cf-983b-dp%2F</url>
    <content type="text"><![CDATA[题目B. XOR-pyramid 限制time limit per test: 2 secondsmemory limit per test: 512 megabytesinput: standard inputoutput: standard output 描述For an array $b$ of length $m$ we define the function $f$ as$$f(b) = \begin{cases} b[1] &amp; \quad \text{if } m = 1 \\ f(b[1] \oplus b[2],b[2] \oplus b[3],\dots,b[m-1] \oplus b[m]) &amp; \quad \text{otherwise,} \end{cases}$$where $\oplus$ is bitwise exclusive OR.For example,$$f(1,2,4,8)=f(1\oplus2,2\oplus4,4\oplus8)=f(3,6,12)=f(3\oplus6,6\oplus12)=f(5,10)=f(5\oplus10)=f(15)=15$$You are given an array $a$ and a few queries. Each query is represented as two integers $l$ and $r$. The answer is the maximum value of $f$ on all continuous subsegments of the array $a_l, a_{l+1}, \ldots, a_r$ 输入格式The first line contains a single integer $n$ $(1 \le n \le 5000)$ — the length of $a$.The second line contains $n$ integers $a_1, a_2, \dots, a_n (0 \le a_i \le 2^{30}-1)$ — the elements of the array.The third line contains a single integer $q$ $(1 \le q \le 100000)$ — the number of queries.Each of the next $q$ lines contains a query represented as two integers $l, r$ $(1 \le l \le r \le n)$. 输出格式Print q lines — the answers for the queries. 样本1234538 4 122 31 2 12512 123456761 2 4 8 16 3241 62 53 41 2 12346030123 提示In first sample in both queries the maximum value of the function is reached on the subsegment that is equal to the whole segment.In second sample, optimal segment for first query are $[3,6]$, for second query — $[2,5]$, for third — $[3,4]$, for fourth — $[1,2]$ 思路用dp，dp右上半个数组存储f(l到r)的值，dp左下半个数组存储l到r区间内子串的最大f函数值提前打表，用递归的方式会超时。亲测。 代码123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int n, q, l, r;int dp[5005][5005];void calc()&#123; for (int i = 2; i &lt;= n; i++)&#123; for(int j = 0; j &lt; n-i+1; j++)&#123; int x = j+1, y = i+j; dp[x][y] = dp[x+1][y] ^ dp[x][y-1]; dp[y][x] = max(dp[x][y], max(dp[y][x+1], dp[y-1][x])); &#125; &#125;&#125;int main()&#123; while(~scanf("%d", &amp;n))&#123; for (int i = 1; i &lt;= n; i++)&#123; scanf("%d", &amp;dp[i][i]); &#125; calc(); scanf("%d", &amp;q); for (int w = 0; w &lt; q; w++)&#123; scanf("%d%d", &amp;l, &amp;r); printf("%d\n", dp[r][l]); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>CodeForces</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM HDU 2577 题解 DP]]></title>
    <url>%2F2018%2F05%2F19%2Facm-hdu-2577-dp%2F</url>
    <content type="text"><![CDATA[题目How to Type 限制Time Limit: 2000/1000 MS(JAVA/Others)Memory Limit: 32768/32768 K (JAVA/Others) 描述Pirates have finished developing the software.He called Cathy to test his typing software. She is good at thinking. After testing for several days, she finds that if she types a string by some ways, she will type the key at least. But she has a bad habit that if the caps lock is on, she must turn off it, after she finishes typing. Now she wants to know the smallest times of typing the key to finish typing a string. 输入格式The first line is an integer $t$ $(t \le 100)$, which is the number of test case in the input file. For each test case, there is only one string which consists of lowercase letter and upper case letter. The length of the string is at most 100. 输出格式For each test case, you must output the smallest times of typing the key to finish typing this string. 样本12343PiratesHDUacmHDUACM 123888 提示The string “Pirates”, can type this way, Shift, p, i, r, a, t, e, s, the answer is 8.The string “HDUacm”, can type this way, Caps lock, h, d, u, Caps lock, a, c, m, the answer is 8The stirng “HDUACM”, can type this way, Caps lock, h, d, u, a, c, m, Caps lock, the answer is 8 思路用动态规划dp[0][j]代表，输入完j个字符之后保持在小写状态的情况下，最小的按键次数。dp[1][j]代表，输入完j个字符之后保持在大写状态的情况下，最小的按键次数。可以考虑用滚动数组，这样可以将数组缩小到dp[2][2]。本解法没用滚动数组。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int t;char s[110];int dp[2][110];int main()&#123; scanf("%d", &amp;t); while(t--)&#123; scanf("%s", s); int len = strlen(s); memset(dp, 0x3f, sizeof dp); for (int i = 0; i &lt; len; i++)&#123; if(s[i] &gt;= 'a' &amp;&amp; s[i] &lt;= 'z')&#123; if(i == 0)&#123; dp[0][i] = 1; dp[1][i] = 2; &#125; else&#123; dp[0][i] = min(dp[0][i-1]+1, dp[1][i-1]+2); dp[1][i] = min(dp[1][i-1]+2, dp[0][i-1]+2); &#125; &#125; else&#123; if(i == 0)&#123; dp[0][i] = 2; dp[1][i] = 2; &#125; else&#123; dp[0][i] = min(dp[0][i-1]+2, dp[1][i-1]+2); dp[1][i] = min(dp[1][i-1]+1, dp[0][i-1]+2); &#125; &#125; &#125; int res = min(dp[0][len-1], dp[1][len-1]+1); printf("%d\n", res); &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>DP</category>
      </categories>
      <tags>
        <tag>ACM</tag>
        <tag>DP</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu16.04 Nginx 反向代理 Apache]]></title>
    <url>%2F2017%2F04%2F07%2Fubuntu-nginx-apache-reverse-proxy%2F</url>
    <content type="text"><![CDATA[Nginx 处理静态界面的性能比 Apache 要高很多，Nginx 同样能够抗并发。但是对于 php 等，Nginx 可以通过 FastCGI 转给 php-fpm 处理。在这个过程中，还是可能会出现403等问题。如果能够让 Nginx 反向代理 Apache 就完美了。 Nginx 的优缺点 轻量级，比apache占用更少的内存及资源 抗并发，nginx处理请求是异步非阻塞的，而apache则是阻塞型的，在高并发下nginx能保持低资源低消耗高性能 没Apache稳定 Apache 的优缺点 rewrite，比nginx的rewrite强大 模块化，结构清晰 稳定，bug较少 思路让Nginx始终监听80端口，做反向代理服务器，Apache退居二线，当遇到Nginx处理不了的请求时候，让Apache处理，处理之后，在返回给Nginx。帖子以php为例。 取消 Nginx 的 FastCGI 代理如果只用Nginx来跑php项目的同学，一定设置过FastCGI代理给php-fpm，我们先取消这个代理，这样的话，Nginx就不能处理php了，能够便于之后的测试。在/etc/nginx/sites-available/default文件中。12cd /etc/nginx/sites-availablesudo vim default 找到如下的地方。12345678910# pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000#location ~ \.php$ &#123;# include snippets/fastcgi-php.conf;## # With php7.0-cgi alone:# fastcgi_pass 127.0.0.1:9000;# # With php7.0-fpm:# fastcgi_pass unix:/run/php/php7.0-fpm.sock;&#125; 将上面的东西注释掉。之后让nginx的配置文件重新载入一下。123sudo systemctl reload nginxcd /var/www/htmlsudo vim index.php 在/var/www/html目录下新建index.php文件。文件中输入1&lt;?php echo phpinfo(); ?&gt; 这个时候，我们访问http://localhost/index.php会发现直接进行下载，没有进行解析。显然，nginx已经失去了解析php的功能。然后我们停止nginx。1sudo systemctl stop nginx 安装 Apache如果没有安装Apache的同学请安装apache1sudo apt install apache2 修改 Apache 的 ports.conf现在我们修改apache的配置文件，好让apache，退居二线。在/etc/apache2目录下，找到ports.conf文件，这个文件中，我们可以看到，是用来注册监听端口的文件。在apache2.conf文件中被包含进去了。12cd /etc/apache2sudo vim ports.conf 文件中的内容如下。123456789101112131415# If you just change the port or add more ports here, you will likely also# have to change the VirtualHost statement in# /etc/apache2/sites-enabled/000-default.confListen 80&lt;IfModule ssl_module&gt; Listen 443&lt;/IfModule&gt;&lt;IfModule mod_gnutls.c&gt; Listen 443&lt;/IfModule&gt;# vim: syntax=apache ts=4 sw=4 sts=4 sr noet 我们可以看到这个文件中最上面的说明。如果更改或者增加了监听端口的话，有也得在000-default.conf文件中做更改。好，现在我们把Listen 80改成Listen 8080，也就是说，我们取消监听80端口，改成监听8080端口。然后保存。 修改 Apache 的 000-default.conf我们修改好了ports.conf，还要修改000-default.conf。12cd /etc/apache2/sites-availablesudo vim 000-default.conf 打开文件之后，我们就可以看到12345678910111213141516171819202122232425262728293031&lt;VirtualHost *:80&gt; # The ServerName directive sets the request scheme, hostname and port that # the server uses to identify itself. This is used when creating # redirection URLs. In the context of virtual hosts, the ServerName # specifies what hostname must appear in the request's Host: header to # match this virtual host. For the default virtual host (this file) this # value is not decisive as it is used as a last resort host regardless. # However, you must set it for any further virtual host explicitly. #ServerName www.example.com ServerAdmin webmaster@localhost DocumentRoot /var/www/html # Available loglevels: trace8, ..., trace1, debug, info, notice, warn, # error, crit, alert, emerg. # It is also possible to configure the loglevel for particular # modules, e.g. #LogLevel info ssl:warn ErrorLog $&#123;APACHE_LOG_DIR&#125;/error.log CustomLog $&#123;APACHE_LOG_DIR&#125;/access.log combined # For most configuration files from conf-available/, which are # enabled or disabled at a global level, it is possible to # include a line for only one particular virtual host. For example the # following line enables the CGI configuration for this host only # after it has been globally disabled with "a2disconf". #Include conf-available/serve-cgi-bin.conf&lt;/VirtualHost&gt;# vim: syntax=apache ts=4 sw=4 sts=4 sr noet 上面的第一行&lt;VirtualHost *:80&gt;。是虚拟主机的配置项。*:80的意思是所有ip的80端口。刚刚我们在ports.conf中只注册了8080端口，那么，我们同样也需要将这个位置的80改成8080。退出保存。1sudo systemctl reload apache2 现在apache就退居二线了。也就是说，80端口已经不被apache占用了。我们可以启动nginx了。1sudo systemctl start nginx 这个时候，nginx就能够成功启动了。如果不更改Apache监听端口的话，nginx是无法启动的，因为他们同时监听80端口。 测试1我们先来测试一波，现在我们访问http://localhost/index.php会发现，直接下载index.php。但是我们访问http://localhost:8080/index.php会发现，能够成功解析界面。因为，前者是通过nginx来处理的，而后者是通过apache来处理的，所以显示的结果不一样。 Nginx 做 Apache 的反向代理现在我们要让nginx遇到php文件的时候，交给apache去处理，然后，返回结果。期待已久了吧？我们要修改nginx的default文件。12cd /etc/nginx/sites-availablesudo vim default 我们需要在处理匹配php的正则表达式的location下加一个代理。1234567891011# pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000#location ~ \.php$ &#123;# include snippets/fastcgi-php.conf;## # With php7.0-cgi alone:# fastcgi_pass 127.0.0.1:9000;# # With php7.0-fpm:# fastcgi_pass unix:/run/php/php7.0-fpm.sock; proxy_pass http://localhost:8080;&#125; 这句话的意思就是，匹配到php文件的时候，交给localhost:8080去处理。我们都知道localhost:8080是apache所在的位置。所以，这个反向代理就成功了。1sudo systemctl reload nginx 我们重新载入一下nginx的配置文件。 测试2现在，一切都OK了。我们再测试一下。首先访问http://localhost/index.php。这个时候，就能够成功的显示界面了。可以看出php已经被解析了。然后如果，我们关闭apache的服务。1sudo systemctl stop apache2 这个时候，我们再访问，http://localhost/index.php。我们会发现，还是解析不了，是因为apache关闭的原因了。所以，这个真的是apache处理的php文件。当然，我们也可以通过，界面显示内容的server API 来判断是谁解析的php文件。记得将nginx和apache都设置一下开机启动。]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>代理</tag>
        <tag>Ubuntu</tag>
        <tag>Nginx</tag>
        <tag>Apache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正向代理与反向代理]]></title>
    <url>%2F2017%2F04%2F07%2Fforward-proxy-and-reverse-proxy%2F</url>
    <content type="text"><![CDATA[什么是代理呢？用了这么久的Nginx，也听说过Nginx搭建反向代理服务器。正向代理是什么？反向代理是什么？两者的区别呢？ 代理打个比方，代理就是我们生活中所熟知的中介。他负责联系服务方和客户方。在服务器层面，就是客户端和服务器中间的一个服务器。这个服务器其实和正常的服务器没什么两样。只不过，他将客户发来的请求，转发到真正处理请求的服务器。或者是下一个代理服务器。正因为有了代理服务器的存在，才有了墙的存在。墙其实就是代理服务器。比如我们访问google.com，代理服务器接受到了这个请求，正常的话，他应该去转发请求的。但是，墙这个代理很邪恶，他不转发，然后告诉你，哎呀，这个没有啊，找不到。然后就访问不了了。 正向代理举个生活中的例子。比如你向隔壁老王借钱，但是隔壁老王和你不熟，不借给你。然后呢？你想到了，隔壁老王和你媳妇熟啊，于是，你让你媳妇跟隔壁老王借钱，隔壁老王一看是你媳妇和他借钱，十分爽快的答应了。然后你媳妇把借来的钱又给你了。综上，隔壁老王只知道把钱借给你媳妇了，不知道实际上是借给你了。而你，知道这一切。你就是客户，你媳妇就是正向代理服务器，老王就是真正的服务器。客户向代理服务器请求，代理服务器向真正的服务器请求。然后处理之后的请求，代理服务器再转给你。整个过程中，客户知道代理服务器的存在。而真正的服务器，感知不到客户的存在，只能感知到代理服务器的存在。 对他来说，代理服务器就是他的客户，所以他感知不到真正的客户。 反向代理举个生活中的例子，你遇到了坏人，然后急中生智，你掏出了手机，打电话给110。然后打通了，过了一会儿，警察来了，然后把坏人抓走了。等等，仔细想一下，全国都哪都有警察，为什么都打一个电话？拨打110之后，会有一个处理系统，来确认你的位置，然后派出相应的警察来帮助你解决问题。这个过程中，如果你不仔细想，你不会感觉到有这个处理系统的存在的。你也不知道，到底哪个地方的110来帮你解决问题，你只知道有警察来了，问题解决了。在上面这个过程中，你就是客户，处理系统就是反向代理服务器，警察就是对应的服务器。反向代理服务器，让客户感觉到方便，向反向代理服务器请求，就好像向真的服务器请求一样。客户无法感知到真正的服务器的存在的。 区别图中的两个方框对与方框之外的事物，像黑盒一样。正向代理服务器是对真正服务器透明，真正的服务器，感知不到客户存在。反向代理服务器是对客户透明，客户，感知不到真正的服务器。]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu16.04 Sogou 输入法的备选词框不见了解决方法]]></title>
    <url>%2F2017%2F03%2F30%2Fubuntu-sogou-input-doesnot-work%2F</url>
    <content type="text"><![CDATA[正在写着博客，突然Ubuntu报了一个内部错误，查看详细一看，貌似是关于sogou输入法的。没当回事儿。过了一会儿，搜狗输入法的备选词框不见了，只能输入英文，这可怎么整。赶紧解决了它。 本帖子针对Ubuntu16.04。 症状Sogou输入法的备选词框不见了。只能输入英文，而且按空格键还不能将英文输进去。 解决方法重新安装输入法。首先要卸载之前的输入法。--purge选项是清除配置文件的。更彻底的一种卸载。1sudo apt remove sogoupinyin --purge 当然，单靠这一句话的力量好像并不能解决掉问题。1234cd ~/.configsudo rm -r SogouPY.userssudo rm -r SogouPYsudo rm -r sogou-qimpanel 然后，在这些操作之后，我重启了一下电脑。不知道需不需要这一步之后，安装sogou输入法的依赖1sudo apt install libopencc1 fcitx-libs fcitx-libs-qt fonts-droid-fallback 然后去sogou输入法的官网，找到上面的linux输入法。然后下载最新的deb包。12sudo dpkg -i ~/下载/sogoupinyin_2.1.0.0082_amd64.debreboot 然后再重启一下电脑，sogou输入法就能正常使用了。]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>搜狗输入法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu16.04 FireFox Flash 插件安装]]></title>
    <url>%2F2017%2F03%2F30%2Ffirefox-add-flash-plugins%2F</url>
    <content type="text"><![CDATA[firefox浏览器下载了之后，默认都是没有安装插件的。如何给firefox浏览器安装插件呢？希望下这篇帖子能够帮助你。 flash插件官网去https://get.adobe.com/flashplayer/这个网站，下载对应的flash插件。选择tar.gz下载。 解压解压下载之后的文件。1tar -xzvf flash_player_npapi_linux.x86_64.tar.gz 目录结构解压了之后，我们可以清晰的看到目录结构。12345678910111213.├── flash_player_npapi_linux.x86_64.tar.gz├── LGPL│ ├── LGPL.txt│ └── notice.txt├── libflashplayer.so├── license.pdf├── readme.txt└── usr ├── bin ├── lib ├── lib64 └── share 拷贝文件将libflashplayer.so这个文件拷贝到/usr/lib/firefox-addons/plugins，将usr下的东西拷贝到/usr下。12sudo cp libflashplayer.so /usr/lib/firefox-addons/pluginssudo cp -r usr/ /usr 重启firefox重新启动，firefox，我们就会发现，能够使用flash插件了。]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>浏览器</tag>
        <tag>FireFox</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu16.04 Nginx 配置站点学习笔记]]></title>
    <url>%2F2017%2F03%2F30%2Fnginx-server-config-guide%2F</url>
    <content type="text"><![CDATA[突然想看一看nginx的文件中应该如何写配置信息，于是看了nginx的官方文档。 nginx 的目录结构nginx的目录结构如下12345678910111213141516171819202122.├── conf.d│ └── my.conf├── fastcgi.conf├── fastcgi_params├── koi-utf├── koi-win├── mime.types├── nginx.conf├── proxy_params├── scgi_params├── sites-available│ ├── default│ └── openapi.com├── sites-enabled│ ├── default -&gt; /etc/nginx/sites-available/default│ └── openapi.com -&gt; /etc/nginx/sites-available/openapi.com├── snippets│ ├── fastcgi-php.conf│ └── snakeoil.conf├── uwsgi_params└── win-utf 这个目录结构是用tree这个东西搞出来的。感兴趣的同学可以安装一下。个人感觉挺好用的。1234sudo apt-get install treetree --helpcd /etc/nginxtree 这样就会出现上面的文件目录了。 nginx.conf首先我们查看一下nginx.conf的文件内容。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364user www-data;worker_processes auto;pid /run/nginx.pid;events &#123; worker_connections 768; # multi_accept on;&#125;http &#123; ## # Basic Settings ## sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; # server_tokens off; # server_names_hash_bucket_size 64; # server_name_in_redirect off; include /etc/nginx/mime.types; default_type application/octet-stream; ## # SSL Settings ## ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # Dropping SSLv3, ref: POODLE ssl_prefer_server_ciphers on; ## # Logging Settings ## access_log /var/log/nginx/access.log; error_log /var/log/nginx/error.log; ## # Gzip Settings ## gzip on; gzip_disable "msie6"; # gzip_vary on; # gzip_proxied any; # gzip_comp_level 6; # gzip_buffers 16 8k; # gzip_http_version 1.1; # gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript; ## # Virtual Host Configs ## include /etc/nginx/conf.d/*.conf; include /etc/nginx/sites-enabled/*;&#125;... 迷之用户我们可以看到，上面的user是www-data，这个是一个用户，没错。linux会创造一些用户，这些用户和普通用户是不一样的。他们主要用来进行一些系统上的的操作。大家可以看一下用户列表。1cat -n /etc/passwd | grep www-data 返回的结果中有一个什么什么nologin，这个东西其实就是限制用户登陆的。好了，不多做介绍。 多个进程nginx是有一个master进程和若干个worker进程的。worker进程负责各种细致的工作，master进程负责管理各种worker进程。我们可以通过一下的命令来查看一下nginx的进程。1ps -aux | grep nginx 具体的输出如下:12345root 1002 0.0 0.0 124972 1444 ? Ss 14:45 0:00 nginx: master process /usr/sbin/nginx -g daemon on; master_process on;www-data 1003 0.0 0.0 125348 3212 ? S 14:45 0:00 nginx: worker processwww-data 1004 0.0 0.0 125348 3212 ? S 14:45 0:00 nginx: worker processwww-data 1005 0.0 0.0 125348 3212 ? S 14:45 0:00 nginx: worker processwww-data 1006 0.0 0.0 125348 3212 ? S 14:45 0:00 nginx: worker process 启动的命令启动nginx的命令有好多种方式。在这里我介绍一种方式。12345sudo systemctl start nginx 启动nginxsudo systemctl restart nginx 重启nginxsudo systemctl stop nginx 关闭nginxsudo systemctl reload nginx 重新加载nginx的配置文件sudo systemctl status nginx 查看nginx的状态 建议保持一种方式对nginx进行操作。也就是说如果总是用systemctl来操作nginx的状态就一直用systemctl来操作，如果还用别的命令的话，免不了会出问题。之前我就出过问题。如果出了问题怎么办呢？也不要太慌张。kill -9强制杀死就好了。 log文件做一些比较基本的介绍。配置文件中，我们可以很清晰的找到。access_log 和 error_log这两行，这两行后面的目录就是存错误信息的目录，如果访问的时候出现什么404啊什么的。去这两个文件中查看，能够帮助定位错误信息。 注释nginx的配置文件中注释的风格是在一行的开头加#号。这是一句废话。。。 虚拟主机配置我们可以看到nginx.conf最下面的两行include，这个就是在启动nginx的时候，加载的配置文件。在修改配置文件的时候不建议在nginx.conf文件中做改动，建议在conf.d/目录下新建.conf文件，或是在sites-available/目录下新建文件，然后在sites-enabled/目录下做软连接。 配置文件的嵌套格式最外层是http context(上下文)，然后是server context， 最后是location context1234567http&#123; server &#123; location &#123; &#125; &#125;&#125; 配置静态服务器首先打开nginx服务器。12sudo systemctl start nginxsudo systemctl enable nginx 设置开启自启动 我们在新建/test/data目录，与/test/images目录。然后我们在/test目录下新建index.html文件，文件中写/test。在/test/data目录下新建index.html文件，文件中写/test/ data，同样在/test/images下的index.html文件中写/test/images。首先请确保，其他的位置没有定义location /。确保/test/data与/test/images至少有r-xr-xr-x权限。我们在conf.d目录下新建一个my.conf文件。然后编辑该文件。12345678server &#123; location / &#123; root /test/data; &#125; location /images/ &#123; root /test; &#125;&#125; 修改完该文件之后，我们要reload一下1sudo systemctl reload nginx root代表绑定到路由的文件系统。如果如果不写监听端口的话，默认监听80端口。因此这样的话，在浏览器中访问http://localhost/的时候，我们会看到/test/data，如果访问http://localhost/images/我们会看到/test/images。如果出现问题的话，那么可以参考/var/log/nginx/error.log这个文件的最后一行。就是刚刚访问出现问题的地方，或许会有所帮助。 配置代理服务器代理服务器(proxy server)是指将用户发来的请求，发送给被代理方，然后再将被代理方返回的结果，发给用户。也就是说正常的服务器和用户之间的通信被一个类似中介的服务器分成了2段，用户和原来的服务器不直接通信，而是通过代理服务器进行通信。将刚刚的配置文件改成这个样子123456789server &#123; listen 8080; location / &#123; root /test/data; &#125; location /images/ &#123; root /test; &#125;&#125; 然后我们reload一下nginx1sudo systemctl reload nginx 这个时候，我们会发现访问http://localhost/不能显示界面了。这是因为我们把刚刚的两个服务，定到了8080端口。这个时候我们访问的时候需要在后面加上端口号http://localhost:8080/这样的话，就会和刚刚一样了。现在我们再次修改配置文件123456789101112131415server &#123; listen 8080; location / &#123; root /test/data; &#125; location /images/ &#123; root /test; &#125;&#125;server &#123; location / &#123; proxy_pass http://localhost:8080; &#125;&#125; 我们再reload一下。proxy_pass，这个意思是被代理的服务器的地址。我们这个时候访问http://localhost/这个时候，我们会发现，页面显示/test/data。localhost:8080被localhost代理了。如果出现了错误的话，我们就在/var/log/nginx/error.log文件中查看具体的错误信息。 正则匹配location的url还可以使用正则匹配，～号代表的是正则匹配，而后面的就是正则表达式啦。\.(gif|jpg|png)$的意思是，以.gif或者.jpg或者.png结尾的就用这个location定位。当然，你需要在/test/images目录下有对应的图片。123456789101112131415161718server &#123; listen 8080; location / &#123; root /test/data; &#125; location /images/ &#123; root /test; &#125;&#125;server &#123; location / &#123; proxy_pass http://localhost:8080; &#125; location ~ \.(gif|jpg|png)$ &#123; root /test/images; &#125;&#125; 1sudo systemctl reload nginx 记得reload一下。当你访问http://localhost/haha.png的时候，就会发现在/test/images/haha.png的图片显示在了网页上。 FastCGI 代理用过php的大家都知道，nginx是没办法直接和php连起来的。需要一个php-fpm的东西。这个的话，就需要在nginx的配置文件中增加fastcgi_pass这个东西。和proxy_pass类似。在这篇博客中不做叙述。在Ubuntu16.04 PHP Nginx 配置这篇博客中详细说明。 匹配方式nginx官方文档中说明。在匹配location的时候，首先匹配直接指明的location前缀，之后再匹配正则表达式。匹配直接指明的location前缀的时候，按能匹配到最长前缀进行匹配。之后，再进行正则表达式匹配，正则表达式匹配中，如果有多个能够匹配上，按出现时间最早的进行匹配。]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
        <tag>Ubuntu</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo NexT Disqus 评论插件]]></title>
    <url>%2F2017%2F03%2F29%2Fhexo-disqus-comments%2F</url>
    <content type="text"><![CDATA[自从多说关闭之后，第三方的评论工具让人找了又找。于是我找到了Disqus。本文针对说明NexT主题与Disqus的配置。 注册Disqus账号登陆disqus.com注册账号。注册过程，不多做说明。 进行邮箱确认注册了disqus账号之后，一定要去邮箱点击一下确认。我当时就是没有点击确认，好像就没有进行下去，还是区点击一下确认吧。 进入 Disqus Home 页应该在disqus.com/home之后点击右上角的齿轮，再点击 Add Disqus To Site。找到页面最下边的 Get Started 按钮。之后点击下面的install Disqus。注意WebsiteName，这个名字要用到配置文件中的。起一个你喜欢的。 设置主题配置文件打开主题配置文件。找到如下的位置：12345# Disqusdisqus: enable: true shortname: ****** count: true shortname的位置就填写刚刚的 WebSite Name 的名字。这样就配置好了。 重新部署123hexo cleanhexo ghexo d PS不过，Disqus墙没墙掉我也不太清楚，让我很是无奈。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atom 插件 browser-plus 修改默认搜索]]></title>
    <url>%2F2017%2F03%2F27%2Fatom-packages-browser-plus-change-default-search-engine%2F</url>
    <content type="text"><![CDATA[安装了atom的browser-plus插件之后，发现url栏的默认搜索是google搜索，想要改成百度搜索怎么办？ 查找很简单。找到配置文件，首先进行备份，以免以后想要改回来。12cd ~/.atom/packages/browser-plus/libcp ./browser-plus-view.coffee ./browser-plus-view.coffee.backup 修改用vim打开。/http://www.google.com/search?as_q=。查找到三处。将这三处替换为http://www.baidu.com/s?ie=UTF-8&amp;wd=。然后重启atom，测试，生效。]]></content>
      <categories>
        <category>编辑器</category>
      </categories>
      <tags>
        <tag>编辑器</tag>
        <tag>Atom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atom 编辑器的插件总结]]></title>
    <url>%2F2017%2F03%2F27%2Fatom-plugins-guide%2F</url>
    <content type="text"><![CDATA[总结一下我的 Atom 编辑器的 Package，个人认为比较好的一些。 安装插件找到编辑-&gt;设置-&gt;Install，在里面搜索插件的名字，可以直接点安装。有些插件安装出现问题，可以到 atom.io/packages 这个网站上去所搜，然后找到github地址。1234cd ~/.atom/packagesgit clone github地址cd 插件目录apm install 或者是 npm install 注意有些插件是需要前置插件的！ Remote-FTP能够连接FTP，显示目录结构。比较有用。 activate-power-modeatom 互动的一个插件，比较有意思。打字的时候会有互动。 atom-beautifyatom 美化代码排版的。当代码格式很乱的时候，就beautify一下。就整齐了。 browser-plusatom集成浏览器，能够在atom中搜索，是不是让搜索更加便捷了呢。 color-picker颜色选择器，前端程序员必备利器。 file-icons让atom的图标更丰富。 git-plus能够在命令界面控制git，感觉不太好用。感觉直接唤出命令行，更容易一些。 language-ocamlocaml语言的高亮，自动自动补全什么的。 markdown-preview-plusmarkdown预览，Ctrl+Shift+M唤出。 markdown-writermarkdown编写的助手吧，不知道具体是做什么的，反正写markdown，我就安装了。 merge-conflicts能够图形化的解决git中的冲突，可以一试。 minimap向sublime一样的右上角的代码缩略图。 ocaml-indentocaml语言的自动缩进。 platformio-ide-terminal让atom能够唤出终端，利器，良心推荐。 remote-edit能够连接服务器并且编辑编辑文件。感觉不够方便，与remote-ftp结合起来，还不错。 simplified-chinese-menu简体中文汉化包，翻译了绝大部分的选项。]]></content>
      <categories>
        <category>编辑器</category>
      </categories>
      <tags>
        <tag>编辑器</tag>
        <tag>Atom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu16.04 GitHub SSH密钥 配置]]></title>
    <url>%2F2017%2F03%2F27%2Fgithub-ssh-config%2F</url>
    <content type="text"><![CDATA[Ubuntu 16.04 如何配置 SSH 与 Github 传输数据 SSH的简介SSH技术是指通信的双方A，B，分别有自己的公钥和私钥，公钥负责加密信息，私钥负责解密信息。设定是这样的A公钥加密的信息，只能通过A的私钥来解密，不能通过其他的私钥来解密，而且通过A的公钥很难推断出A的私钥。通信开始前，双方得知对方的公钥，A给B发送数据，用B的公钥来加密。B给A发送数据用A的公钥来加密。此项技术能够保证通信之间的安全性。即使信息被第三方获取，也无法解密。避免了信息被窃取，篡改，和冒充的情况。 SSH的生成首先查看/home/username/.ssh目录下是否有类似id_rsa和id_rsa.pub这样的一对文件存在。如果存在的话，不需要生成ssh。如果不存在的话，首先生成这样的文件。1ssh-keygen 生成的过程中会有提示，会让你输入两次密码，这个密码是在使用ssh时候输入的，如果不想设置密码，直接按回车。 SSH在Github上的配置登陆Github网站，找到个人设置界面。左侧有 SSH and GPG keys 类似字样的选项，点击。然后新建一个 SSH 的 key， 把/home/username/.ssh/id_rsa.pub中的内容复制过去。然后保存。之后就OK了。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Git</tag>
        <tag>GitHub</tag>
        <tag>OpenSSH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub Hexo blog 绑定域名]]></title>
    <url>%2F2017%2F03%2F27%2Fgithub-hexo-blog-bundle-domain%2F</url>
    <content type="text"><![CDATA[Github 上的 username.github.io 的博客绑定域名操作 创建CNAME文件首先我们要在master分之下创建CNAME文件，文件中写‘你自己想的二级域名.你购买的一级域名’。我的二级域名是www，加上一级域名，所以是www.yunhao.life。这时候就会遇到一个问题，每次在hexo d的时候，CNAME文件会被删除，不要慌，我们将CNAME文件创建在source目录下，然后再进行hexo g的时候，会生成。不用担心CNAME文件被删除的情况。 添加解析去购买域名的网站。找到购买的一级域名。点击解析，然后添加记录。记录类型写CNAME，然后主机记录，就是你要起的二级域名，然后记录值，就是你的github的username.github.io了。我们看介绍可以知道CNAME是针对的两个域名之间的解析，即把记录值的域名，解析成二级域名和一级域名组合成的域名。添加完解析之后，稍等几分钟，访问域名就能看到你的博客了。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Hexo</tag>
        <tag>域名</tag>
        <tag>GitHub</tag>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 备份]]></title>
    <url>%2F2017%2F03%2F27%2Fhexo-backup%2F</url>
    <content type="text"><![CDATA[hexo 备份和移植 创建仓库PS：如果远程已经备份好，只是要pull下来，请跳到恢复一节假设我们的博客的项目目录为blog我们可以看到在blog目录下是没有.git文件夹的。首先，我们先将所有的更改，提交到本地库12git add .git commit -m "backup" 创建backup分支我们新建一个叫做backup的分支。然后切换到该分支，再删除master分支。1234git branch backupgit checkout backupgit branch -d mastergit branch 我们可以通过git branch 查看，只剩一个backup分支。 连接远程我们连接远程库，并进行push操作，如下，远程库会自动建立backup分支。12git remote add origin 你的username.github.io的项目地址git push origin backup:backup 修改push和pull的默认分支保险起见，设置默认的跟踪分支，之后会看到本地的backup分支跟踪origin/backup分支12git push -u origin backupgit branch --set-upstream-to=origin/backup backup 设置了之后，我们再进行git push 或者是git pull的操作的时候就不用担心，会影响到origin/master分支了。 备份之后我们再上传新的帖子的时候，要进行下面的操作。123456hexo cleanhexo ggit add .git commit -m "backup"git pushhexo d 这样就能够备份了 恢复本地的博客丢了怎么办？这样就能够弄一份一模一样的了。1234567891011121314mkdir blogcd bloggit initgit remote add origin 你的username.github.io的项目地址git pull origin backup:backupgit branchgit checkout backupgit branch -d mastergit push -u origin backupgit branch --set-upstream-to=origin/backup backupnpm installhexo cleanhexo ghexo d]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu16.04 PPPoE 拨号上网]]></title>
    <url>%2F2017%2F03%2F27%2Fubuntu-PPPoE-dsl-connection%2F</url>
    <content type="text"><![CDATA[ubuntu PPPoE 拨号登陆校园网 配置信息打开终端，输入sudo pppoeconf之后会出现界面，让你输入用户名，注意这个界面上默认有username，一定要把username全都删掉，再输入用户名才行。之前一直没注意。后面一路选是，直到有一个是询问是否开机自动连接，这个选否。 三条命令我们可以通过plog这条命令来，查看状态。我们可以通过sudo poff -a来断开所有连接。我们下次连接的时候通过pon dsl-provider来连接。]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>PPPoE</tag>
        <tag>DSL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown 学习笔记]]></title>
    <url>%2F2017%2F03%2F26%2Fmarkdown-learning-note%2F</url>
    <content type="text"><![CDATA[Markdown基本语法，帖子的布局格式 段落和换行一个段落的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。如果想要插入换行符&lt;br /&gt;的话，在插入处键入两个以上的空格，然后回车。 标题一共有6级，随着#号增多级数增加123456# 1级标题## 2级标题### 3级标题#### 4级标题##### 5级标题###### 6级标题 2级标题3级标题4级标题5级标题6级标题表格12345表头1 | 表头2 | 表头3---|---|---1.1 | 2.1 | 3.11.2 | 2.2 | 3.21.3 | 2.3 | 3.3 表头1 表头2 表头3 1.1 2.1 3.1 1.2 2.2 3.2 1.3 2.3 3.3 列表无序列表123* 以星号开头+ 以加号开头- 以减号开头 以星号开头 以加号开头 以减号开头 有序列表1231. 火龙窝2. 小火龙3. 火龙果 火龙窝 小火龙 火龙果 强调斜体12*斜体*_斜体_ 斜体_斜体_ 加粗12**加粗**__加粗__ 加粗加粗 删除1~~删除~~ 删除 代码短代码1use `printf()` use printf() 长代码123```c++#include &lt;iostream&gt;``` 1#include &lt;iostream&gt; 引用12345678910111213141516171819202122&gt; 开头加 ‘&gt;’，即可&gt; &gt; 引用中仍然可以使用强调&gt; __haha__&gt; &gt; 引用中仍然可以使用列表&gt; * yes&gt; * no&gt; &gt; 引用中仍然可以使用引用&gt; &gt; haha&gt; &gt; huhu&gt; &gt; 引用中仍然可以使用标题&gt; ## 引用中的标题&gt; &gt; 引用中仍然可以使用代码&gt; `hello`&gt; ```#include &lt;iostream&gt;```&gt; 开头加 ‘&gt;’，即可 引用中仍然可以使用强调haha 引用中仍然可以使用列表 yes no 引用中仍然可以使用引用 hahahuhu 引用中仍然可以使用标题 引用中的标题引用中仍然可以使用代码hello1#include &lt;iostream&gt; 图片与链接图片123![Alt text](/path/to/img.jpg)![Alt text](/path/to/img.jpg "Optional title") 链接1[链接名](http://lmnsyunhao.github.io "标题是鼠标悬停在链接名上是弹出栏的名字") 链接名 水平线12345* * *********- - ---------------------------------------- 转义Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号123456789101112\ 反斜线` 反引号* 星号_ 底线&#123;&#125; 花括号[] 方括号() 括弧# 井字号+ 加号- 减号. 英文句点! 惊叹号]]></content>
      <categories>
        <category>Language</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
